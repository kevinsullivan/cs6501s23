%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother


\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage{unixode}
\definecolor{VerbatimBorderColor}{rgb}{0.7,0.7,0.7}
% from sphinxmanual.cls: put authors on separate lines
\DeclareRobustCommand{\and}{%
   \end{tabular}\kern-\tabcolsep\\\begin{tabular}[t]{c}%
}


\title{Computing Foundations}
\date{Feb 09, 2023}
\release{1.2.2}
\author{Kevin Sullivan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{CS6501 Spring 2023}
\label{\detokenize{A_00_Introduction:cs6501-spring-2023}}\label{\detokenize{A_00_Introduction:introduction}}\label{\detokenize{A_00_Introduction::doc}}

\section{To Think Abstractly}
\label{\detokenize{A_00_Introduction:to-think-abstractly}}
\sphinxAtStartPar
To advance science and engineering, we need languages in
which we can describe and reason about complex worlds. By
a \sphinxstyleemphasis{world} we mean a collection of objects of interest and
their structures, properties, behaviors, relations to each
other.


\subsection{Abstract Mathematics}
\label{\detokenize{A_00_Introduction:abstract-mathematics}}
\sphinxAtStartPar
Mathematics and formal logics provide such languages. They
give us the intellectual tools we need to think abstractly
and yet with great precision about rich and complex systems:
to represent, reason about, and ultimately design complex
worlds that would otherwise remain beyond our grasps.

\sphinxAtStartPar
As an example, the abstract mathematics of linear and affine
spaces give us languages for describing, reasoning about, and
designing systems that work in the \sphinxstyleemphasis{classical} physical world
we experience every day. The abstract mathematics of tensor
fields on topological manifolds are essential for describing,
reasoning about, and designing interventions in the \sphinxstyleemphasis{quantum}
world of particle physics.

\sphinxAtStartPar
By the term, \sphinxstyleemphasis{abstract}, we mean that descriptions in such
languages represent relevant phenomena precisely, concisely,
and without any unnecessary complexity or inessential detail.

\sphinxAtStartPar
As an example, a physicist might represent two accelerations
applied to a drone in a three\sphinxhyphen{}dimensional geometric space in
abstract, coordinate\sphinxhyphen{}free terms, by writing this: \sphinxstyleemphasis{let a₁ and
a₂ be accelerations of the drone.} This formulation is abstract
insofar as no coordinates are given for these vectors. The
assignment of coordinates to \sphinxstyleemphasis{physical} quantities is usually
arbitrary and unnecessary to express. A physicist might, for
example, represent \sphinxstyleemphasis{the sum of these accelerations} simply as
\sphinxstyleemphasis{a₁ + a₂.} This expression has an absolutely precise physical
meaning even though it’s abstract.

\sphinxAtStartPar
A programmer, by contrast, would typically jump to a choice
of some coordinate system and would then represent the two
physical quantities in the concrete (\sphinxstyleemphasis{parametric}) terms of
tuples of floating point numbers; with the summation of the
physical accelerations represented by element\sphinxhyphen{}wise floating
point addition of the corresponding coordinate tuples.


\subsection{Costs of Concreteness}
\label{\detokenize{A_00_Introduction:costs-of-concreteness}}
\sphinxAtStartPar
This ubiquitous approach to programming physical computations
is problematical in multiple dimensions. First, as mentioned,
it substitues concrete representations for abstract, adding
inessesntial complexity to models and computations. Second,
it generally strips away crucial mathematical properties of
the abstract representations of objects of interest, making
it impossible to check programs for consistency with such
mathematics.

\sphinxAtStartPar
For example, in the \sphinxstyleemphasis{tf} and \sphinxstyleemphasis{tf2} affine space libraries of
the Robot Operating System (ROS) platform for the programming
of terrestrial robots, points and vectors are represented in
the concrete terms of coordinate tuples relative to arbitrary
coordinate frames. But it gets worse: points and vectors in
this framework are aliases for the same concrete type: a type
of floating\sphinxhyphen{}point tuples.

\sphinxAtStartPar
This means, among other things, that one can add points to
points in \sphinxstyleemphasis{tf} without receiving any type errors from the
programming language system, even though addition of points
to points makes no physical sense and is inconsistent with
the abstract mathematics of the domain. In an affine space,
there is no operation for adding points to point.

\sphinxAtStartPar
The nearly exclusive use of concrete representations in most
everyday programming complicates software design and reasoning
by requiring the manipulation of often complex, inessential
details. And because so much of the structure of the mathematics
of the domain is \sphinxstyleemphasis{forgotten} in the programming code, it also
becomes impossible for the programming system to check for what
we might call \sphinxstyleemphasis{full physical type consistency}.

\sphinxAtStartPar
Programming code thus generally ends up deeply disconnected
from the abstract mathematics of the physics of the domain that
it’s meant to represent, manipulate, implement, and free to
carry out inconsistent operations. As one example, programmers
often struggle mightily using different frames of reference in
a consistent manner, e.g., by adding vectors represented by
numerical tuples but with coordinates expressed in different
frames of reference.

\sphinxAtStartPar
A special case, by the way, is operating incorrectly on values
because they are expressed in different units, such a meters
and feet. We can understand 1 meter and 1 foot as each being
a basis vector for the \sphinxstyleemphasis{same} one\sphinxhyphen{}dimensional physical space.
Clearly adding numerical values of 2 (feet) and 3 (meters) to
produce 5 of \sphinxstyleemphasis{something,} produces a meaningless result.


\subsection{A Path Forward}
\label{\detokenize{A_00_Introduction:a-path-forward}}
\sphinxAtStartPar
So why haven’t we already deeply connected concrete to code
the abstract mathematics of the domain in which it’s meant
to operate? Perhaps the most fundamental reason is that math
has up until recently been a quasi\sphinxhyphen{}formal, paper\sphinxhyphen{}and\sphinxhyphen{}pencil
exercise, making it, hard even impossible, to connect code
to such mathematics.

\sphinxAtStartPar
Now, with rapidly developing work by a still small set of
ressearchers in mathematics, the complete formalization and
mechanization of advanced abstract mathematics is becoming
a reality. As and example Massot and his colleagues in 2022
managed to formalize not only a statement, but a proof, of
the local h\sphinxhyphen{}principle for first\sphinxhyphen{}order, open, ample partial
differential relations, with the possibility of eversion of
the 3\sphinxhyphen{}sphere as a corollary.

\sphinxAtStartPar
Their work showed that their approach to formalizing
mathematics is no longer useful mostly just for abstract
algebra, but that it also now promises advances in abstract
geometry (e.g., on manifolds), which is at the very heart
of not only terrestrial robotics but also modern physics
and perhaps even areas such areas as deep learning.


\subsection{The Vision}
\label{\detokenize{A_00_Introduction:the-vision}}
\sphinxAtStartPar
The insight driving this class is that this kind of work
from the  mathematics community is now making it possible
to develop \sphinxstyleemphasis{computable abstract mathematics} for purposes
of software engineering. Promising application domains for
such work clearly include divere cyber\sphinxhyphen{}physical systems and
might be relevant to deep learning as well, with its basic
assumption that real\sphinxhyphen{}world data have geometric properties,
such as lying on high\sphinxhyphen{}dimensional manifolds.

\sphinxAtStartPar
What we seek are ways to enable use of the abstract mathematical
languages of such domains, coupled with concrete representations
to support computation, with \sphinxstyleemphasis{full physical type checking} of the
physical mathematics; \sphinxstyleemphasis{foundational proofs} of correctness of the
mathematics; and explicit link to concrete (often coordinate\sphinxhyphen{}based)
representations that are necessary in practical implementations.


\subsection{This Class}
\label{\detokenize{A_00_Introduction:this-class}}
\sphinxAtStartPar
The purpose of this class is to introduce computer science
students to the ideas necessary to pursue both research and
development activities based on these ideas. We will use the
preferred tool of the community of mathematicians pushing the
formalization of mathematics, namely the Lean Proof Assistant,
developed by Leo DeMoura at Microsoft research, and the ever
growing \sphinxstyleemphasis{mathlib} library of formalized mathematics.


\section{Welcome. Overview.}
\label{\detokenize{A_00_Introduction:welcome-overview}}
\sphinxAtStartPar
This is a special topics course in software engineering. The idea
that we will explore is that we can now import ongoing advances
in the formalization of abstract mathematics (in type theory and
to a significant extent around the Lean prover and its mathematics
libraries) as new foundations for engineering software programs for
systems that inhabit domains that have such abstract mathematical
underpinnings. Such domains include physics, and thus also a broad
range of cyber\sphinxhyphen{}physical systems.

\sphinxAtStartPar
Along the way, you’ll learn formal logic and proof construction,
foundations of programming languages, functional programming, and
more. By the end you will know how to use some cutting\sphinxhyphen{}edge tools,
type theory and constructive logic proof assistants, to formalize
the abstract mathematics of important application domains.


\subsection{What does \sphinxstyleemphasis{abstract} mean here?}
\label{\detokenize{A_00_Introduction:what-does-abstract-mean-here}}
\sphinxAtStartPar
Here, the adjective, abstract, means \sphinxstyleemphasis{being coordinate\sphinxhyphen{}free}.
For the opposite of \sphinxstyleemphasis{abstract}, we’ll use \sphinxstyleemphasis{parametric}. The idea
is that a mathematical object, such as a vector, can be understood
simply as such, with no reference to coordinates; or that same abstract
vector can be represented concretely/parametrically as a struture of
parameter values expressed relative to some given frame of reference.


\subsection{Why \sphinxstyleemphasis{abstract} mathematics?}
\label{\detokenize{A_00_Introduction:why-abstract-mathematics}}
\sphinxAtStartPar
A premise of this class is that domain experts (e.g., in the
physics of terrestrial robotics, or of elemenary particles) speak,
model, analyze, and understand the operation of systems in the
abstract mathematical language of the domain, and very often not
in terms of ultimately arbitrarily selected frames of reference .

\sphinxAtStartPar
This is clear in physics where complex mathematical structures
such as tensor fields on topological manifolds are essential for
precise definitions of phenomena in particle physics.

\sphinxAtStartPar
Domain\sphinxhyphen{}specific abstract mathematics formalized in type theory
is what we see as an important language of the domain, to serve
as a basis for programming with static checking of abstractions,
and with parametric representations carried along as necessary.


\subsection{What is the point?}
\label{\detokenize{A_00_Introduction:what-is-the-point}}
\sphinxAtStartPar
A remarkable feature of constructive logics as hosted by many
proof assistants is that they can compute. Computation is now
wholly integral to practical logical reasoning if only because
some proofs require systematic case analysis over very large
numbers of cases, given as the outputs of other computations.

\sphinxAtStartPar
This is is relevant because it suggests that fully formalizing
the fully developed mathematical language of the given domain,
we will be well on our way to having reference specifications
and with computable implementations.

\sphinxAtStartPar
Going even further, the most recent version of Lean is intended
as an efficient general\sphinxhyphen{}purpose programming language as well as
a proof assistant, compiling to C, and with workable language
interoperability interfaces.

\sphinxAtStartPar
In the future we expect to be able to statically type check and
foundationally verify “code” written in the abstract mathematics
of the domain and with very little custom coding needed also to
have corresponding verified implementations, even if only used as
test oracles for production code.

\sphinxAtStartPar
This is the of abstract specifictions from which concrete
implementations are derived. I will not say refined because
in practice most derivations are not refinements but rather
toyish models of semantically rich and complex computations
in the source domain.


\subsection{This class}
\label{\detokenize{A_00_Introduction:id1}}
\sphinxAtStartPar
The first major part of this class will teach you the fundamentals
of programming and reasoning in Lean 3. We will mainly use Lean 3,
nothwithstaning that Lean 4 is garnering real attention and effort.
Student might wish to explore Lean 4 as an optional class activity.

\sphinxAtStartPar
The second part of the class will focus on how to formalized abstract
mathematical structures in Lean, and how we might such capabilities
to  these advances in formalizing mathematics to help meet
the need for statically type checked specifications in the abstract
language of the domain, with corresponding parametric representations
carried along for computational possibly and oher purposes.

\sphinxstepscope


\chapter{Formal Languages}
\label{\detokenize{A_01_Propositional_Logic:formal-languages}}\label{\detokenize{A_01_Propositional_Logic:introduction}}\label{\detokenize{A_01_Propositional_Logic::doc}}

\section{Balanced Parentheses}
\label{\detokenize{A_01_Propositional_Logic:balanced-parentheses}}
\sphinxAtStartPar
As a warmup, and to put some basic
concepts into play, we’ll begin by specifying the syntax
and semantics of a simple formal language: the language of
strings of balanced parentheses. Before we do that, we’ll
better explain wht it all menas. So let’s get started.


\subsection{Formal languages}
\label{\detokenize{A_01_Propositional_Logic:id1}}
\sphinxAtStartPar
The syntax of a \sphinxstyleemphasis{formal language} defines a (possibly
infinite) set of strings. Strings are sequences of symbols
from some \sphinxstyleemphasis{alphabet} of symbols. The formal language of basic
algebra, for example, includes strings such as \sphinxstyleemphasis{x}, \sphinxstyleemphasis{y}, and
\sphinxstyleemphasis{x + y}, but not \sphinxstyleemphasis{x y}. Propositional logic includes \sphinxstyleemphasis{X}, \sphinxstyleemphasis{Y},
and \sphinxstyleemphasis{X ∧ Y} but not \sphinxstyleemphasis{X Y}.

\sphinxAtStartPar
As another example, which shortly we will specify formally,
consider the language of all strings of balanced parentheses.
The language includes the empty string, \sphinxstyleemphasis{(), (()), ((()))},
etc.  It does not include any unbalanced strings, such as
\sphinxstyleemphasis{(}, \sphinxstyleemphasis{)}, \sphinxstyleemphasis{((}, or \sphinxstyleemphasis{(()}.

\sphinxAtStartPar
Each string in our language will be of some finite nesting
depth (and thus length) but the number of strings in the
language is infinite. There is one such string for each
possible nesting depth of such a string. That is, for any
natural number, \sphinxstyleemphasis{n}, there is a such a string with nesting
depth \sphinxstyleemphasis{n}.

\sphinxAtStartPar
We clearly can’t specify the set of strings by exhaustively
enumerating them expliciitly. There are too many for that.
Rather, we need a concise, precise, finite, and manageable
way to specify the set of all such strings. We will do that
by defining a small set of \sphinxstyleemphasis{basic rules for building} strings
of this kind (we’ll call them \sphinxstyleemphasis{constructors}), sufficient for
constructing all and only the strings in the language.

\sphinxAtStartPar
We can specify the balanced parentheses language with just two
rules. First, the empty string, ∅, is in our language. Second,
if \sphinxstyleemphasis{b} is \sphinxstyleemphasis{any} string in the language, then so is \sphinxstyleemphasis{(b)}. That
is all we need to construct a string of any nesting depth.

\sphinxAtStartPar
The empty string (nesting depth 0) is just empty, while we can
construct a string of any positive depth by applying the first
rule once, giving us the \sphinxstyleemphasis{base string}, ∅, any by applying the
second rule iteratively, first to ∅, as many times as needed to
construct a string of balanced parentheses as big as desired.

\sphinxAtStartPar
A key characteristic of this definition is that it’s properly
\sphinxstyleemphasis{inductive}. That is, it provides ways to build larger values
of a given type (balanced parenthesis strings) from smaller
values \sphinxstyleemphasis{of the same type}. The complete set of strings that
these rules \sphinxstyleemphasis{generate} (by any finite number of applications
thereof) is exactly the set of strings, the \sphinxstyleemphasis{formal language}
that we set out to specify.


\subsection{Paper \& Pencil Syntax}
\label{\detokenize{A_01_Propositional_Logic:paper-pencil-syntax}}
\sphinxAtStartPar
What we’ve basically done in this case is to specify the set of
strings in our language with a \sphinxstyleemphasis{grammar} or \sphinxstyleemphasis{syntax definition}.
Such grammars are often expressed, especially in the programming
worls, using so\sphinxhyphen{}called \sphinxstyleemphasis{Backus\sphinxhyphen{}Naur Form (BNF)}.

\sphinxAtStartPar
Backus first used BNF notation to define the syntax of the Algol
60 programming language. BNF is basically a notation for specifying
what the linguist, Noam Chomsky, called \sphinxstyleemphasis{context\sphinxhyphen{}free grammars}.

\sphinxAtStartPar
Here’s a grammer in BNF for our language of balanced parentheses.
We can say that the BNF grammar defines the syntax, or permitted
forms, of strings in our language. Be sure you see how this grammar
allow larger expressions to be build from smaller ones of the same
kind (here \sphinxstyleemphasis{expression}).
\begin{quote}

\sphinxAtStartPar
expression ::=
| ∅
| (expression)
\end{quote}

\sphinxAtStartPar
This definition says that an expression (string) in our
language is either the empty string or it’s an expression
within a pair of parentheses. That’s it. That’s all it takes.


\subsection{Formal Syntax}
\label{\detokenize{A_01_Propositional_Logic:formal-syntax}}
\sphinxAtStartPar
Now we give an equivalent but \sphinxstyleemphasis{completely formal} definition
of this language in Lean. The key idea is that we will define
a new \sphinxstyleemphasis{data type} the values of which are all and only terms
representing strings in our language.

\sphinxAtStartPar
We’ll start by defining separate data types (each with just
one value) to represent left and right parentheses, respectively.
The names of the types are \sphinxstyleemphasis{lparen} and \sphinxstyleemphasis{rparen.} Each has a
single value that we will call \sphinxstyleemphasis{mk}. We can use qualified names
to distinguish these values: \sphinxstyleemphasis{lparen.mk} and \sphinxstyleemphasis{rparen.mk}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{lparen}
\PYG{n+nb+bp}{|} \PYG{n}{mk}

\PYG{k+kd}{inductive} \PYG{n}{rparen}
\PYG{n+nb+bp}{|} \PYG{n}{mk}


\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{H}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{.}
\PYG{c+cm}{I}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{L}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{a}
\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}
\PYG{c+cm}{i}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{a}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{.}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{I}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}
\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{L}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{a}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{b}\PYG{c+cm}{i}\PYG{c+cm}{t}
\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{a}
\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{h}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{)}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}

\PYG{k+kd}{def} \PYG{n}{a\PYGZus{}left\PYGZus{}paren} \PYG{o}{:} \PYG{n}{lparen} \PYG{o}{:=} \PYG{n}{lparen.mk}
\PYG{k+kd}{example}          \PYG{o}{:} \PYG{n}{rparen} \PYG{o}{:=} \PYG{n}{rparen.mk}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we’re set to specify the set of all and only balanced
parenthesis strings. We give an inductive definition with
the two rules (\sphinxstyleemphasis{constructors}). First, the empty string
(which for now we call mk\_empty to stand for ∅), is in the
set of balanced strings. Second, if \sphinxstyleemphasis{b} is any balanced
string, then the term \sphinxstyleemphasis{mk\_nonempty l b r} is also (that is
also represents) a balanced string, namely \sphinxstyleemphasis{(b)}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{bal}
\PYG{n+nb+bp}{|} \PYG{n}{mk\PYGZus{}empty}
\PYG{n+nb+bp}{|} \PYG{n}{mk\PYGZus{}nonempty} \PYG{o}{(}\PYG{n}{l}\PYG{o}{:} \PYG{n}{lparen}\PYG{o}{)} \PYG{o}{(}\PYG{n}{b} \PYG{o}{:} \PYG{n}{bal}\PYG{o}{)} \PYG{o}{(}\PYG{n}{r} \PYG{o}{:} \PYG{n}{rparen}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The only thing that a constructor does in such a definition
is to package up its arguments (if any) into a new term with
the constructor name as a first element (a label, if you will).
The type system of Lean will now recognize any term that can
be built using the available constructors as being of type bal.

\sphinxAtStartPar
Here we illustrate the use of these constructors to build the
first few balanced strings in our language. We Open the \sphinxstyleemphasis{bal}
namespace so that we don’t have to write \sphinxstyleemphasis{bal.} before each
constructor name. These constructor names do not conflict with
any existing definitions in the current (global) namespace.
We don’t open the lparen and rparen namespaces because then
we’d have two (ambiguous) definitions of the identifier, mk,
and we’d have to write \sphinxstyleemphasis{lparen.mk} or \sphinxstyleemphasis{rparen.mk} in any case
to disambiguate them.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{open} \PYG{n}{bal}

\PYG{k+kd}{def} \PYG{n}{b0} \PYG{o}{:} \PYG{n}{bal} \PYG{o}{:=}       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} ∅}
  \PYG{n}{mk\PYGZus{}empty}

\PYG{k+kd}{def} \PYG{n}{b1} \PYG{o}{:} \PYG{n}{bal} \PYG{o}{:=}       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} (∅)}
\PYG{n}{mk\PYGZus{}nonempty}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} constructor}
  \PYG{n}{lparen.mk}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} argument left parenthesis}
  \PYG{n}{b0}                  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} note: we could write mk\PYGZus{}empty}
  \PYG{n}{rparen.mk}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} argument right parenthesis}

\PYG{k+kd}{def} \PYG{n}{b2} \PYG{o}{:=}             \PYG{c+c1}{\PYGZhy{}\PYGZhy{} ((∅))}
\PYG{n}{mk\PYGZus{}nonempty}
  \PYG{n}{lparen.mk}
  \PYG{n}{b1}
  \PYG{n}{rparen.mk}

\PYG{k+kd}{def} \PYG{n}{b3} \PYG{o}{:=}
\PYG{n}{mk\PYGZus{}nonempty}
  \PYG{n}{lparen.mk}
  \PYG{o}{(}
    \PYG{n}{mk\PYGZus{}nonempty}
      \PYG{n}{lparen.mk}
      \PYG{o}{(}
        \PYG{n}{mk\PYGZus{}nonempty}
          \PYG{n}{lparen.mk}
          \PYG{n}{mk\PYGZus{}empty}
          \PYG{n}{rparen.mk}
      \PYG{o}{)}
      \PYG{n}{rparen.mk}
  \PYG{o}{)}
  \PYG{n}{rparen.mk}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can confirm that the type of b1 is bal using the
\sphinxstyleemphasis{check} command in Lean. The output of this  command is
visible if you hover your cursor over the blue underline
(in VSCode), and in your Lean infoview. You can open and
close the infoview window in VSCode by CMD/CTRL\sphinxhyphen{}SHIFT\sphinxhyphen{}ENTER.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{b1}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can now use the \sphinxstyleemphasis{reduce} command in Lean to see that \sphinxstyleemphasis{b1} is
bound to the term, \sphinxstyleemphasis{mk\_nonempty lparen.mk mk\_empty rparen.mk}. If
you do the same for \sphinxstyleemphasis{b2} you will see its unfolded value, and the
same goes for b3. Be sure to relate the results you get here back
to the definitions of \sphinxstyleemphasis{b1, b2,} and \sphinxstyleemphasis{b3} above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{b1}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{b2}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{b3}
\end{sphinxVerbatim}

\sphinxAtStartPar
From here we can build larger and larger strings in \sphinxstyleemphasis{bal}.


\subsection{Inductive Datatype Definitions}
\label{\detokenize{A_01_Propositional_Logic:inductive-datatype-definitions}}
\sphinxAtStartPar
There are three crucial properties of constructors of inductive
data types in Lean that you should now understand. First, they
are \sphinxstyleemphasis{disjoint}. Different constructors \sphinxstyleemphasis{never} produce the same
value. Second, they are \sphinxstyleemphasis{injective}. A constructor applied to
different argument values will always produce different terms.
Finally, they are complete. The langauge they define contains
\sphinxstyleemphasis{all} of the strings constructible by any finite number of
applications of the defined constructors \sphinxstyleemphasis{and no other terms}.
For example, our \sphinxstyleemphasis{bal} language doesn’t contain any \sphinxstyleemphasis{error} or
any other terms not constructible by the given constructors.


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:semantics}}
\sphinxAtStartPar
The semantics of a formal language defines an association
between some or all of the terms of a language and what each
such term means, in some \sphinxstyleemphasis{semantic domain}. For example, we
can associate each string in \sphinxstyleemphasis{bal} with the natural number
that describes its nesting depth.

\sphinxAtStartPar
In this case, there is total function from terms of type
\sphinxstyleemphasis{bal} to \sphinxstyleemphasis{ℕ}, so we can specify the semantics as a function
in Lean. (All functions in Lean represent total functions in
mathematics.)

\sphinxAtStartPar
Here is such a function defined using one of several notations
available in Lean. We define the function, \sphinxstyleemphasis{sem} as taking a
value of type \sphinxstyleemphasis{bal} as an argument and returning a value of
type nat (ℕ, natural number, i.e., non\sphinxhyphen{}negative integer) as
a result.

\sphinxAtStartPar
The function is defined by case analysis on the argument. If
it is the empty string, mk\_empty, the function returns 0.
Otherwise (the only remaining possibility) is that the value
to which \sphinxstyleemphasis{sem} is applied is of the form (mk\_nonempty l b r)
where \sphinxstyleemphasis{l} and \sphinxstyleemphasis{r} are values representing left and right
parenthesis, and where \sphinxstyleemphasis{b} is some smaller string/value of
type \sphinxstyleemphasis{bal}. In this case, the nesting depth of the argument
is one more than the nesting depth of \sphinxstyleemphasis{b}, which we compute
by applying \sphinxstyleemphasis{bal} recursively to \sphinxstyleemphasis{b}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{sem} \PYG{o}{:} \PYG{n}{bal} \PYG{n+nb+bp}{→} \PYG{n}{ℕ}
\PYG{n+nb+bp}{|} \PYG{n}{mk\PYGZus{}empty} \PYG{o}{:=} \PYG{l+m+mi}{0}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{mk\PYGZus{}nonempty} \PYG{n}{l} \PYG{n}{b} \PYG{n}{r}\PYG{o}{)} \PYG{o}{:=} \PYG{l+m+mi}{1} \PYG{n+nb+bp}{+} \PYG{n}{sem} \PYG{n}{b}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} We can now run some tests to see that it works}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{sem} \PYG{n}{b0}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{sem} \PYG{n}{b1}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{sem} \PYG{n}{b2}
\end{sphinxVerbatim}

\sphinxAtStartPar
So there you have it. We’ve defined both a formal language
and a semantics of this language using the logic of the Lean
proof assistant. We defined an inductive data type the \sphinxstyleemphasis{terms}
(values) of which represent all and only the strings in \sphinxstyleemphasis{bal}.
We defined a total function that maps any term of this type to
its corresponding length expressed as a natural number, which
we take to be the \sphinxstyleemphasis{semantic meaning} of that string.

\sphinxAtStartPar
We now have all the machinery we need to formally define the
syntax and semantics of more interesting and useful languages.
We will now turn to the language of propositional logic as our
next major example.


\section{Simplified Propositional Logic}
\label{\detokenize{A_01_Propositional_Logic:simplified-propositional-logic}}
\sphinxAtStartPar
Our next step toward formalizing abstract mathematics for software
engineering, we will specify the syntax and semantics of a simple
but important mathatical language, namely \sphinxstyleemphasis{propositional logic}.

\sphinxAtStartPar
Propositional logic is isomorphic to (essentially the same thing
as) Boolean algebra. You already know about Boolean algebra from
writing conditions in if and loop commands in everyday programming
languages such as Java.

\sphinxAtStartPar
Our first task will be to see how to formalize the syntax and
semantics of this language in Lean.


\subsection{Syntax}
\label{\detokenize{A_01_Propositional_Logic:syntax}}
\sphinxAtStartPar
The set of expressions (strings) comprising the formal
language of propositional logic is defined inductively.
That is, some smallest expressions are first defined,
with larger expressions then defined as being constructed,
at least in part, from smaller ones \sphinxstyleemphasis{of the same type}.

\sphinxAtStartPar
The syntax of propositional logic comprises
\begin{itemize}
\item {} 
\sphinxAtStartPar
variables, e.g., x, y, y, theSkyIsBlue, etc

\item {} 
\sphinxAtStartPar
a language of propositional expressions (propositions)
* constant expressions, \sphinxstyleemphasis{true} and \sphinxstyleemphasis{false}
* variable expressions, such as X, Y, Z, TheSkyIsBlue, each such expression having an associated variable
* operator expressions, such as ¬X, X ∧ Y, and X ∨ Y

\end{itemize}

\sphinxAtStartPar
You can think of these operators as taking expressions
as their arguments and returning longer expressions as
their results.

\sphinxAtStartPar
To begin, we define a datatype the values of which will
represent our the variables. We’ll name the type \sphinxstyleemphasis{prop\_var,}
for propositional variable. For now we’ll assume we’re
restricted to using at most three variables.  We’ll call
them \sphinxstyleemphasis{x, y,} and \sphinxstyleemphasis{z} and will just list them as being the
distinct constant values of the \sphinxstyleemphasis{prop\_var} type.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}var} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{x}
\PYG{n+nb+bp}{|} \PYG{n}{y}
\PYG{n+nb+bp}{|} \PYG{n}{z}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}var}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we’ll define the set of expressions in our language,
which we’ll call \sphinxstyleemphasis{prop\_expr}, the language of expressions
in propositional logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}expr}
\PYG{n+nb+bp}{|} \PYG{n}{var\PYGZus{}expr} \PYG{o}{(}\PYG{n}{v} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{and\PYGZus{}expr} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{or\PYGZus{}expr} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}expr}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can now form both variable and operator
expressions! Let’s start with some variable
expressions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{X} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{var\PYGZus{}expr} \PYG{n}{x}
\PYG{k+kd}{def} \PYG{n}{Y} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{var\PYGZus{}expr} \PYG{n}{y}
\PYG{k+kd}{def} \PYG{n}{Z} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{var\PYGZus{}expr} \PYG{n}{z}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can also define operator expressions, which
build larger expressions out of smaller ones.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{XandY} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{and\PYGZus{}expr} \PYG{n}{X} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{XandY\PYGZus{}and\PYGZus{}Z} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{and\PYGZus{}expr} \PYG{n}{XandY} \PYG{n}{Z}
\end{sphinxVerbatim}


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:id2}}
\sphinxAtStartPar
The semantics of propositional logic assigns a Boolean
truth value to each expression in the language, but to
do this, an additional piece of data is required: one
that defines the Boolean meaning (truth value) of each
\sphinxstyleemphasis{variable} referenced by any variable expression.

\sphinxAtStartPar
What for example is the meaning of the variable expression,
\sphinxstyleemphasis{X}? It’s impossible to say unless you know the meaning of
the variable, \sphinxstyleemphasis{x}. If the meaning of \sphinxstyleemphasis{x} is true, then we
define the meaning of \sphinxstyleemphasis{X} to be true, and likewise for the
value, false.

\sphinxAtStartPar
We will use the word \sphinxstyleemphasis{interpretation} to refer to any
assignment of Boolean truth values to all variables that
can be referenced by any given variable expression. For
example, we might define \sphinxstyleemphasis{x}, \sphinxstyleemphasis{y}, and \sphinxstyleemphasis{z} all to have
true as their meanings.  We can formalize this mapping
from variables to truth values as a total function from
terms of type \sphinxstyleemphasis{prop\_var} to terms of type \sphinxstyleemphasis{bool} in Lean.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{all\PYGZus{}true} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{tt}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} for any argument return true (tt in Lean)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Similarly here’s an interpretation under which all variables
are assigned the value, false.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{all\PYGZus{}false} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{ff}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} for any argument return true (tt in Lean)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now here’s an interpretation under which x is assigned true,
and the remaining variables (y and z) are assigned false.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{mixed} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{prop\PYGZus{}var.x} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{ff}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{mixed} \PYG{n}{z}

\PYG{k+kd}{def} \PYG{n}{another\PYGZus{}interpretation} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{x} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{y} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{z} \PYG{o}{:=} \PYG{n}{tt}
\end{sphinxVerbatim}

\sphinxAtStartPar
Given one of these interpretations as additional data, we
can now assign truth value semantic meanings to expressions
such as XandY (and\_expr X Y). We do this recursively. First
we evaluate X to get its truth value (by applying a given
interpretation function to the variable, x, that expression
X “contains”.

\sphinxAtStartPar
Recall that X is defined to be the term, var\_expr x. We just
need to \sphinxstyleemphasis{destructure} this term to get the \sphinxstyleemphasis{x} part of it.
Remember that constructors simply package up their arguments
into terms in which those arguments appear in order. Once we
get at the variable, \sphinxstyleemphasis{x}, we just apply an interpretation
function to it to get its corresponding Boolean value, and
we take that as the meaning of the variable expression, \sphinxstyleemphasis{X}.

\sphinxAtStartPar
Ok, so what about the meaning of \sphinxstyleemphasis{(and\_expr X Y)}? First we
need to know the meanings of \sphinxstyleemphasis{X} and \sphinxstyleemphasis{Y}. Suppose they are
true and false, respectively. Then we define the meaning of
\sphinxstyleemphasis{(and\_expr X Y)} as the Boolean \sphinxstyleemphasis{conjunction} of these truth
values. In this case, that’d be \sphinxstyleemphasis{tt \&\& ff,} which is \sphinxstyleemphasis{ff}.

\sphinxAtStartPar
Here then is a semantic evaluation function that implements
these two notions: one in the case where the expression to
be given a meaning is a variable expression, and one where
it’s an \sphinxstyleemphasis{and} expression.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{prop\PYGZus{}eval} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{var\PYGZus{}expr} \PYG{n}{v}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{i} \PYG{n}{v}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{and\PYGZus{}expr} \PYG{n}{e1} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{band} \PYG{o}{(}\PYG{n}{prop\PYGZus{}eval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{prop\PYGZus{}eval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{or\PYGZus{}expr} \PYG{n}{e1} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{bor} \PYG{o}{(}\PYG{n}{prop\PYGZus{}eval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{prop\PYGZus{}eval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we can find the meaning of \sphinxstyleemphasis{any} expression in our
initial subset of the language of propositional logic.
To be more precise, we’d say that we’ve specified an
\sphinxstyleemphasis{abstract syntax} for our language. In our next unit,
we’ll see how to use Lean’s syntax extension capabilities
to define a corresponding \sphinxstyleemphasis{concrete} syntax, one that’ll
let us write expressions in our language as if we were
using paper and pencil methods and standard syntax for
propositional logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{all\PYGZus{}true}


\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{X} \PYG{n}{all\PYGZus{}true}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{Y} \PYG{n}{all\PYGZus{}true}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{Z} \PYG{n}{all\PYGZus{}true}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{X} \PYG{n}{all\PYGZus{}false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{Y} \PYG{n}{all\PYGZus{}false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{Z} \PYG{n}{all\PYGZus{}false}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{XandY} \PYG{n}{all\PYGZus{}true}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{XandY} \PYG{n}{all\PYGZus{}false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{XandY} \PYG{n}{mixed}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{o}{(}\PYG{n}{and\PYGZus{}expr} \PYG{o}{(}\PYG{n}{and\PYGZus{}expr} \PYG{n}{X} \PYG{n}{Y}\PYG{o}{)} \PYG{o}{(}\PYG{n}{or\PYGZus{}expr} \PYG{n}{X} \PYG{n}{Z}\PYG{o}{)}\PYG{o}{)} \PYG{n}{mixed}
\end{sphinxVerbatim}

\sphinxAtStartPar
So we now have is a specification of the syntax and
semantics of a subset of propositional logic. As an
in\sphinxhyphen{}class exercise, let’s add some new logical operators:
for not, or, implies, bi\sphinxhyphen{}implication, and exclusive or.


\section{Propositional Logic}
\label{\detokenize{A_01_Propositional_Logic:propositional-logic}}
\sphinxAtStartPar
In this chapter, we’ll present a first
version of a syntax and semantic specification
for a full language of propositional logic. As
in the last chapter, we start by defining the
syntax, then we present the semantics.


\subsection{Syntax}
\label{\detokenize{A_01_Propositional_Logic:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{P}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{o}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{o}\PYG{c+cm}{g}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{u}\PYG{c+cm}{p}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{a}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{.}
\PYG{c+cm}{W}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{a}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{m}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{.}\PYG{c+cm}{m}\PYG{c+cm}{k}
\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{n}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{s}
\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{m}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{*}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{*}
\PYG{c+cm}{b}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}var} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{mk} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Abstract syntax}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{pTrue} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}
\PYG{n+nb+bp}{|} \PYG{n}{pFalse} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}
\PYG{n+nb+bp}{|} \PYG{n}{pVar} \PYG{o}{(}\PYG{n}{v}\PYG{o}{:} \PYG{n}{prop\PYGZus{}var}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pNot} \PYG{o}{(}\PYG{n}{e} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pAnd} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pOr} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pImp} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pIff} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pXor} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}expr}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can now \sphinxstyleemphasis{overload} some predefined operators in Lean
having appropriate associativity and precedence properties
to obtain a nice \sphinxstyleemphasis{concrete syntax} for our language. See also
(\sphinxurl{https://github.com/leanprover/lean/blob/master/library/init/core.lean})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{var\PYGZus{}mk}\PYG{o}{)} \PYG{n+nb+bp}{`}\PYG{o}{[}\PYG{n+nb+bp}{`} \PYG{n}{v} \PYG{n+nb+bp}{`}\PYG{o}{]}\PYG{n+nb+bp}{`} \PYG{o}{:=}  \PYG{n}{pVar} \PYG{n}{v}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pAnd}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{∧} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pAnd} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pOr}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{∨} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pOr} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pNot}\PYG{o}{)} \PYG{n+nb+bp}{¬}\PYG{n}{e} \PYG{o}{:=} \PYG{n}{pNot} \PYG{n}{e}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pImp}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pImp} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pIff}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pIff} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pXor}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{⊕} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pXor} \PYG{n}{e1} \PYG{n}{e2}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, after giving nice names, X, Y, and Z, to
the first three variables, we givesome examples of
propositional logic expressions written using our
new \sphinxstyleemphasis{concrete} syntax.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{X} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Y} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Z} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{2}\PYG{o}{]}

\PYG{k+kd}{def} \PYG{n}{e1} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e3} \PYG{o}{:=} \PYG{n+nb+bp}{¬} \PYG{n}{Z}
\PYG{k+kd}{def} \PYG{n}{e4} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} avoid overloading →}
\PYG{k+kd}{def} \PYG{n}{e5} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e1}
\PYG{k+kd}{def} \PYG{n}{e6} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{⊕} \PYG{n+nb+bp}{¬}\PYG{n}{X}
\end{sphinxVerbatim}


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Helper functions}
\PYG{k+kd}{def} \PYG{n}{bimp} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}

\PYG{k+kd}{def} \PYG{n}{biff} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Operational semantics}
\PYG{k+kd}{def} \PYG{n}{pEval} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{pTrue} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{pFalse} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{o}{[}\PYG{n}{v}\PYG{o}{]}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{i} \PYG{n}{v}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n+nb+bp}{¬} \PYG{n}{e}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{bnot} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{∧} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{\PYGZam{}}\PYG{n+nb+bp}{\PYGZam{}} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{∨} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{|}\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{bimp} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{biff} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{⊕} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{xor} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
I’ll fill in explanatory text later, but for now wanted
to get you the \sphinxstyleemphasis{code}.


\section{A Better Specification}
\label{\detokenize{A_01_Propositional_Logic:a-better-specification}}
\sphinxAtStartPar
In this chapter we present an improved specification
of the syntax and semantics of propositional logic. As
usual, we first present the syntax specification then the
semantics.


\subsection{Syntax}
\label{\detokenize{A_01_Propositional_Logic:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variables, still indexed by natural numbers}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}var} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{mk} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} examples}
\PYG{k+kd}{def} \PYG{n}{v₀} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}
\PYG{k+kd}{def} \PYG{n}{v₁} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}
\PYG{k+kd}{def} \PYG{n}{v₂} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will now refactor our definition of
prop\_expr to factor out mostly repeated code
and to make explicit (1) a class of \sphinxstyleemphasis{literal}
expressions, and (2) binary operators as first
class citizens and a class of corresponding
binary operator expressions. Be sure to compare
and contrast our definitions here with the ones in
the last chapter.

\sphinxAtStartPar
We’ll start by defining a \sphinxstyleemphasis{binary operator} type
whose values are abstract syntax terms for binary
operators/connectives in propositional logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Syntactic terms for binary operators}
\PYG{k+kd}{inductive} \PYG{n}{binop}
\PYG{n+nb+bp}{|} \PYG{n}{opAnd}
\PYG{n+nb+bp}{|} \PYG{n}{opOr}
\PYG{n+nb+bp}{|} \PYG{n}{opImp}
\PYG{n+nb+bp}{|} \PYG{n}{opIff}
\PYG{n+nb+bp}{|} \PYG{n}{opXor}

\PYG{k+kn}{open} \PYG{n}{binop}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A much improved language syntax spec}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{pLit} \PYG{o}{(}\PYG{n}{b} \PYG{o}{:} \PYG{n}{bool}\PYG{o}{)}                         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} literal expressions}
\PYG{n+nb+bp}{|} \PYG{n}{pVar} \PYG{o}{(}\PYG{n}{v}\PYG{o}{:} \PYG{n}{prop\PYGZus{}var}\PYG{o}{)}                      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expressions}
\PYG{n+nb+bp}{|} \PYG{n}{pNot} \PYG{o}{(}\PYG{n}{e} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}                    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} unary operator expression}
\PYG{n+nb+bp}{|} \PYG{n}{pBinOp} \PYG{o}{(}\PYG{n}{op} \PYG{o}{:} \PYG{n}{binop}\PYG{o}{)} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} binary operator expressions}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}expr}


\PYG{c+c1}{\PYGZhy{}\PYGZhy{} An example of an \PYGZdq{}and\PYGZdq{} expression}
\PYG{k+kd}{def} \PYG{n}{an\PYGZus{}and\PYGZus{}expr} \PYG{o}{:=}
  \PYG{n}{pBinOp}
    \PYG{n}{opAnd}                   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} binary operator}
    \PYG{o}{(}\PYG{n}{pVar} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}\PYG{o}{)}\PYG{o}{)}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expression}
    \PYG{o}{(}\PYG{n}{pVar} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expression}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have to update the previous notations definitions,
which now need to \sphinxstyleemphasis{desugar} to use the new expression
constructors. We also define some shorthands for the
two literal expressions in our language.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{True} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{tt}
\PYG{k+kd}{def} \PYG{n}{False} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{ff}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pVar}\PYG{o}{)} \PYG{n+nb+bp}{`}\PYG{o}{[}\PYG{n+nb+bp}{`} \PYG{n}{v} \PYG{n+nb+bp}{`}\PYG{o}{]}\PYG{n+nb+bp}{`} \PYG{o}{:=}  \PYG{n}{pVar} \PYG{n}{v}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pAnd}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{∧} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pBinOp} \PYG{n}{opAnd} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pOr}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{∨} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pBinOp} \PYG{n}{opOr} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pNot}\PYG{o}{)} \PYG{n+nb+bp}{¬}\PYG{n}{e} \PYG{o}{:=} \PYG{n}{pNot} \PYG{n}{e}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pImp}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opImp} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pIff}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opIff} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pXor}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{⊕} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opXor} \PYG{n}{e1} \PYG{n}{e2}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Precedence highest to lowest NOT, NAND, NOR, AND, OR, \PYGZhy{}\PYGZgt{}, ==}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} `↓`:37 x:37}
\PYG{k+kd}{reserve} \PYG{k+kd}{notation} \PYG{n+nb+bp}{`}\PYG{n+nb+bp}{↓}\PYG{n+nb+bp}{`}\PYG{o}{:}\PYG{l+m+mi}{37} \PYG{n}{x}\PYG{o}{:}\PYG{l+m+mi}{37}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pNor}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`}\PYG{n+nb+bp}{↓}\PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opAnd} \PYG{n}{e1} \PYG{n}{e2}

\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{¬}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{∧}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{↑}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{↓}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here are examples of expressions using our concrete syntax

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expressions from variables}
\PYG{k+kd}{def} \PYG{n}{X} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₀}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Y} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₁}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Z} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₂}\PYG{o}{]}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} operator expressions}
\PYG{k+kd}{def} \PYG{n}{e1} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e3} \PYG{o}{:=} \PYG{n+nb+bp}{¬}\PYG{n}{Z}
\PYG{k+kd}{def} \PYG{n}{e4} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2}
\PYG{k+kd}{def} \PYG{n}{e5} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e1}
\PYG{k+kd}{def} \PYG{n}{e6} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{⊕} \PYG{n+nb+bp}{¬}\PYG{n}{X}
\end{sphinxVerbatim}


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:id6}}
\sphinxAtStartPar
A benefit of having made binary operators
explicit as a set of syntactic terms is that
we can simultaneously simplify and generalize
our semantics.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Helper functions}
\PYG{k+kd}{def} \PYG{n}{bimp} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}

\PYG{k+kd}{def} \PYG{n}{biff} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}
\end{sphinxVerbatim}

\sphinxAtStartPar
We now define an \sphinxstyleemphasis{interpretation} for operator symbols!
Each binop (a syntactic object) has as its meaning some
corresponding binary Boolean operator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{op\PYGZus{}sem} \PYG{o}{:} \PYG{n}{binop} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{opAnd} \PYG{o}{:=} \PYG{n}{band}
\PYG{n+nb+bp}{|} \PYG{n}{opOr}  \PYG{o}{:=} \PYG{n}{bor}
\PYG{n+nb+bp}{|} \PYG{n}{opImp} \PYG{o}{:=} \PYG{n}{bimp}
\PYG{n+nb+bp}{|} \PYG{n}{opIff} \PYG{o}{:=} \PYG{n}{biff}
\PYG{n+nb+bp}{|} \PYG{n}{opXor} \PYG{o}{:=} \PYG{n}{bxor}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A quick demo}
\PYG{k}{\PYGZsh{}reduce} \PYG{o}{(}\PYG{o}{(}\PYG{n}{op\PYGZus{}sem} \PYG{n}{opAnd}\PYG{o}{)} \PYG{n}{tt} \PYG{n}{ff}\PYG{o}{)}
\PYG{k}{\PYGZsh{}reduce} \PYG{o}{(}\PYG{n}{op\PYGZus{}sem} \PYG{n}{opOr} \PYG{n}{tt} \PYG{n}{ff}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} recall left associativity}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now here’s a much improved semantic specification.
In place of rules for pTrue and pFalse we just have
one rule for pLit (literal expressions). Second, in
place of one rule for each binary operator we have
one rule for \sphinxstyleemphasis{any} binary operator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{pEval} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pLit} \PYG{n}{b}\PYG{o}{)}          \PYG{n}{i} \PYG{o}{:=} \PYG{n}{b}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{o}{[}\PYG{n}{v}\PYG{o}{]}\PYG{o}{)}             \PYG{n}{i} \PYG{o}{:=} \PYG{n}{i} \PYG{n}{v}                  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} our [] notation on the left}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n+nb+bp}{¬}\PYG{n}{e}\PYG{o}{)}              \PYG{n}{i} \PYG{o}{:=} \PYG{n}{bnot} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} our ¬ notation; Lean\PYGZsq{}s bnot}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pBinOp} \PYG{n}{op} \PYG{n}{e1} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{\PYGZam{}}\PYG{n+nb+bp}{\PYGZam{}} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} BUG!}
\end{sphinxVerbatim}


\subsection{Exploration}
\label{\detokenize{A_01_Propositional_Logic:exploration}}
\sphinxAtStartPar
You’ve heard about Lean and seen in it action, but there’s no substitute for
getting into it yourself. The goal of this exploration is for you to “connect
all the dots” in what we’ve developed so far, and for you to start to develop
“muscle memory” for some basic Lean programming.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Identify and fix the bug in the last rule of pEval

\item {} 
\sphinxAtStartPar
Replace pNot with pUnOp (“unary operator”), as with pBinOp

\item {} 
\sphinxAtStartPar
Add end\sphinxhyphen{}to\sphinxhyphen{}end support for logical \sphinxstyleemphasis{nand} (↑) and \sphinxstyleemphasis{nor} (↓) expression\sphinxhyphen{}building operators

\item {} 
\sphinxAtStartPar
Define some examples of propositional logic expressions using concrete syntax

\item {} 
\sphinxAtStartPar
Define several interpretations and evaluate each of your expressions under each one

\end{itemize}

\sphinxAtStartPar
To avoid future git conflicts, make a copy of src/04\_prop\_logic\_syn\_sem.lean, and
make changes to that file rather than to the original. Bring your completed work
to our next class. Be prepared to share and/or turn in your work at the beginning
of next class.


\section{Formal Validation}
\label{\detokenize{A_01_Propositional_Logic:formal-validation}}
\sphinxAtStartPar
So far we’ve defined (1) an abstract syntax for propositional
logic, (2) a “big step” operational semantics for our syntax,
and (3) a concrete syntax for it, in the form of prefix (¬) and
infix (∧, ∨, =>, etc) operators.

\sphinxAtStartPar
But how do we know that our \sphinxstyleemphasis{specification} is correct? Checking
a specification for correctness is called \sphinxstyleemphasis{validating} it, or just
validation. \sphinxstyleemphasis{Formal} validation is the use of mathematical logic
to validate given specifications.

\sphinxAtStartPar
In particular, one can formally validate a specification by
proving that it has certain required properties. To illustrate
the point, n this chapter we add a fourth section,(4): a formal
proof of the proposition that in our syntax and semantics, ∧ is
commutative; that for \sphinxstyleemphasis{any} expressions in propositional logic,
e1 and e2, and for \sphinxstyleemphasis{any} interpretation, the values of e1 ∧ e2
under i, and of e2 ∧ e1 under i, are equal.

\sphinxAtStartPar
Another way to look at this chapter is that it extends the set of
elements of a good formalization of a mathematical concept from
three above to four. Now the modular unit of definition specifies
(1) the data (sometimes language syntax, sometimes not), (2) the
operations on that data, (3) the available concrete notations,
and now also (4) proofs that essential properties hold.
Abstract Syntax
—————

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{namespace} \PYG{n}{cs6501}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variables, indexed by natural numbers}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}var} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{mk} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Abstract syntactic terms for unary operators}
\PYG{k+kd}{inductive} \PYG{n}{unop}
\PYG{n+nb+bp}{|} \PYG{n}{opNot}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Abstract syntactic terms for binary operators}
\PYG{k+kd}{inductive} \PYG{n}{binop}
\PYG{n+nb+bp}{|} \PYG{n}{opAnd}
\PYG{n+nb+bp}{|} \PYG{n}{opOr}
\PYG{n+nb+bp}{|} \PYG{n}{opImp}
\PYG{n+nb+bp}{|} \PYG{n}{opIff}
\PYG{n+nb+bp}{|} \PYG{n}{opXor}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} make constructor names globally visible}
\PYG{k+kn}{open} \PYG{n}{unop}
\PYG{k+kn}{open} \PYG{n}{binop}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} syntax}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{pLit} \PYG{o}{(}\PYG{n}{b} \PYG{o}{:} \PYG{n}{bool}\PYG{o}{)}                         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} literal expressions}
\PYG{n+nb+bp}{|} \PYG{n}{pVar} \PYG{o}{(}\PYG{n}{v}\PYG{o}{:} \PYG{n}{prop\PYGZus{}var}\PYG{o}{)}                      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expressions}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} | pNot (e : prop\PYGZus{}expr)                    \PYGZhy{}\PYGZhy{} unary operator expression}
\PYG{n+nb+bp}{|} \PYG{n}{pUnOp} \PYG{o}{(}\PYG{n}{op} \PYG{o}{:}\PYG{n}{unop}\PYG{o}{)} \PYG{o}{(}\PYG{n}{e} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}                    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} unary operator expression}
\PYG{n+nb+bp}{|} \PYG{n}{pBinOp} \PYG{o}{(}\PYG{n}{op} \PYG{o}{:} \PYG{n}{binop}\PYG{o}{)} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} binary operator expressions}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}expr}
\end{sphinxVerbatim}


\subsection{Concrete Syntax / Notation}
\label{\detokenize{A_01_Propositional_Logic:concrete-syntax-notation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} notations (concrete syntax)}
\PYG{k+kd}{notation} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⊤} \PYG{n+nb+bp}{`} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{tt}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Notation for True}
\PYG{k+kd}{notation} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⊥} \PYG{n+nb+bp}{`} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{ff}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Notation for False}
\PYG{k+kd}{def} \PYG{n}{True} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{tt}         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} deprecated now}
\PYG{k+kd}{def} \PYG{n}{False} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{ff}        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} deprecated now}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pVar}\PYG{o}{)} \PYG{n+nb+bp}{`} \PYG{o}{[} \PYG{n+nb+bp}{`} \PYG{n}{v}  \PYG{n+nb+bp}{`} \PYG{o}{]} \PYG{n+nb+bp}{`} \PYG{o}{:=}  \PYG{n}{pVar} \PYG{n}{v}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pNot}\PYG{o}{)} \PYG{n+nb+bp}{¬}\PYG{n}{e} \PYG{o}{:=} \PYG{n}{pUnOp} \PYG{n}{opNot} \PYG{n}{e}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pAnd}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pBinOp} \PYG{n}{opAnd} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pOr}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pBinOp} \PYG{n}{opOr} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{precedence} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n+nb+bp}{`}\PYG{o}{:} \PYG{l+m+mi}{23}                                        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} add operator precedence}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pImp}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n+nb+bp}{`}  \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opImp} \PYG{n}{e1} \PYG{n}{e2}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} bug fixed; add back quotes}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pIff}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{↔} \PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opIff} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pXor}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⊕} \PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opXor} \PYG{n}{e1} \PYG{n}{e2}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Let\PYGZsq{}s not bother with notations for nand and nor at this point}
\end{sphinxVerbatim}


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:id7}}
\sphinxAtStartPar
The \sphinxstyleemphasis{semantic domain} for our language is not only the
Boolean values, but also the Boolean operations. We map
variables to Boolean values (via an interpretation) and
we define a fixed mapping of logical connectives (¬, ∧,
∨, etc.) to Boolean operations (bnot, band, bor, etc.)
With these elementary semantic mappings in place we can
finally map \sphinxstyleemphasis{any} propositional logical expression to
its (Boolean) meaning in a \sphinxstyleemphasis{compositional} manner, where
the meaning of any compound expression is composed from
the meanings of its parts, which we compute recursively,
down to individual variables and connectives.

\sphinxAtStartPar
The Lean standard libraries define some but not all
binary Boolean operations. We will thus start off in
this section by augmenting Lean’s definitions of the
Boolean operations with two more: for implication (we
follow Lean naming conventions and call this bimp) and
bi\sphinxhyphen{}implication (biff).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Boolean implication operation (buggy!)}
\PYG{k+kd}{def} \PYG{n}{bimp} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A fault to inject first time through}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Now corrected in following to lines}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} | tt ff := tt}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} | ff tt := ff}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Boolean biimplication operation}
\PYG{k+kd}{def} \PYG{n}{biff} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we define a fixed interpretation for our
syntactic logical connectives, first unary and
then binary. We give these mappings in the form
of functions from unary and binary operators
(which act to compose logical expressions into
new expressions), to Boolean operations (which
compose Boolean values into Boolean results).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} interpretations of unary operators}
\PYG{k+kd}{def} \PYG{n}{un\PYGZus{}op\PYGZus{}sem} \PYG{o}{:} \PYG{n}{unop} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{opNot} \PYG{o}{:=} \PYG{n}{bnot}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} interpretations of binary operators}
\PYG{k+kd}{def} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem} \PYG{o}{:} \PYG{n}{binop} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{opAnd} \PYG{o}{:=} \PYG{n}{band}
\PYG{n+nb+bp}{|} \PYG{n}{opOr}  \PYG{o}{:=} \PYG{n}{bor}
\PYG{n+nb+bp}{|} \PYG{n}{opImp} \PYG{o}{:=} \PYG{n}{bimp}
\PYG{n+nb+bp}{|} \PYG{n}{opIff} \PYG{o}{:=} \PYG{n}{biff}
\PYG{n+nb+bp}{|} \PYG{n}{opXor} \PYG{o}{:=} \PYG{n}{bxor}
\end{sphinxVerbatim}

\sphinxAtStartPar
And now here’s our overal expression semantic evaluation
function. It works as described, computing the value of
sub\sphinxhyphen{}expressions and composing the Boolean results into
final Boolean meanings for any given expression under any
give interpretation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} semantic evaluation (meaning of expressions)}
\PYG{k+kd}{def} \PYG{n}{pEval} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pLit} \PYG{n}{b}\PYG{o}{)}          \PYG{n}{i} \PYG{o}{:=} \PYG{n}{b}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{o}{[}\PYG{n}{v}\PYG{o}{]}\PYG{o}{)}             \PYG{n}{i} \PYG{o}{:=} \PYG{n}{i} \PYG{n}{v}                  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} our [] notation on the left}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pUnOp} \PYG{n}{op} \PYG{n}{e}\PYG{o}{)}      \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{un\PYGZus{}op\PYGZus{}sem} \PYG{n}{op}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} our ¬ notation; Lean\PYGZsq{}s bnot}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pBinOp} \PYG{n}{op} \PYG{n}{e1} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{bin\PYGZus{}op\PYGZus{}sem} \PYG{n}{op}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} BUG FIXED :\PYGZhy{})!}
\end{sphinxVerbatim}


\subsection{Formal Validation}
\label{\detokenize{A_01_Propositional_Logic:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} proof of one key property: \PYGZdq{}commutativity of ∧\PYGZdq{} in the logic we\PYGZsq{}ve specified,, as required}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}commutes} \PYG{o}{:}
  \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
    \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
    \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{∧} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n}{e2} \PYG{n+nb+bp}{∧} \PYG{n}{e1}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} assume that e1 e2 and i are arbitrary}
\PYG{k}{assume} \PYG{n}{e1} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} unfold definition of pEval for given arguments}
\PYG{n}{unfold} \PYG{n}{pEval}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} unfold definition of bin\PYGZus{}op\PYGZus{}sem}
\PYG{n}{unfold} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} case analysis on Boolean value (pEval e1 i)}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} within first case, nested case analysis on (pEval e2 i)}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} goal proved by reflexivity of equality}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} second case for (pEval e2 i) within first case for  (pEval e1 i)}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} onto second case for (pEval e1 i)}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} again nested case analysis on (pEval e2 i)}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} and both cases are again true by reflexivity of equality}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} QED}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Examples}
\label{\detokenize{A_01_Propositional_Logic:examples}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} tell Lean to explain given notations}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{¬}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{∧}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{↑}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variables}
\PYG{k+kd}{def} \PYG{n}{v₀} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}
\PYG{k+kd}{def} \PYG{n}{v₁} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}
\PYG{k+kd}{def} \PYG{n}{v₂} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expressions}
\PYG{k+kd}{def} \PYG{n}{X} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₀}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Y} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₁}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Z} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₂}\PYG{o}{]}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} operator expressions}
\PYG{k+kd}{def} \PYG{n}{e1} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e3} \PYG{o}{:=} \PYG{n+nb+bp}{¬}\PYG{n}{Z}
\PYG{k+kd}{def} \PYG{n}{e4} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2}
\PYG{k+kd}{def} \PYG{n}{e5} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e1}
\PYG{k+kd}{def} \PYG{n}{e6} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{⊕} \PYG{n+nb+bp}{¬}\PYG{n}{X}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} an interpretation}
\PYG{k+kd}{def} \PYG{n}{an\PYGZus{}interp} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{tt} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} X}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{ff} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Y}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{2}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{tt} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Z}
\PYG{n+nb+bp}{|} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{ff}               \PYG{c+c1}{\PYGZhy{}\PYGZhy{} any other variable}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} evaluation}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pEval} \PYG{n}{X} \PYG{n}{an\PYGZus{}interp}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pEval} \PYG{n}{Y} \PYG{n}{an\PYGZus{}interp}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{an\PYGZus{}interp}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pEval} \PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{Y}\PYG{o}{)} \PYG{n}{an\PYGZus{}interp}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} oops}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} applying theorem!}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}commutes} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{an\PYGZus{}interp}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} result is a proof that ff = ff}
\end{sphinxVerbatim}


\subsection{Exercises}
\label{\detokenize{A_01_Propositional_Logic:exercises}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Formally state and prove that in our language, or (∨) is commutative (1 minute!)

\item {} 
\sphinxAtStartPar
Formally state and prove that in our language, not (¬) is involutive (a few minutes).
Hints: Put parens around (¬¬e). Open the Lean infoview with CTRL/CMD\sphinxhyphen{}SHIFT\sphinxhyphen{}RETURN/ENTER.
If you get hung up on Lean syntax, ask a friend (or instructor) for help to get unstuck.

\end{enumerate}


\subsection{Solutions}
\label{\detokenize{A_01_Propositional_Logic:solutions}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} The proof that ∨ is commutative is basically identical to that for ∧}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}commutes} \PYG{o}{:}
  \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
    \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
    \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{∨} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n}{e2} \PYG{n+nb+bp}{∨} \PYG{n}{e1}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Suppose e1 e2 and i are arbitrary expressions and interpretation}
\PYG{k}{assume} \PYG{n}{e1} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} unfold definitions of pEval and bin\PYGZus{}op\PYGZus{}sem applied to their arguments}
\PYG{n}{unfold} \PYG{n}{pEval}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} proof by simple case analysis on possible results of evaluating e1 and e2 under i}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} QED: By showing it\PYGZsq{}s true for arbitrary e1/e2/i we\PYGZsq{}ve shown it\PYGZsq{}s true for *all*}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Prove not is involutive}
\PYG{k+kd}{theorem} \PYG{n}{not\PYGZus{}involutive}\PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{e} \PYG{n}{i}\PYG{o}{,} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n+nb+bp}{¬}\PYG{n+nb+bp}{¬}\PYG{n}{e}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{e} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{pEval}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{un\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}
\PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{apply} \PYG{n}{rfl} \PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{end} \PYG{n}{cs6501}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nb+bp}{.}\PYG{n}{A\PYGZus{}05\PYGZus{}prop\PYGZus{}logic\PYGZus{}properties}
\PYG{k+kn}{namespace} \PYG{n}{cs6501}
\end{sphinxVerbatim}


\section{Algebraic Axioms}
\label{\detokenize{A_01_Propositional_Logic:algebraic-axioms}}
\sphinxAtStartPar
We’ve now seen that it’s not enough to prove a few
theorems about a construction (here our syntax and
semantics for propositional logic).

\sphinxAtStartPar
So how will we confirm \sphinxstyleemphasis{for sure} that our model (or
implementation) of propositional logic is completely
valid?

\sphinxAtStartPar
We’ll offer two different methods. First, in this
chapter, we’ll prove that our specification satisfies
the \sphinxstyleemphasis{algebraic axioms} of propositional logic. Second,
in the next chapter, we’ll prove that the \sphinxstyleemphasis{inference
rules} of propositional logic are valid in our model.

\sphinxAtStartPar
Along the way we’ll take the opportunity to see more
of what Lean can do for us:
\sphinxhyphen{} Scott/semantic bracket notation for \sphinxstyleemphasis{meaning\sphinxhyphen{}of}
\sphinxhyphen{} declare automatically introduced variables
\sphinxhyphen{} use of implicit arguments to further improve notation
\sphinxhyphen{} universally quantified variables are function arguments
\sphinxhyphen{} “sorry” to bail out of a proof and accept proposition as axiom

\sphinxAtStartPar
To avoid duplication of code from the last chapter,
we’ll import all of the definitions in its Lean file
for use here.
Algebraic Properties
——————–

\sphinxAtStartPar
First, a propositional logic can be understood as an \sphinxstyleemphasis{algebra} with
Boolean\sphinxhyphen{}valued (as opposed to numeric) terms, variables, and constants.
Constants and variables are are terms, but terms are also  constructed
from smaller terms using connectives: ∧, ∨, ¬, and so on. The axioms of
propopsitions define how these operations work, on their own and when
combined.

\sphinxAtStartPar
These algebraic properties of propositional logic are very much akin
to the usual commutativity, associativity, distributivity, identity,
and other such properties of the natural numbers and the addition and
multiplication operations on them. As we go through the analogous
properties for propositional logic, note the common properties of both
algebras.


\subsection{Commutativity}
\label{\detokenize{A_01_Propositional_Logic:commutativity}}
\sphinxAtStartPar
The first two axioms that that the and and or operators
(∧, ∨) are commutative. One will often see these rules
written in textbooks and tutorials as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
(p ∧ q) = (q ∧ p)

\item {} 
\sphinxAtStartPar
(p ∨ q) = (q ∨ p)

\end{itemize}

\sphinxAtStartPar
This kind of presentation hides a few assumptions. First,
it assumes p and q are taken to be arbitrary expressions
in propositional logic. Second, it assumes that what is
really being compared here are not the expressions per se
but their semantic meanings. Third it assumes that equality
of meanings hold under all possible interpretations.

\sphinxAtStartPar
To be completely formal in Lean, we need to be explicit
about these matters. We need to define variables, such as
p and q, to be arbitrary expressions. Second, we need to
be clear that the quantities that are equal are not the
propositions themselves but their \sphinxstyleemphasis{meanings} under all
possible interpretations.

\sphinxAtStartPar
We have already seen, in the last chapter, how to do this.
For example, we defined the commutative property of ∧ as
follows. In mathematical natural language we can read this
as “for any expressions, p and q, the meaning of \sphinxstyleemphasis{p ∧ q}
is equal to that of \sphinxstyleemphasis{q ∧ p} under all interpretations.”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:}
\PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{p} \PYG{n}{q} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
  \PYG{n}{pEval} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{pEval} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=}
\PYG{n}{and\PYGZus{}commutes}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} proof from last chapter}
\end{sphinxVerbatim}


\subsection{Another Notation}
\label{\detokenize{A_01_Propositional_Logic:another-notation}}
\sphinxAtStartPar
As we’ve seen, mathematical theories are often
augmented with concrete syntactic notations that
make it easier for people to read and write such
mathemantics. We would typically write \sphinxstyleemphasis{3 + 4},
for example, in lieu of \sphinxstyleemphasis{nat.add 3 4}. For that
matter, we write \sphinxstyleemphasis{3} for (succ(succ(succ zero))).
Good notations are important.

\sphinxAtStartPar
One area in our specification that could use an
improvement is where we apply the \sphinxstyleemphasis{pEval} semantic
\sphinxstyleemphasis{meaning\sphinxhyphen{}of} operator to a given expression. The
standard notation for sucg a “meaning\sphinxhyphen{}of” operator
is a pair of \sphinxstyleemphasis{denotation} or \sphinxstyleemphasis{Scott} brackets.

\sphinxAtStartPar
We thus write \sphinxstyleemphasis{⟦ e ⟧} as “the meaning of \sphinxstyleemphasis{e}” and
define this notation to desugar to \sphinxstyleemphasis{pEval e}. We
thus  write \sphinxstyleemphasis{⟦ e ⟧ i} to mean the truth (Boolean)
value of \sphinxstyleemphasis{e} under the interpretation i. Thus, the
expression, \sphinxstyleemphasis{⟦ e ⟧ i}, desugars to  \sphinxstyleemphasis{pEval e i},
which in turn reduces to the Boolean meaning of
\sphinxstyleemphasis{e} under \sphinxstyleemphasis{i}.

\sphinxAtStartPar
With this notation in hand, we’ll be able to write
all of the algebraic axioms of propositional logic
in an easy to read, mathematically fairly standard
style. So let’s go ahead and define this notation,
and then use it to specify the commutative property
of logical ∧ using it.
Here’s the notation definition. When an operation,
such as pEval is represented by tokens on either side
of an argument, we call this an outfix notation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pEval}\PYG{o}{)} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⟦} \PYG{n+nb+bp}{`} \PYG{n}{p} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⟧} \PYG{n+nb+bp}{`}  \PYG{o}{:=}  \PYG{n}{pEval} \PYG{n}{p}
\end{sphinxVerbatim}


\subsection{Variable Declarations}
\label{\detokenize{A_01_Propositional_Logic:variable-declarations}}
\sphinxAtStartPar
It’s common when specifying multiple of properties of a
given object or collection of objects to introduce the
same variables at the beginning of each definition. For
example, we started our definition of the commutative
property with \sphinxstyleemphasis{∀ (p q : prop\_expr) (i : prop\_var → bool)}.
Lean allows us to avoid having to do this by declaring
such variables once, in a \sphinxstyleemphasis{section} of a specification,
and then to use them in multiple definitions without
the need for redundant introductions. Let’s see how it
works.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} start a section}
\PYG{k+kn}{section} \PYG{n}{prop\PYGZus{}logic\PYGZus{}axioms}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Let p, q, r, and i be arbitrary expressions and an}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} interpretation}
\PYG{k+kd}{variables} \PYG{o}{(}\PYG{n}{p} \PYG{n}{q} \PYG{n}{r} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we can write expressions with these variables
without explicitly introducing them. As an aside, in
this example, we add prime marks to the names used in
imported chapter to avoid conflicts with names used in
that file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{o}{:=} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{)}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}commutes\PYGZsq{}} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Specialization of Generalizations}
\label{\detokenize{A_01_Propositional_Logic:specialization-of-generalizations}}
\sphinxAtStartPar
Observe: We can \sphinxstyleemphasis{apply} these theorems
to particular objects to specalize the
generalized statement to the particular
objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{p} \PYG{n}{q} \PYG{n}{i}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can use notations not only in writing
propositions to be proved but also in our
proof\sphinxhyphen{}building scripts. In addition to doing
that in what follows, we illustrate two new
elements of the Lean proof script (or tactic)
language. First, we can sequentially compose
tactics into larger tactics using semi\sphinxhyphen{}colon.
Second we can use \sphinxstyleemphasis{repeat} to repeated apply a
tactic until it fails to apply. The result
can be a nicely compacted proof script.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} by unfolding definitions and case analysis}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{p} \PYG{n}{q} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{p} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{q} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{n+nb+bp}{;} \PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{apply} \PYG{n}{rfl} \PYG{o}{\PYGZcb{}} \PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Associativity}
\label{\detokenize{A_01_Propositional_Logic:associativity}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}associative\PYGZus{}axiom} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}associative\PYGZus{}axiom} \PYG{o}{:=}   \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Distributivity}
\label{\detokenize{A_01_Propositional_Logic:distributivity}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}dist\PYGZus{}and\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}dist\PYGZus{}or\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{DeMorgan’s Laws}
\label{\detokenize{A_01_Propositional_Logic:demorgan-s-laws}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{demorgan\PYGZus{}not\PYGZus{}over\PYGZus{}and\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{¬}\PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{demorgan\PYGZus{}not\PYGZus{}over\PYGZus{}or\PYGZus{}axiom} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{¬}\PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Negation}
\label{\detokenize{A_01_Propositional_Logic:negation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{negation\PYGZus{}elimination\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Excluded Middle}
\label{\detokenize{A_01_Propositional_Logic:excluded-middle}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{excluded\PYGZus{}middle\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{⊤}\PYG{n+nb+bp}{⟧} \PYG{n}{i}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} or just tt}
\end{sphinxVerbatim}


\subsection{No Contradiction}
\label{\detokenize{A_01_Propositional_Logic:no-contradiction}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{no\PYGZus{}contradiction\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{⊥}\PYG{n+nb+bp}{⟧} \PYG{n}{i}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} or just tt}
\end{sphinxVerbatim}


\subsection{Implication}
\label{\detokenize{A_01_Propositional_Logic:implication}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{implication\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} notation issue}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{implication\PYGZus{}axiom} \PYG{n}{p} \PYG{n}{q} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{implication\PYGZus{}axiom} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem} \PYG{n}{un\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{p} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{n+nb+bp}{;} \PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{q} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{n+nb+bp}{;} \PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{apply} \PYG{n}{rfl} \PYG{o}{\PYGZcb{}} \PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
The next two sections give the axioms for simplifying expressions
involving ∧ and ∨.


\subsection{And Simplification}
\label{\detokenize{A_01_Propositional_Logic:and-simplification}}
\sphinxAtStartPar
p ∧ p = p
p ∧ T = p
p ∧ F = F
p ∧ (p ∨ q) = p


\subsection{Or Simplification}
\label{\detokenize{A_01_Propositional_Logic:or-simplification}}
\sphinxAtStartPar
p ∨ p = p
p ∨ T = T
p ∨ F = p
p ∨ (p ∧ q) = p

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{end} \PYG{n}{prop\PYGZus{}logic\PYGZus{}axioms}
\PYG{k+kd}{end} \PYG{n}{cs6501}
\end{sphinxVerbatim}


\subsection{Homework}
\label{\detokenize{A_01_Propositional_Logic:homework}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Formalize the and/or simplification rules.

\end{enumerate}

\sphinxAtStartPar
2. Use Lean’s \sphinxstyleemphasis{theorem} command to assert,
give, and name proofs that our Lean model
satisfies all of the algebraic axioms of
propositional logic, as formalized above.

\sphinxAtStartPar
Solving this problem is repetitive application
of what we’ve done already in a few examples,
but it’s still worth writing and running these
proofs scripts a few times to get a better feel
for the process.

\sphinxAtStartPar
3. Collaboratively refactor the “code” we’ve
developed into a mathematical library component
with an emphasis on good design.

\sphinxAtStartPar
What does that even mean? Good with respect to
what criteria, deciderata, needs, objectives?
\begin{itemize}
\item {} 
\sphinxAtStartPar
data type definitions

\item {} 
\sphinxAtStartPar
operation definitions

\item {} 
\sphinxAtStartPar
notation definitions

\item {} 
\sphinxAtStartPar
formal validation

\item {} 
\sphinxAtStartPar
some helpful examples

\end{itemize}


\section{Algebraic Axioms}
\label{\detokenize{A_01_Propositional_Logic:id9}}
\sphinxAtStartPar
We’ve now seen that it’s not enough to prove a few
theorems about a construction (here our syntax and
semantics for propositional logic).

\sphinxAtStartPar
So how will we confirm \sphinxstyleemphasis{for sure} that our model (or
implementation) of propositional logic is completely
valid?

\sphinxAtStartPar
In this class we’ll distinguish two different methods.
First, we can prove that our specification satisfies
the \sphinxstyleemphasis{algebraic axioms} of propositional logic. Second,
we can prove that all of the \sphinxstyleemphasis{inference rules} of the
logic are valid in our model of propositional logic.

\sphinxAtStartPar
Along the way we’ll take the opportunity to see more
of what Lean can do for us:
\sphinxhyphen{} Scott/semantic bracket notation for \sphinxstyleemphasis{meaning\sphinxhyphen{}of}
\sphinxhyphen{} declare automatically introduced variables
\sphinxhyphen{} use of implicit arguments to further improve notation
\sphinxhyphen{} universally quantified variables are function arguments
\sphinxhyphen{} “sorry” to bail out of a proof and accept proposition as axiom

\sphinxAtStartPar
To avoid duplication of code from the last chapter,
we’ll import all of the definitions in its Lean file
for use here.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nb+bp}{.}\PYG{n}{A\PYGZus{}05\PYGZus{}prop\PYGZus{}logic\PYGZus{}properties}
\PYG{k+kn}{namespace} \PYG{n}{cs6501}
\end{sphinxVerbatim}

\sphinxAtStartPar
First, a propositional logic can be understood as an algebra over
Boolean\sphinxhyphen{}valued terms, variables, and constants. Constants and variables
are are terms, but terms can also be constructed from smaller terms using
connectives: ∧, ∨, ¬, and so on. The axioms of propopsitiona logic impose
constraints on how these operations behave, on their own and combined.

\sphinxAtStartPar
The constraints are algebraic, just as the axioms are algebraic that
impose the standard ring structure on the natural numbers. These are
the \sphinxstyleemphasis{usual} commutativity and associativity properties of natural number
addition and multiplication, the distributivity of multiplication over
addition, and so forth. As we go through the required properties for
propositional logic, note the common underlying algebraic structure.


\subsection{Commutativity}
\label{\detokenize{A_01_Propositional_Logic:id10}}
\sphinxAtStartPar
The first two axioms that that the and and or operators
(∧, ∨) are commutative. One will often see these rules
written as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
(p ∧ q) = (q ∧ p)

\item {} 
\sphinxAtStartPar
(p ∨ q) = (q ∨ p)

\end{itemize}

\sphinxAtStartPar
To be completely formal, we need to be a more careful.
First, we need to define variables such as p and q as
being universally quantified. Second, we need to make clear
that the quantities that are equal are not the propositions
themselves (they are not equal) but their \sphinxstyleemphasis{meanings} under
all interpretations. Thus in the last chapter we defined
the commutativity of ∧ like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:}
\PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{p} \PYG{n}{q} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
  \PYG{n}{pEval} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{pEval} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=}
\PYG{n}{and\PYGZus{}commutes}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} proof from last chapter}
\end{sphinxVerbatim}

\sphinxAtStartPar
As we’ve seen, mathematical theories are often
augmented with concrete syntax / notations that
make it practical for people to read and write
such mathemantics.

\sphinxAtStartPar
A standard notation for a “meaning\sphinxhyphen{}of\sphinxhyphen{}expression”
operator is a pair of \sphinxstyleemphasis{denotation} or \sphinxstyleemphasis{Scoot}
brackets. So \sphinxstyleemphasis{⟦ e ⟧} can be read as “the meaning
of \sphinxstyleemphasis{e}.” To resolve meaning, an interpretation,
\sphinxstyleemphasis{i}. We’ll thus write \sphinxstyleemphasis{⟦ e ⟧ i} to mean the meaning
of e under the interpretation i: \sphinxstyleemphasis{pEval e i}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pEval}\PYG{o}{)} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⟦} \PYG{n+nb+bp}{`} \PYG{n}{p} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⟧} \PYG{n+nb+bp}{`}  \PYG{o}{:=}  \PYG{n}{pEval} \PYG{n}{p}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{W}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{l}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{a}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{s}\PYG{c+cm}{s}
\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k+kn}{section} \PYG{n}{prop\PYGZus{}logic\PYGZus{}axioms}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Let p, q, r, and i be arbitrary expressions and an interpretation}
\PYG{k+kd}{variables} \PYG{o}{(}\PYG{n}{p} \PYG{n}{q} \PYG{n}{r} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} now we can write expressions with these variables without explicitly introducing them by ∀}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} we add prime marks just to avoid naming conflicts, the primes have no special meaning here}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}commutes\PYGZsq{}} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{C}\PYG{c+cm}{o}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}
\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{m}\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{w}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{h}\PYG{c+cm}{o}\PYG{c+cm}{w}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}
\PYG{c+cm}{s}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{y}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{∀}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{q}\PYG{c+cm}{u}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{a}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{s}
\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{s}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k}{\PYGZsh{}check} \PYG{n}{and\PYGZus{}commutes}
\PYG{k}{\PYGZsh{}check} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{O}\PYG{c+cm}{b}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{:}\PYG{c+cm}{ }\PYG{c+cm}{W}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{a}\PYG{c+cm}{p}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{m}\PYG{c+cm}{s}
\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{b}\PYG{c+cm}{j}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{z}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}
\PYG{c+cm}{g}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{z}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{a}\PYG{c+cm}{r}
\PYG{c+cm}{o}\PYG{c+cm}{b}\PYG{c+cm}{j}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{s}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}

\PYG{k+kd}{variables} \PYG{o}{(}\PYG{n}{a} \PYG{n}{b} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{p} \PYG{n}{q} \PYG{n}{i}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{a} \PYG{n}{b} \PYG{n}{i}


\PYG{c+c1}{\PYGZhy{}\PYGZhy{} re\PYGZhy{}doing proof with new notation}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{p} \PYG{n}{q} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} expand definitions}
\PYG{n}{unfold} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} rest by case analysis as usual}
\PYG{g+gr}{sorry}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Associativity}
\label{\detokenize{A_01_Propositional_Logic:id11}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}associative\PYGZus{}axiom} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}associative\PYGZus{}axiom} \PYG{o}{:=}   \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Distributivity}
\label{\detokenize{A_01_Propositional_Logic:id12}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}dist\PYGZus{}and\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}dist\PYGZus{}or\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{DeMorgan’s Laws}
\label{\detokenize{A_01_Propositional_Logic:id13}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{demorgan\PYGZus{}not\PYGZus{}over\PYGZus{}and\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{¬}\PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{demorgan\PYGZus{}not\PYGZus{}over\PYGZus{}or\PYGZus{}axiom} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{¬}\PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Negation}
\label{\detokenize{A_01_Propositional_Logic:id14}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{negation\PYGZus{}elimination\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Excluded Middle}
\label{\detokenize{A_01_Propositional_Logic:id15}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{excluded\PYGZus{}middle\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{⊤}\PYG{n+nb+bp}{⟧} \PYG{n}{i}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} or just tt}
\end{sphinxVerbatim}


\subsection{No Contradiction}
\label{\detokenize{A_01_Propositional_Logic:id16}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{no\PYGZus{}contradiction\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{⊥}\PYG{n+nb+bp}{⟧} \PYG{n}{i}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} or just tt}
\end{sphinxVerbatim}


\subsection{Implication}
\label{\detokenize{A_01_Propositional_Logic:id17}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{implication\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} notation issue}


\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{implication\PYGZus{}axiom} \PYG{n}{a} \PYG{n}{b} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{implication\PYGZus{}axiom} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem} \PYG{n}{un\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{a} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{b} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} = bnot ( ⟦ a ⟧ i) || ⟦ b ⟧ i}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{And Simplification}
\label{\detokenize{A_01_Propositional_Logic:id18}}
\sphinxAtStartPar
Homework: Formalize

\sphinxAtStartPar
p ∧ p = p
p ∧ T = p
p ∧ F = F
p ∧ (p ∨ q) = p


\subsection{Or Simplification}
\label{\detokenize{A_01_Propositional_Logic:id19}}
\sphinxAtStartPar
Homework: Formalize

\sphinxAtStartPar
p ∨ p = p
p ∨ T = T
p ∨ F = p
p ∨ (p ∧ q) = p


\subsubsection{Inference Rules}
\label{\detokenize{A_01_Propositional_Logic:inference-rules}}
\sphinxAtStartPar
Key idea: These are rules for reasoning about evidence.
What \sphinxstyleemphasis{evidence} do you need to derive a given conclusion?
These are the “introduction” rules. From a given piece of
evidence (and possibly with additional evidence) what new
forms of evidence can you derive? These are “elimination”
rules of the logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 1. ⊢ ⊤                     \PYGZhy{}\PYGZhy{} true introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 2. ⊥, X ⊢ X                \PYGZhy{}\PYGZhy{} false elimination}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 3. X, Y ⊢ X ∧ Y            \PYGZhy{}\PYGZhy{} and\PYGZus{}introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 4. X ∧ Y ⊢ X               \PYGZhy{}\PYGZhy{} and\PYGZus{}elimination\PYGZus{}left}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 5. X ∧ Y ⊢ Y               \PYGZhy{}\PYGZhy{} and\PYGZus{}elimination\PYGZus{}right}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 6. X ⊢ X ∨ Y               \PYGZhy{}\PYGZhy{} or introduction left}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 7. Y ⊢ X ∨ Y               \PYGZhy{}\PYGZhy{} or introduction right}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 8. X ∨ Y, X → Z, Y → Z ⊢ Z \PYGZhy{}\PYGZhy{} or elimination}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 9. ¬¬X ⊢ X                 \PYGZhy{}\PYGZhy{} negation elimination}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 10. X → ⊥ ⊢ ¬X              \PYGZhy{}\PYGZhy{} negation introduction}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 11. (X ⊢ Y) → (X → Y)      \PYGZhy{}\PYGZhy{} a little complicated}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 12. X → Y, X ⊢ Y           \PYGZhy{}\PYGZhy{} arrow elimination}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 13. X → Y, Y → X ⊢ X ↔ Y    \PYGZhy{}\PYGZhy{} iff introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 14. X ↔ Y ⊢ X → Y          \PYGZhy{}\PYGZhy{} iff elimination left}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 15. X ↔ Y ⊢ Y → X          \PYGZhy{}\PYGZhy{} iff elimination right}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the style we’ve developed, formally state and prove
that our logic and semantics has each of the properties,
1, 2, 4, 5, 6, 8, 9, 10, 12, and 15. Identify any rules
that fail to be provable due to the injected bug in bimp.

\sphinxAtStartPar
Use Lean’s \sphinxstyleemphasis{theorem} directive to give names to proofs.
as names for your proofs, use the names in the comments
after each rule (adding missing underscores as needed).

\sphinxAtStartPar
To do this part of the assignment, make a copy of this
file from the class repo and add the statement and proof
of each theorem below. You will turn in the file with these
proofs included in the given order at the end of the file.

\sphinxAtStartPar
This isn’t a comprehensive list of properties. We lack
rules for ⊤ and ⊥ (formerly True, False; still terms
that invariably evaluate to true (tt) and false (ff).
There are rules that explain, for example, that ⊤ ∧ e
is equivalent to e; ⊥ ∧ e is invariably false; ⊥ or e
is equivalent to e; and ⊤ ∨ e is invariably true. Go
ahead and prove these propositions as well if you just
can’t stop proving! (optional :\sphinxhyphen{}).

\sphinxAtStartPar
Try to do all or at least most of this assignment on
your own. Feel free to ask for or give help on minor
matters, e.g., of Lean syntax, or if some concept isn’t
yet clear enough. Discussing such issues is constructive.
I skipped over properties whose proofs look almost just
like those for closely related properties.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{end} \PYG{n}{cs6501}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Index}
\label{\detokenize{genindex:index}}\label{\detokenize{genindex::doc}}


\renewcommand{\indexname}{Index}
\printindex
\end{document}