%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother


\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage{unixode}
\definecolor{VerbatimBorderColor}{rgb}{0.7,0.7,0.7}
% from sphinxmanual.cls: put authors on separate lines
\DeclareRobustCommand{\and}{%
   \end{tabular}\kern-\tabcolsep\\\begin{tabular}[t]{c}%
}


\title{Computing Foundations}
\date{Mar 15, 2023}
\release{1.2.2}
\author{Kevin Sullivan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{CS6501 Spring 2023}
\label{\detokenize{A_00_Introduction:cs6501-spring-2023}}\label{\detokenize{A_00_Introduction:introduction}}\label{\detokenize{A_00_Introduction::doc}}

\section{To Think Abstractly}
\label{\detokenize{A_00_Introduction:to-think-abstractly}}
\sphinxAtStartPar
To advance science and engineering, we need languages in
which we can describe and reason about complex worlds. By
a \sphinxstyleemphasis{world} we mean a collection of objects of interest and
their structures, properties, behaviors, relations to each
other.


\subsection{Abstract Mathematics}
\label{\detokenize{A_00_Introduction:abstract-mathematics}}
\sphinxAtStartPar
Mathematics and formal logics provide such languages. They
give us the intellectual tools we need to think abstractly
and yet with great precision about rich and complex systems:
to represent, reason about, and ultimately design complex
worlds that would otherwise remain beyond our grasps.

\sphinxAtStartPar
As an example, the abstract mathematics of linear and affine
spaces give us languages for describing, reasoning about, and
designing systems that work in the \sphinxstyleemphasis{classical} physical world
we experience every day. The abstract mathematics of tensor
fields on topological manifolds are essential for describing,
reasoning about, and designing interventions in the \sphinxstyleemphasis{quantum}
world of particle physics.

\sphinxAtStartPar
By the term, \sphinxstyleemphasis{abstract}, we mean that descriptions in such
languages represent relevant phenomena precisely, concisely,
and without any unnecessary complexity or inessential detail.

\sphinxAtStartPar
As an example, a physicist might represent two accelerations
applied to a drone in a three\sphinxhyphen{}dimensional geometric space in
abstract, coordinate\sphinxhyphen{}free terms, by writing this: \sphinxstyleemphasis{let a₁ and
a₂ be accelerations of the drone.} This formulation is abstract
insofar as no coordinates are given for these vectors. The
assignment of coordinates to \sphinxstyleemphasis{physical} quantities is usually
arbitrary and unnecessary to express. A physicist might, for
example, represent \sphinxstyleemphasis{the sum of these accelerations} simply as
\sphinxstyleemphasis{a₁ + a₂.} This expression has an absolutely precise physical
meaning even though it’s abstract.

\sphinxAtStartPar
A programmer, by contrast, would typically jump to a choice
of some coordinate system and would then represent the two
physical quantities in the concrete (\sphinxstyleemphasis{parametric}) terms of
tuples of floating point numbers; with the summation of the
physical accelerations represented by element\sphinxhyphen{}wise floating
point addition of the corresponding coordinate tuples.


\subsection{Costs of Concreteness}
\label{\detokenize{A_00_Introduction:costs-of-concreteness}}
\sphinxAtStartPar
This ubiquitous approach to programming physical computations
is problematical in multiple dimensions. First, as mentioned,
it substitues concrete representations for abstract, adding
inessesntial complexity to models and computations. Second,
it generally strips away crucial mathematical properties of
the abstract representations of objects of interest, making
it impossible to check programs for consistency with such
mathematics.

\sphinxAtStartPar
For example, in the \sphinxstyleemphasis{tf} and \sphinxstyleemphasis{tf2} affine space libraries of
the Robot Operating System (ROS) platform for the programming
of terrestrial robots, points and vectors are represented in
the concrete terms of coordinate tuples relative to arbitrary
coordinate frames. But it gets worse: points and vectors in
this framework are aliases for the same concrete type: a type
of floating\sphinxhyphen{}point tuples.

\sphinxAtStartPar
This means, among other things, that one can add points to
points in \sphinxstyleemphasis{tf} without receiving any type errors from the
programming language system, even though addition of points
to points makes no physical sense and is inconsistent with
the abstract mathematics of the domain. In an affine space,
there is no operation for adding points to point.

\sphinxAtStartPar
The nearly exclusive use of concrete representations in most
everyday programming complicates software design and reasoning
by requiring the manipulation of often complex, inessential
details. And because so much of the structure of the mathematics
of the domain is \sphinxstyleemphasis{forgotten} in the programming code, it also
becomes impossible for the programming system to check for what
we might call \sphinxstyleemphasis{full physical type consistency}.

\sphinxAtStartPar
Programming code thus generally ends up deeply disconnected
from the abstract mathematics of the physics of the domain that
it’s meant to represent, manipulate, implement, and free to
carry out inconsistent operations. As one example, programmers
often struggle mightily using different frames of reference in
a consistent manner, e.g., by adding vectors represented by
numerical tuples but with coordinates expressed in different
frames of reference.

\sphinxAtStartPar
A special case, by the way, is operating incorrectly on values
because they are expressed in different units, such a meters
and feet. We can understand 1 meter and 1 foot as each being
a basis vector for the \sphinxstyleemphasis{same} one\sphinxhyphen{}dimensional physical space.
Clearly adding numerical values of 2 (feet) and 3 (meters) to
produce 5 of \sphinxstyleemphasis{something,} produces a meaningless result.


\subsection{A Path Forward}
\label{\detokenize{A_00_Introduction:a-path-forward}}
\sphinxAtStartPar
So why haven’t we already deeply connected concrete to code
the abstract mathematics of the domain in which it’s meant
to operate? Perhaps the most fundamental reason is that math
has up until recently been a quasi\sphinxhyphen{}formal, paper\sphinxhyphen{}and\sphinxhyphen{}pencil
exercise, making it, hard even impossible, to connect code
to such mathematics.

\sphinxAtStartPar
Now, with rapidly developing work by a still small set of
ressearchers in mathematics, the complete formalization and
mechanization of advanced abstract mathematics is becoming
a reality. As and example Massot and his colleagues in 2022
managed to formalize not only a statement, but a proof, of
the local h\sphinxhyphen{}principle for first\sphinxhyphen{}order, open, ample partial
differential relations, with the possibility of eversion of
the 3\sphinxhyphen{}sphere as a corollary.

\sphinxAtStartPar
Their work showed that their approach to formalizing
mathematics is no longer useful mostly just for abstract
algebra, but that it also now promises advances in abstract
geometry (e.g., on manifolds), which is at the very heart
of not only terrestrial robotics but also modern physics
and perhaps even areas such areas as deep learning.


\subsection{The Vision}
\label{\detokenize{A_00_Introduction:the-vision}}
\sphinxAtStartPar
The insight driving this class is that this kind of work
from the  mathematics community is now making it possible
to develop \sphinxstyleemphasis{computable abstract mathematics} for purposes
of software engineering. Promising application domains for
such work clearly include divere cyber\sphinxhyphen{}physical systems and
might be relevant to deep learning as well, with its basic
assumption that real\sphinxhyphen{}world data have geometric properties,
such as lying on high\sphinxhyphen{}dimensional manifolds.

\sphinxAtStartPar
What we seek are ways to enable use of the abstract mathematical
languages of such domains, coupled with concrete representations
to support computation, with \sphinxstyleemphasis{full physical type checking} of the
physical mathematics; \sphinxstyleemphasis{foundational proofs} of correctness of the
mathematics; and explicit link to concrete (often coordinate\sphinxhyphen{}based)
representations that are necessary in practical implementations.


\subsection{This Class}
\label{\detokenize{A_00_Introduction:this-class}}
\sphinxAtStartPar
The purpose of this class is to introduce computer science
students to the ideas necessary to pursue both research and
development activities based on these ideas. We will use the
preferred tool of the community of mathematicians pushing the
formalization of mathematics, namely the Lean Proof Assistant,
developed by Leo DeMoura at Microsoft research, and the ever
growing \sphinxstyleemphasis{mathlib} library of formalized mathematics.


\section{Welcome. Overview.}
\label{\detokenize{A_00_Introduction:welcome-overview}}
\sphinxAtStartPar
This is a special topics course in software engineering. The idea
that we will explore is that we can now import ongoing advances
in the formalization of abstract mathematics (in type theory and
to a significant extent around the Lean prover and its mathematics
libraries) as new foundations for engineering software programs for
systems that inhabit domains that have such abstract mathematical
underpinnings. Such domains include physics, and thus also a broad
range of cyber\sphinxhyphen{}physical systems.

\sphinxAtStartPar
Along the way, you’ll learn formal logic and proof construction,
foundations of programming languages, functional programming, and
more. By the end you will know how to use some cutting\sphinxhyphen{}edge tools,
type theory and constructive logic proof assistants, to formalize
the abstract mathematics of important application domains.


\subsection{What does \sphinxstyleemphasis{abstract} mean here?}
\label{\detokenize{A_00_Introduction:what-does-abstract-mean-here}}
\sphinxAtStartPar
Here, the adjective, abstract, means \sphinxstyleemphasis{being coordinate\sphinxhyphen{}free}.
For the opposite of \sphinxstyleemphasis{abstract}, we’ll use \sphinxstyleemphasis{parametric}. The idea
is that a mathematical object, such as a vector, can be understood
simply as such, with no reference to coordinates; or that same abstract
vector can be represented concretely/parametrically as a struture of
parameter values expressed relative to some given frame of reference.


\subsection{Why \sphinxstyleemphasis{abstract} mathematics?}
\label{\detokenize{A_00_Introduction:why-abstract-mathematics}}
\sphinxAtStartPar
A premise of this class is that domain experts (e.g., in the
physics of terrestrial robotics, or of elemenary particles) speak,
model, analyze, and understand the operation of systems in the
abstract mathematical language of the domain, and very often not
in terms of ultimately arbitrarily selected frames of reference .

\sphinxAtStartPar
This is clear in physics where complex mathematical structures
such as tensor fields on topological manifolds are essential for
precise definitions of phenomena in particle physics.

\sphinxAtStartPar
Domain\sphinxhyphen{}specific abstract mathematics formalized in type theory
is what we see as an important language of the domain, to serve
as a basis for programming with static checking of abstractions,
and with parametric representations carried along as necessary.


\subsection{What is the point?}
\label{\detokenize{A_00_Introduction:what-is-the-point}}
\sphinxAtStartPar
A remarkable feature of constructive logics as hosted by many
proof assistants is that they can compute. Computation is now
wholly integral to practical logical reasoning if only because
some proofs require systematic case analysis over very large
numbers of cases, given as the outputs of other computations.

\sphinxAtStartPar
This is is relevant because it suggests that fully formalizing
the fully developed mathematical language of the given domain,
we will be well on our way to having reference specifications
and with computable implementations.

\sphinxAtStartPar
Going even further, the most recent version of Lean is intended
as an efficient general\sphinxhyphen{}purpose programming language as well as
a proof assistant, compiling to C, and with workable language
interoperability interfaces.

\sphinxAtStartPar
In the future we expect to be able to statically type check and
foundationally verify “code” written in the abstract mathematics
of the domain and with very little custom coding needed also to
have corresponding verified implementations, even if only used as
test oracles for production code.

\sphinxAtStartPar
This is the of abstract specifictions from which concrete
implementations are derived. I will not say refined because
in practice most derivations are not refinements but rather
toyish models of semantically rich and complex computations
in the source domain.


\subsection{This class}
\label{\detokenize{A_00_Introduction:id1}}
\sphinxAtStartPar
The first major part of this class will teach you the fundamentals
of programming and reasoning in Lean 3. We will mainly use Lean 3,
nothwithstaning that Lean 4 is garnering real attention and effort.
Student might wish to explore Lean 4 as an optional class activity.

\sphinxAtStartPar
The second part of the class will focus on how to formalized abstract
mathematical structures in Lean, and how we might such capabilities
to  these advances in formalizing mathematics to help meet
the need for statically type checked specifications in the abstract
language of the domain, with corresponding parametric representations
carried along for computational possibly and oher purposes.

\sphinxstepscope


\chapter{Propositional Logic}
\label{\detokenize{A_01_Propositional_Logic:propositional-logic}}\label{\detokenize{A_01_Propositional_Logic:introduction}}\label{\detokenize{A_01_Propositional_Logic::doc}}

\section{Balanced Parentheses}
\label{\detokenize{A_01_Propositional_Logic:balanced-parentheses}}
\sphinxAtStartPar
As a warmup, and to put some basic
concepts into play, we’ll begin by specifying the syntax
and semantics of a simple formal language: the language of
strings of balanced parentheses. Before we do that, we’ll
better explain wht it all menas. So let’s get started.


\subsection{Formal languages}
\label{\detokenize{A_01_Propositional_Logic:formal-languages}}
\sphinxAtStartPar
The syntax of a \sphinxstyleemphasis{formal language} defines a (possibly
infinite) set of strings. Strings are sequences of symbols
from some \sphinxstyleemphasis{alphabet} of symbols. The formal language of basic
algebra, for example, includes strings such as \sphinxstyleemphasis{x}, \sphinxstyleemphasis{y}, and
\sphinxstyleemphasis{x + y}, but not \sphinxstyleemphasis{x y}. Propositional logic includes \sphinxstyleemphasis{X}, \sphinxstyleemphasis{Y},
and \sphinxstyleemphasis{X ∧ Y} but not \sphinxstyleemphasis{X Y}.

\sphinxAtStartPar
As another example, which shortly we will specify formally,
consider the language of all strings of balanced parentheses.
The language includes the empty string, \sphinxstyleemphasis{(), (()), ((()))},
etc.  It does not include any unbalanced strings, such as
\sphinxstyleemphasis{(}, \sphinxstyleemphasis{)}, \sphinxstyleemphasis{((}, or \sphinxstyleemphasis{(()}.

\sphinxAtStartPar
Each string in our language will be of some finite nesting
depth (and thus length) but the number of strings in the
language is infinite. There is one such string for each
possible nesting depth of such a string. That is, for any
natural number, \sphinxstyleemphasis{n}, there is a such a string with nesting
depth \sphinxstyleemphasis{n}.

\sphinxAtStartPar
We clearly can’t specify the set of strings by exhaustively
enumerating them expliciitly. There are too many for that.
Rather, we need a concise, precise, finite, and manageable
way to specify the set of all such strings. We will do that
by defining a small set of \sphinxstyleemphasis{basic rules for building} strings
of this kind (we’ll call them \sphinxstyleemphasis{constructors}), sufficient for
constructing all and only the strings in the language.

\sphinxAtStartPar
We can specify the balanced parentheses language with just two
rules. First, the empty string, ∅, is in our language. Second,
if \sphinxstyleemphasis{b} is \sphinxstyleemphasis{any} string in the language, then so is \sphinxstyleemphasis{(b)}. That
is all we need to construct a string of any nesting depth.

\sphinxAtStartPar
The empty string (nesting depth 0) is just empty, while we can
construct a string of any positive depth by applying the first
rule once, giving us the \sphinxstyleemphasis{base string}, ∅, any by applying the
second rule iteratively, first to ∅, as many times as needed to
construct a string of balanced parentheses as big as desired.

\sphinxAtStartPar
A key characteristic of this definition is that it’s properly
\sphinxstyleemphasis{inductive}. That is, it provides ways to build larger values
of a given type (balanced parenthesis strings) from smaller
values \sphinxstyleemphasis{of the same type}. The complete set of strings that
these rules \sphinxstyleemphasis{generate} (by any finite number of applications
thereof) is exactly the set of strings, the \sphinxstyleemphasis{formal language}
that we set out to specify.


\subsection{Paper \& Pencil Syntax}
\label{\detokenize{A_01_Propositional_Logic:paper-pencil-syntax}}
\sphinxAtStartPar
What we’ve basically done in this case is to specify the set of
strings in our language with a \sphinxstyleemphasis{grammar} or \sphinxstyleemphasis{syntax definition}.
Such grammars are often expressed, especially in the programming
worls, using so\sphinxhyphen{}called \sphinxstyleemphasis{Backus\sphinxhyphen{}Naur Form (BNF)}.

\sphinxAtStartPar
Backus first used BNF notation to define the syntax of the Algol
60 programming language. BNF is basically a notation for specifying
what the linguist, Noam Chomsky, called \sphinxstyleemphasis{context\sphinxhyphen{}free grammars}.

\sphinxAtStartPar
Here’s a grammer in BNF for our language of balanced parentheses.
We can say that the BNF grammar defines the syntax, or permitted
forms, of strings in our language. Be sure you see how this grammar
allow larger expressions to be build from smaller ones of the same
kind (here \sphinxstyleemphasis{expression}).
\begin{quote}

\sphinxAtStartPar
expression ::=
| ∅
| (expression)
\end{quote}

\sphinxAtStartPar
This definition says that an expression (string) in our
language is either the empty string or it’s an expression
within a pair of parentheses. That’s it. That’s all it takes.


\subsection{Formal Syntax}
\label{\detokenize{A_01_Propositional_Logic:formal-syntax}}
\sphinxAtStartPar
Now we give an equivalent but \sphinxstyleemphasis{completely formal} definition
of this language in Lean. The key idea is that we will define
a new \sphinxstyleemphasis{data type} the values of which are all and only terms
representing strings in our language.

\sphinxAtStartPar
We’ll start by defining separate data types (each with just
one value) to represent left and right parentheses, respectively.
The names of the types are \sphinxstyleemphasis{lparen} and \sphinxstyleemphasis{rparen.} Each has a
single value that we will call \sphinxstyleemphasis{mk}. We can use qualified names
to distinguish these values: \sphinxstyleemphasis{lparen.mk} and \sphinxstyleemphasis{rparen.mk}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{lparen}
\PYG{n+nb+bp}{|} \PYG{n}{mk}

\PYG{k+kd}{inductive} \PYG{n}{rparen}
\PYG{n+nb+bp}{|} \PYG{n}{mk}


\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{H}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{.}
\PYG{c+cm}{I}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{L}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{a}
\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}
\PYG{c+cm}{i}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{a}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{.}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{I}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}
\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{L}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{a}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{b}\PYG{c+cm}{i}\PYG{c+cm}{t}
\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{a}
\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{h}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{)}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}

\PYG{k+kd}{def} \PYG{n}{a\PYGZus{}left\PYGZus{}paren} \PYG{o}{:} \PYG{n}{lparen} \PYG{o}{:=} \PYG{n}{lparen.mk}
\PYG{k+kd}{example}          \PYG{o}{:} \PYG{n}{rparen} \PYG{o}{:=} \PYG{n}{rparen.mk}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we’re set to specify the set of all and only balanced
parenthesis strings. We give an inductive definition with
the two rules (\sphinxstyleemphasis{constructors}). First, the empty string
(which for now we call mk\_empty to stand for ∅), is in the
set of balanced strings. Second, if \sphinxstyleemphasis{b} is any balanced
string, then the term \sphinxstyleemphasis{mk\_nonempty l b r} is also (that is
also represents) a balanced string, namely \sphinxstyleemphasis{(b)}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{bal}
\PYG{n+nb+bp}{|} \PYG{n}{mk\PYGZus{}empty}
\PYG{n+nb+bp}{|} \PYG{n}{mk\PYGZus{}nonempty} \PYG{o}{(}\PYG{n}{l}\PYG{o}{:} \PYG{n}{lparen}\PYG{o}{)} \PYG{o}{(}\PYG{n}{b} \PYG{o}{:} \PYG{n}{bal}\PYG{o}{)} \PYG{o}{(}\PYG{n}{r} \PYG{o}{:} \PYG{n}{rparen}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The only thing that a constructor does in such a definition
is to package up its arguments (if any) into a new term with
the constructor name as a first element (a label, if you will).
The type system of Lean will now recognize any term that can
be built using the available constructors as being of type bal.

\sphinxAtStartPar
Here we illustrate the use of these constructors to build the
first few balanced strings in our language. We Open the \sphinxstyleemphasis{bal}
namespace so that we don’t have to write \sphinxstyleemphasis{bal.} before each
constructor name. These constructor names do not conflict with
any existing definitions in the current (global) namespace.
We don’t open the lparen and rparen namespaces because then
we’d have two (ambiguous) definitions of the identifier, mk,
and we’d have to write \sphinxstyleemphasis{lparen.mk} or \sphinxstyleemphasis{rparen.mk} in any case
to disambiguate them.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{open} \PYG{n}{bal}

\PYG{k+kd}{def} \PYG{n}{b0} \PYG{o}{:} \PYG{n}{bal} \PYG{o}{:=}       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} ∅}
  \PYG{n}{mk\PYGZus{}empty}

\PYG{k+kd}{def} \PYG{n}{b1} \PYG{o}{:} \PYG{n}{bal} \PYG{o}{:=}       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} (∅)}
\PYG{n}{mk\PYGZus{}nonempty}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} constructor}
  \PYG{n}{lparen.mk}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} argument left parenthesis}
  \PYG{n}{b0}                  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} note: we could write mk\PYGZus{}empty}
  \PYG{n}{rparen.mk}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} argument right parenthesis}

\PYG{k+kd}{def} \PYG{n}{b2} \PYG{o}{:=}             \PYG{c+c1}{\PYGZhy{}\PYGZhy{} ((∅))}
\PYG{n}{mk\PYGZus{}nonempty}
  \PYG{n}{lparen.mk}
  \PYG{n}{b1}
  \PYG{n}{rparen.mk}

\PYG{k+kd}{def} \PYG{n}{b3} \PYG{o}{:=}
\PYG{n}{mk\PYGZus{}nonempty}
  \PYG{n}{lparen.mk}
  \PYG{o}{(}
    \PYG{n}{mk\PYGZus{}nonempty}
      \PYG{n}{lparen.mk}
      \PYG{o}{(}
        \PYG{n}{mk\PYGZus{}nonempty}
          \PYG{n}{lparen.mk}
          \PYG{n}{mk\PYGZus{}empty}
          \PYG{n}{rparen.mk}
      \PYG{o}{)}
      \PYG{n}{rparen.mk}
  \PYG{o}{)}
  \PYG{n}{rparen.mk}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can confirm that the type of b1 is bal using the
\sphinxstyleemphasis{check} command in Lean. The output of this  command is
visible if you hover your cursor over the blue underline
(in VSCode), and in your Lean infoview. You can open and
close the infoview window in VSCode by CMD/CTRL\sphinxhyphen{}SHIFT\sphinxhyphen{}ENTER.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{b1}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can now use the \sphinxstyleemphasis{reduce} command in Lean to see that \sphinxstyleemphasis{b1} is
bound to the term, \sphinxstyleemphasis{mk\_nonempty lparen.mk mk\_empty rparen.mk}. If
you do the same for \sphinxstyleemphasis{b2} you will see its unfolded value, and the
same goes for b3. Be sure to relate the results you get here back
to the definitions of \sphinxstyleemphasis{b1, b2,} and \sphinxstyleemphasis{b3} above.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{b1}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{b2}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{b3}
\end{sphinxVerbatim}

\sphinxAtStartPar
From here we can build larger and larger strings in \sphinxstyleemphasis{bal}.


\subsection{Inductive Datatype Definitions}
\label{\detokenize{A_01_Propositional_Logic:inductive-datatype-definitions}}
\sphinxAtStartPar
There are three crucial properties of constructors of inductive
data types in Lean that you should now understand. First, they
are \sphinxstyleemphasis{disjoint}. Different constructors \sphinxstyleemphasis{never} produce the same
value. Second, they are \sphinxstyleemphasis{injective}. A constructor applied to
different argument values will always produce different terms.
Finally, they are complete. The langauge they define contains
\sphinxstyleemphasis{all} of the strings constructible by any finite number of
applications of the defined constructors \sphinxstyleemphasis{and no other terms}.
For example, our \sphinxstyleemphasis{bal} language doesn’t contain any \sphinxstyleemphasis{error} or
any other terms not constructible by the given constructors.


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:semantics}}
\sphinxAtStartPar
The semantics of a formal language defines an association
between some or all of the terms of a language and what each
such term means, in some \sphinxstyleemphasis{semantic domain}. For example, we
can associate each string in \sphinxstyleemphasis{bal} with the natural number
that describes its nesting depth.

\sphinxAtStartPar
In this case, there is total function from terms of type
\sphinxstyleemphasis{bal} to \sphinxstyleemphasis{ℕ}, so we can specify the semantics as a function
in Lean. (All functions in Lean represent total functions in
mathematics.)

\sphinxAtStartPar
Here is such a function defined using one of several notations
available in Lean. We define the function, \sphinxstyleemphasis{sem} as taking a
value of type \sphinxstyleemphasis{bal} as an argument and returning a value of
type nat (ℕ, natural number, i.e., non\sphinxhyphen{}negative integer) as
a result.

\sphinxAtStartPar
The function is defined by case analysis on the argument. If
it is the empty string, mk\_empty, the function returns 0.
Otherwise (the only remaining possibility) is that the value
to which \sphinxstyleemphasis{sem} is applied is of the form (mk\_nonempty l b r)
where \sphinxstyleemphasis{l} and \sphinxstyleemphasis{r} are values representing left and right
parenthesis, and where \sphinxstyleemphasis{b} is some smaller string/value of
type \sphinxstyleemphasis{bal}. In this case, the nesting depth of the argument
is one more than the nesting depth of \sphinxstyleemphasis{b}, which we compute
by applying \sphinxstyleemphasis{bal} recursively to \sphinxstyleemphasis{b}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{sem} \PYG{o}{:} \PYG{n}{bal} \PYG{n+nb+bp}{→} \PYG{n}{ℕ}
\PYG{n+nb+bp}{|} \PYG{n}{mk\PYGZus{}empty} \PYG{o}{:=} \PYG{l+m+mi}{0}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{mk\PYGZus{}nonempty} \PYG{n}{l} \PYG{n}{b} \PYG{n}{r}\PYG{o}{)} \PYG{o}{:=} \PYG{l+m+mi}{1} \PYG{n+nb+bp}{+} \PYG{n}{sem} \PYG{n}{b}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} We can now run some tests to see that it works}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{sem} \PYG{n}{b0}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{sem} \PYG{n}{b1}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{sem} \PYG{n}{b2}
\end{sphinxVerbatim}

\sphinxAtStartPar
So there you have it. We’ve defined both a formal language
and a semantics of this language using the logic of the Lean
proof assistant. We defined an inductive data type the \sphinxstyleemphasis{terms}
(values) of which represent all and only the strings in \sphinxstyleemphasis{bal}.
We defined a total function that maps any term of this type to
its corresponding length expressed as a natural number, which
we take to be the \sphinxstyleemphasis{semantic meaning} of that string.

\sphinxAtStartPar
We now have all the machinery we need to formally define the
syntax and semantics of more interesting and useful languages.
We will now turn to the language of propositional logic as our
next major example.


\section{Simplified Propositional Logic}
\label{\detokenize{A_01_Propositional_Logic:simplified-propositional-logic}}
\sphinxAtStartPar
Our next step toward formalizing abstract mathematics for software
engineering, we will specify the syntax and semantics of a simple
but important mathatical language, namely \sphinxstyleemphasis{propositional logic}.

\sphinxAtStartPar
Propositional logic is isomorphic to (essentially the same thing
as) Boolean algebra. You already know about Boolean algebra from
writing conditions in if and loop commands in everyday programming
languages such as Java.

\sphinxAtStartPar
Our first task will be to see how to formalize the syntax and
semantics of this language in Lean.


\subsection{Syntax}
\label{\detokenize{A_01_Propositional_Logic:syntax}}
\sphinxAtStartPar
The set of expressions (strings) comprising the formal
language of propositional logic is defined inductively.
That is, some smallest expressions are first defined,
with larger expressions then defined as being constructed,
at least in part, from smaller ones \sphinxstyleemphasis{of the same type}.

\sphinxAtStartPar
The syntax of propositional logic comprises
\begin{itemize}
\item {} 
\sphinxAtStartPar
variables, e.g., x, y, y, theSkyIsBlue, etc

\item {} 
\sphinxAtStartPar
a language of propositional expressions (propositions)
* constant expressions, \sphinxstyleemphasis{true} and \sphinxstyleemphasis{false}
* variable expressions, such as X, Y, Z, TheSkyIsBlue, each such expression having an associated variable
* operator expressions, such as ¬X, X ∧ Y, and X ∨ Y

\end{itemize}

\sphinxAtStartPar
You can think of these operators as taking expressions
as their arguments and returning longer expressions as
their results.

\sphinxAtStartPar
To begin, we define a datatype the values of which will
represent our the variables. We’ll name the type \sphinxstyleemphasis{prop\_var,}
for propositional variable. For now we’ll assume we’re
restricted to using at most three variables.  We’ll call
them \sphinxstyleemphasis{x, y,} and \sphinxstyleemphasis{z} and will just list them as being the
distinct constant values of the \sphinxstyleemphasis{prop\_var} type.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}var} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{x}
\PYG{n+nb+bp}{|} \PYG{n}{y}
\PYG{n+nb+bp}{|} \PYG{n}{z}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}var}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we’ll define the set of expressions in our language,
which we’ll call \sphinxstyleemphasis{prop\_expr}, the language of expressions
in propositional logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}expr}
\PYG{n+nb+bp}{|} \PYG{n}{var\PYGZus{}expr} \PYG{o}{(}\PYG{n}{v} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{and\PYGZus{}expr} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{or\PYGZus{}expr} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}expr}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can now form both variable and operator
expressions! Let’s start with some variable
expressions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{X} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{var\PYGZus{}expr} \PYG{n}{x}
\PYG{k+kd}{def} \PYG{n}{Y} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{var\PYGZus{}expr} \PYG{n}{y}
\PYG{k+kd}{def} \PYG{n}{Z} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{var\PYGZus{}expr} \PYG{n}{z}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can also define operator expressions, which
build larger expressions out of smaller ones.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{XandY} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{and\PYGZus{}expr} \PYG{n}{X} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{XandY\PYGZus{}and\PYGZus{}Z} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:=} \PYG{n}{and\PYGZus{}expr} \PYG{n}{XandY} \PYG{n}{Z}
\end{sphinxVerbatim}


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:id1}}
\sphinxAtStartPar
The semantics of propositional logic assigns a Boolean
truth value to each expression in the language, but to
do this, an additional piece of data is required: one
that defines the Boolean meaning (truth value) of each
\sphinxstyleemphasis{variable} referenced by any variable expression.

\sphinxAtStartPar
What for example is the meaning of the variable expression,
\sphinxstyleemphasis{X}? It’s impossible to say unless you know the meaning of
the variable, \sphinxstyleemphasis{x}. If the meaning of \sphinxstyleemphasis{x} is true, then we
define the meaning of \sphinxstyleemphasis{X} to be true, and likewise for the
value, false.

\sphinxAtStartPar
We will use the word \sphinxstyleemphasis{interpretation} to refer to any
assignment of Boolean truth values to all variables that
can be referenced by any given variable expression. For
example, we might define \sphinxstyleemphasis{x}, \sphinxstyleemphasis{y}, and \sphinxstyleemphasis{z} all to have
true as their meanings.  We can formalize this mapping
from variables to truth values as a total function from
terms of type \sphinxstyleemphasis{prop\_var} to terms of type \sphinxstyleemphasis{bool} in Lean.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{all\PYGZus{}true} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{tt}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} for any argument return true (tt in Lean)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Similarly here’s an interpretation under which all variables
are assigned the value, false.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{all\PYGZus{}false} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{ff}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} for any argument return true (tt in Lean)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now here’s an interpretation under which x is assigned true,
and the remaining variables (y and z) are assigned false.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{mixed} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{prop\PYGZus{}var.x} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{ff}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{mixed} \PYG{n}{z}

\PYG{k+kd}{def} \PYG{n}{another\PYGZus{}interpretation} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{x} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{y} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{z} \PYG{o}{:=} \PYG{n}{tt}
\end{sphinxVerbatim}

\sphinxAtStartPar
Given one of these interpretations as additional data, we
can now assign truth value semantic meanings to expressions
such as XandY (and\_expr X Y). We do this recursively. First
we evaluate X to get its truth value (by applying a given
interpretation function to the variable, x, that expression
X “contains”.

\sphinxAtStartPar
Recall that X is defined to be the term, var\_expr x. We just
need to \sphinxstyleemphasis{destructure} this term to get the \sphinxstyleemphasis{x} part of it.
Remember that constructors simply package up their arguments
into terms in which those arguments appear in order. Once we
get at the variable, \sphinxstyleemphasis{x}, we just apply an interpretation
function to it to get its corresponding Boolean value, and
we take that as the meaning of the variable expression, \sphinxstyleemphasis{X}.

\sphinxAtStartPar
Ok, so what about the meaning of \sphinxstyleemphasis{(and\_expr X Y)}? First we
need to know the meanings of \sphinxstyleemphasis{X} and \sphinxstyleemphasis{Y}. Suppose they are
true and false, respectively. Then we define the meaning of
\sphinxstyleemphasis{(and\_expr X Y)} as the Boolean \sphinxstyleemphasis{conjunction} of these truth
values. In this case, that’d be \sphinxstyleemphasis{tt \&\& ff,} which is \sphinxstyleemphasis{ff}.

\sphinxAtStartPar
Here then is a semantic evaluation function that implements
these two notions: one in the case where the expression to
be given a meaning is a variable expression, and one where
it’s an \sphinxstyleemphasis{and} expression.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{prop\PYGZus{}eval} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{var\PYGZus{}expr} \PYG{n}{v}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{i} \PYG{n}{v}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{and\PYGZus{}expr} \PYG{n}{e1} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{band} \PYG{o}{(}\PYG{n}{prop\PYGZus{}eval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{prop\PYGZus{}eval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{or\PYGZus{}expr} \PYG{n}{e1} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{bor} \PYG{o}{(}\PYG{n}{prop\PYGZus{}eval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{prop\PYGZus{}eval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we can find the meaning of \sphinxstyleemphasis{any} expression in our
initial subset of the language of propositional logic.
To be more precise, we’d say that we’ve specified an
\sphinxstyleemphasis{abstract syntax} for our language. In our next unit,
we’ll see how to use Lean’s syntax extension capabilities
to define a corresponding \sphinxstyleemphasis{concrete} syntax, one that’ll
let us write expressions in our language as if we were
using paper and pencil methods and standard syntax for
propositional logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{all\PYGZus{}true}


\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{X} \PYG{n}{all\PYGZus{}true}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{Y} \PYG{n}{all\PYGZus{}true}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{Z} \PYG{n}{all\PYGZus{}true}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{X} \PYG{n}{all\PYGZus{}false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{Y} \PYG{n}{all\PYGZus{}false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{Z} \PYG{n}{all\PYGZus{}false}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{XandY} \PYG{n}{all\PYGZus{}true}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{XandY} \PYG{n}{all\PYGZus{}false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{n}{XandY} \PYG{n}{mixed}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{prop\PYGZus{}eval} \PYG{o}{(}\PYG{n}{and\PYGZus{}expr} \PYG{o}{(}\PYG{n}{and\PYGZus{}expr} \PYG{n}{X} \PYG{n}{Y}\PYG{o}{)} \PYG{o}{(}\PYG{n}{or\PYGZus{}expr} \PYG{n}{X} \PYG{n}{Z}\PYG{o}{)}\PYG{o}{)} \PYG{n}{mixed}
\end{sphinxVerbatim}

\sphinxAtStartPar
So we now have is a specification of the syntax and
semantics of a subset of propositional logic. As an
in\sphinxhyphen{}class exercise, let’s add some new logical operators:
for not, or, implies, bi\sphinxhyphen{}implication, and exclusive or.


\section{Propositional Logic}
\label{\detokenize{A_01_Propositional_Logic:id2}}
\sphinxAtStartPar
In this chapter, we’ll present a first
version of a syntax and semantic specification
for a full language of propositional logic. As
in the last chapter, we start by defining the
syntax, then we present the semantics.


\subsection{Syntax}
\label{\detokenize{A_01_Propositional_Logic:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{P}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{o}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{o}\PYG{c+cm}{g}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{u}\PYG{c+cm}{p}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{a}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{.}
\PYG{c+cm}{W}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{a}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{m}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{.}\PYG{c+cm}{m}\PYG{c+cm}{k}
\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{n}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{s}
\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{m}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{*}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{*}
\PYG{c+cm}{b}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}var} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{mk} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Abstract syntax}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{pTrue} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}
\PYG{n+nb+bp}{|} \PYG{n}{pFalse} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}
\PYG{n+nb+bp}{|} \PYG{n}{pVar} \PYG{o}{(}\PYG{n}{v}\PYG{o}{:} \PYG{n}{prop\PYGZus{}var}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pNot} \PYG{o}{(}\PYG{n}{e} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pAnd} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pOr} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pImp} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pIff} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{pXor} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}expr}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can now \sphinxstyleemphasis{overload} some predefined operators in Lean
having appropriate associativity and precedence properties
to obtain a nice \sphinxstyleemphasis{concrete syntax} for our language. See also
(\sphinxurl{https://github.com/leanprover/lean/blob/master/library/init/core.lean})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{var\PYGZus{}mk}\PYG{o}{)} \PYG{n+nb+bp}{`}\PYG{o}{[}\PYG{n+nb+bp}{`} \PYG{n}{v} \PYG{n+nb+bp}{`}\PYG{o}{]}\PYG{n+nb+bp}{`} \PYG{o}{:=}  \PYG{n}{pVar} \PYG{n}{v}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pAnd}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{∧} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pAnd} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pOr}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{∨} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pOr} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pNot}\PYG{o}{)} \PYG{n+nb+bp}{¬}\PYG{n}{e} \PYG{o}{:=} \PYG{n}{pNot} \PYG{n}{e}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pImp}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pImp} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pIff}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pIff} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pXor}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{⊕} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pXor} \PYG{n}{e1} \PYG{n}{e2}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, after giving nice names, X, Y, and Z, to
the first three variables, we givesome examples of
propositional logic expressions written using our
new \sphinxstyleemphasis{concrete} syntax.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{X} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Y} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Z} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{2}\PYG{o}{]}

\PYG{k+kd}{def} \PYG{n}{e1} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e3} \PYG{o}{:=} \PYG{n+nb+bp}{¬} \PYG{n}{Z}
\PYG{k+kd}{def} \PYG{n}{e4} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} avoid overloading →}
\PYG{k+kd}{def} \PYG{n}{e5} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e1}
\PYG{k+kd}{def} \PYG{n}{e6} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{⊕} \PYG{n+nb+bp}{¬}\PYG{n}{X}
\end{sphinxVerbatim}


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Helper functions}
\PYG{k+kd}{def} \PYG{n}{bimp} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}

\PYG{k+kd}{def} \PYG{n}{biff} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Operational semantics}
\PYG{k+kd}{def} \PYG{n}{pEval} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{pTrue} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{pFalse} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{o}{[}\PYG{n}{v}\PYG{o}{]}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{i} \PYG{n}{v}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n+nb+bp}{¬} \PYG{n}{e}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{bnot} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{∧} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{\PYGZam{}}\PYG{n+nb+bp}{\PYGZam{}} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{∨} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{|}\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{bimp} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{biff} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{⊕} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{n}{xor} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
I’ll fill in explanatory text later, but for now wanted
to get you the \sphinxstyleemphasis{code}.


\section{A Better Specification}
\label{\detokenize{A_01_Propositional_Logic:a-better-specification}}
\sphinxAtStartPar
In this chapter we present an improved specification
of the syntax and semantics of propositional logic. As
usual, we first present the syntax specification then the
semantics.


\subsection{Syntax}
\label{\detokenize{A_01_Propositional_Logic:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variables, still indexed by natural numbers}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}var} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{mk} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} examples}
\PYG{k+kd}{def} \PYG{n}{v₀} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}
\PYG{k+kd}{def} \PYG{n}{v₁} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}
\PYG{k+kd}{def} \PYG{n}{v₂} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will now refactor our definition of
prop\_expr to factor out mostly repeated code
and to make explicit (1) a class of \sphinxstyleemphasis{literal}
expressions, and (2) binary operators as first
class citizens and a class of corresponding
binary operator expressions. Be sure to compare
and contrast our definitions here with the ones in
the last chapter.

\sphinxAtStartPar
We’ll start by defining a \sphinxstyleemphasis{binary operator} type
whose values are abstract syntax terms for binary
operators/connectives in propositional logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Syntactic terms for binary operators}
\PYG{k+kd}{inductive} \PYG{n}{binop}
\PYG{n+nb+bp}{|} \PYG{n}{opAnd}
\PYG{n+nb+bp}{|} \PYG{n}{opOr}
\PYG{n+nb+bp}{|} \PYG{n}{opImp}
\PYG{n+nb+bp}{|} \PYG{n}{opIff}
\PYG{n+nb+bp}{|} \PYG{n}{opXor}

\PYG{k+kn}{open} \PYG{n}{binop}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A much improved language syntax spec}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{pLit} \PYG{o}{(}\PYG{n}{b} \PYG{o}{:} \PYG{n}{bool}\PYG{o}{)}                         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} literal expressions}
\PYG{n+nb+bp}{|} \PYG{n}{pVar} \PYG{o}{(}\PYG{n}{v}\PYG{o}{:} \PYG{n}{prop\PYGZus{}var}\PYG{o}{)}                      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expressions}
\PYG{n+nb+bp}{|} \PYG{n}{pNot} \PYG{o}{(}\PYG{n}{e} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}                    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} unary operator expression}
\PYG{n+nb+bp}{|} \PYG{n}{pBinOp} \PYG{o}{(}\PYG{n}{op} \PYG{o}{:} \PYG{n}{binop}\PYG{o}{)} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} binary operator expressions}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}expr}


\PYG{c+c1}{\PYGZhy{}\PYGZhy{} An example of an \PYGZdq{}and\PYGZdq{} expression}
\PYG{k+kd}{def} \PYG{n}{an\PYGZus{}and\PYGZus{}expr} \PYG{o}{:=}
  \PYG{n}{pBinOp}
    \PYG{n}{opAnd}                   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} binary operator}
    \PYG{o}{(}\PYG{n}{pVar} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}\PYG{o}{)}\PYG{o}{)}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expression}
    \PYG{o}{(}\PYG{n}{pVar} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}\PYG{o}{)}\PYG{o}{)}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expression}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have to update the previous notations definitions,
which now need to \sphinxstyleemphasis{desugar} to use the new expression
constructors. We also define some shorthands for the
two literal expressions in our language.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{True} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{tt}
\PYG{k+kd}{def} \PYG{n}{False} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{ff}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pVar}\PYG{o}{)} \PYG{n+nb+bp}{`}\PYG{o}{[}\PYG{n+nb+bp}{`} \PYG{n}{v} \PYG{n+nb+bp}{`}\PYG{o}{]}\PYG{n+nb+bp}{`} \PYG{o}{:=}  \PYG{n}{pVar} \PYG{n}{v}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pAnd}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{∧} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pBinOp} \PYG{n}{opAnd} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pOr}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{∨} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pBinOp} \PYG{n}{opOr} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pNot}\PYG{o}{)} \PYG{n+nb+bp}{¬}\PYG{n}{e} \PYG{o}{:=} \PYG{n}{pNot} \PYG{n}{e}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pImp}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opImp} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pIff}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opIff} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pXor}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{⊕} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opXor} \PYG{n}{e1} \PYG{n}{e2}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Precedence highest to lowest NOT, NAND, NOR, AND, OR, \PYGZhy{}\PYGZgt{}, ==}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} `↓`:37 x:37}
\PYG{k+kd}{reserve} \PYG{k+kd}{notation} \PYG{n+nb+bp}{`}\PYG{n+nb+bp}{↓}\PYG{n+nb+bp}{`}\PYG{o}{:}\PYG{l+m+mi}{37} \PYG{n}{x}\PYG{o}{:}\PYG{l+m+mi}{37}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pNor}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`}\PYG{n+nb+bp}{↓}\PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opAnd} \PYG{n}{e1} \PYG{n}{e2}

\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{¬}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{∧}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{↑}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{↓}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here are examples of expressions using our concrete syntax

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expressions from variables}
\PYG{k+kd}{def} \PYG{n}{X} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₀}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Y} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₁}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Z} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₂}\PYG{o}{]}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} operator expressions}
\PYG{k+kd}{def} \PYG{n}{e1} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e3} \PYG{o}{:=} \PYG{n+nb+bp}{¬}\PYG{n}{Z}
\PYG{k+kd}{def} \PYG{n}{e4} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2}
\PYG{k+kd}{def} \PYG{n}{e5} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e1}
\PYG{k+kd}{def} \PYG{n}{e6} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{⊕} \PYG{n+nb+bp}{¬}\PYG{n}{X}
\end{sphinxVerbatim}


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:id6}}
\sphinxAtStartPar
A benefit of having made binary operators
explicit as a set of syntactic terms is that
we can simultaneously simplify and generalize
our semantics.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Helper functions}
\PYG{k+kd}{def} \PYG{n}{bimp} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}

\PYG{k+kd}{def} \PYG{n}{biff} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}
\end{sphinxVerbatim}

\sphinxAtStartPar
We now define an \sphinxstyleemphasis{interpretation} for operator symbols!
Each binop (a syntactic object) has as its meaning some
corresponding binary Boolean operator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{op\PYGZus{}sem} \PYG{o}{:} \PYG{n}{binop} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{opAnd} \PYG{o}{:=} \PYG{n}{band}
\PYG{n+nb+bp}{|} \PYG{n}{opOr}  \PYG{o}{:=} \PYG{n}{bor}
\PYG{n+nb+bp}{|} \PYG{n}{opImp} \PYG{o}{:=} \PYG{n}{bimp}
\PYG{n+nb+bp}{|} \PYG{n}{opIff} \PYG{o}{:=} \PYG{n}{biff}
\PYG{n+nb+bp}{|} \PYG{n}{opXor} \PYG{o}{:=} \PYG{n}{bxor}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A quick demo}
\PYG{k}{\PYGZsh{}reduce} \PYG{o}{(}\PYG{o}{(}\PYG{n}{op\PYGZus{}sem} \PYG{n}{opAnd}\PYG{o}{)} \PYG{n}{tt} \PYG{n}{ff}\PYG{o}{)}
\PYG{k}{\PYGZsh{}reduce} \PYG{o}{(}\PYG{n}{op\PYGZus{}sem} \PYG{n}{opOr} \PYG{n}{tt} \PYG{n}{ff}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} recall left associativity}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now here’s a much improved semantic specification.
In place of rules for pTrue and pFalse we just have
one rule for pLit (literal expressions). Second, in
place of one rule for each binary operator we have
one rule for \sphinxstyleemphasis{any} binary operator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{pEval} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pLit} \PYG{n}{b}\PYG{o}{)}          \PYG{n}{i} \PYG{o}{:=} \PYG{n}{b}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{o}{[}\PYG{n}{v}\PYG{o}{]}\PYG{o}{)}             \PYG{n}{i} \PYG{o}{:=} \PYG{n}{i} \PYG{n}{v}                  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} our [] notation on the left}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n+nb+bp}{¬}\PYG{n}{e}\PYG{o}{)}              \PYG{n}{i} \PYG{o}{:=} \PYG{n}{bnot} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} our ¬ notation; Lean\PYGZsq{}s bnot}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pBinOp} \PYG{n}{op} \PYG{n}{e1} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{\PYGZam{}}\PYG{n+nb+bp}{\PYGZam{}} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} BUG!}
\end{sphinxVerbatim}


\subsection{Exploration}
\label{\detokenize{A_01_Propositional_Logic:exploration}}
\sphinxAtStartPar
You’ve heard about Lean and seen in it action, but there’s no substitute for
getting into it yourself. The goal of this exploration is for you to “connect
all the dots” in what we’ve developed so far, and for you to start to develop
“muscle memory” for some basic Lean programming.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Identify and fix the bug in the last rule of pEval

\item {} 
\sphinxAtStartPar
Replace pNot with pUnOp (“unary operator”), as with pBinOp

\item {} 
\sphinxAtStartPar
Add end\sphinxhyphen{}to\sphinxhyphen{}end support for logical \sphinxstyleemphasis{nand} (↑) and \sphinxstyleemphasis{nor} (↓) expression\sphinxhyphen{}building operators

\item {} 
\sphinxAtStartPar
Define some examples of propositional logic expressions using concrete syntax

\item {} 
\sphinxAtStartPar
Define several interpretations and evaluate each of your expressions under each one

\end{itemize}

\sphinxAtStartPar
To avoid future git conflicts, make a copy of src/04\_prop\_logic\_syn\_sem.lean, and
make changes to that file rather than to the original. Bring your completed work
to our next class. Be prepared to share and/or turn in your work at the beginning
of next class.


\section{Formal Validation}
\label{\detokenize{A_01_Propositional_Logic:formal-validation}}
\sphinxAtStartPar
So far we’ve defined (1) an abstract syntax for propositional
logic, (2) a “big step” operational semantics for our syntax,
and (3) a concrete syntax for it, in the form of prefix (¬) and
infix (∧, ∨, =>, etc) operators.

\sphinxAtStartPar
But how do we know that our \sphinxstyleemphasis{specification} is correct? Checking
a specification for correctness is called \sphinxstyleemphasis{validating} it, or just
validation. \sphinxstyleemphasis{Formal} validation is the use of mathematical logic
to validate given specifications.

\sphinxAtStartPar
In particular, one can formally validate a specification by
proving that it has certain required properties. To illustrate
the point, n this chapter we add a fourth section,(4): a formal
proof of the proposition that in our syntax and semantics, ∧ is
commutative; that for \sphinxstyleemphasis{any} expressions in propositional logic,
e1 and e2, and for \sphinxstyleemphasis{any} interpretation, the values of e1 ∧ e2
under i, and of e2 ∧ e1 under i, are equal.

\sphinxAtStartPar
Another way to look at this chapter is that it extends the set of
elements of a good formalization of a mathematical concept from
three above to four. Now the modular unit of definition specifies
(1) the data (sometimes language syntax, sometimes not), (2) the
operations on that data, (3) the available concrete notations,
and now also (4) proofs that essential properties hold.
Abstract Syntax
—————

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{namespace} \PYG{n}{cs6501}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variables, indexed by natural numbers}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}var} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{mk} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Abstract syntactic terms for unary operators}
\PYG{k+kd}{inductive} \PYG{n}{unop}
\PYG{n+nb+bp}{|} \PYG{n}{opNot}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Abstract syntactic terms for binary operators}
\PYG{k+kd}{inductive} \PYG{n}{binop}
\PYG{n+nb+bp}{|} \PYG{n}{opAnd}
\PYG{n+nb+bp}{|} \PYG{n}{opOr}
\PYG{n+nb+bp}{|} \PYG{n}{opImp}
\PYG{n+nb+bp}{|} \PYG{n}{opIff}
\PYG{n+nb+bp}{|} \PYG{n}{opXor}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} make constructor names globally visible}
\PYG{k+kn}{open} \PYG{n}{unop}
\PYG{k+kn}{open} \PYG{n}{binop}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} syntax}
\PYG{k+kd}{inductive} \PYG{n}{prop\PYGZus{}expr} \PYG{o}{:} \PYG{k+kt}{Type}
\PYG{n+nb+bp}{|} \PYG{n}{pLit} \PYG{o}{(}\PYG{n}{b} \PYG{o}{:} \PYG{n}{bool}\PYG{o}{)}                         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} literal expressions}
\PYG{n+nb+bp}{|} \PYG{n}{pVar} \PYG{o}{(}\PYG{n}{v}\PYG{o}{:} \PYG{n}{prop\PYGZus{}var}\PYG{o}{)}                      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expressions}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} | pNot (e : prop\PYGZus{}expr)                    \PYGZhy{}\PYGZhy{} unary operator expression}
\PYG{n+nb+bp}{|} \PYG{n}{pUnOp} \PYG{o}{(}\PYG{n}{op} \PYG{o}{:}\PYG{n}{unop}\PYG{o}{)} \PYG{o}{(}\PYG{n}{e} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}                    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} unary operator expression}
\PYG{n+nb+bp}{|} \PYG{n}{pBinOp} \PYG{o}{(}\PYG{n}{op} \PYG{o}{:} \PYG{n}{binop}\PYG{o}{)} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} binary operator expressions}

\PYG{k+kn}{open} \PYG{n}{prop\PYGZus{}expr}
\end{sphinxVerbatim}


\subsection{Concrete Syntax / Notation}
\label{\detokenize{A_01_Propositional_Logic:concrete-syntax-notation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} notations (concrete syntax)}
\PYG{k+kd}{notation} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⊤} \PYG{n+nb+bp}{`} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{tt}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Notation for True}
\PYG{k+kd}{notation} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⊥} \PYG{n+nb+bp}{`} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{ff}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Notation for False}
\PYG{k+kd}{def} \PYG{n}{True} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{tt}         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} deprecated now}
\PYG{k+kd}{def} \PYG{n}{False} \PYG{o}{:=} \PYG{n}{pLit} \PYG{n}{ff}        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} deprecated now}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pVar}\PYG{o}{)} \PYG{n+nb+bp}{`} \PYG{o}{[} \PYG{n+nb+bp}{`} \PYG{n}{v}  \PYG{n+nb+bp}{`} \PYG{o}{]} \PYG{n+nb+bp}{`} \PYG{o}{:=}  \PYG{n}{pVar} \PYG{n}{v}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pNot}\PYG{o}{)} \PYG{n+nb+bp}{¬}\PYG{n}{e} \PYG{o}{:=} \PYG{n}{pUnOp} \PYG{n}{opNot} \PYG{n}{e}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pAnd}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pBinOp} \PYG{n}{opAnd} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pOr}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=}  \PYG{n}{pBinOp} \PYG{n}{opOr} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{precedence} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n+nb+bp}{`}\PYG{o}{:} \PYG{l+m+mi}{23}                                        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} add operator precedence}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pImp}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n+nb+bp}{`}  \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opImp} \PYG{n}{e1} \PYG{n}{e2}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} bug fixed; add back quotes}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pIff}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{↔} \PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opIff} \PYG{n}{e1} \PYG{n}{e2}
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pXor}\PYG{o}{)} \PYG{n}{e1} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⊕} \PYG{n+nb+bp}{`} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{pBinOp} \PYG{n}{opXor} \PYG{n}{e1} \PYG{n}{e2}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Let\PYGZsq{}s not bother with notations for nand and nor at this point}
\end{sphinxVerbatim}


\subsection{Semantics}
\label{\detokenize{A_01_Propositional_Logic:id7}}
\sphinxAtStartPar
The \sphinxstyleemphasis{semantic domain} for our language is not only the
Boolean values, but also the Boolean operations. We map
variables to Boolean values (via an interpretation) and
we define a fixed mapping of logical connectives (¬, ∧,
∨, etc.) to Boolean operations (bnot, band, bor, etc.)
With these elementary semantic mappings in place we can
finally map \sphinxstyleemphasis{any} propositional logical expression to
its (Boolean) meaning in a \sphinxstyleemphasis{compositional} manner, where
the meaning of any compound expression is composed from
the meanings of its parts, which we compute recursively,
down to individual variables and connectives.

\sphinxAtStartPar
The Lean standard libraries define some but not all
binary Boolean operations. We will thus start off in
this section by augmenting Lean’s definitions of the
Boolean operations with two more: for implication (we
follow Lean naming conventions and call this bimp) and
bi\sphinxhyphen{}implication (biff).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Boolean implication operation (buggy!)}
\PYG{k+kd}{def} \PYG{n}{bimp} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A fault to inject first time through}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Now corrected in following to lines}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} | tt ff := tt}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} | ff tt := ff}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Boolean biimplication operation}
\PYG{k+kd}{def} \PYG{n}{biff} \PYG{o}{:} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{tt}
\PYG{n+nb+bp}{|} \PYG{n}{tt} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{tt} \PYG{o}{:=} \PYG{n}{ff}
\PYG{n+nb+bp}{|} \PYG{n}{ff} \PYG{n}{ff} \PYG{o}{:=} \PYG{n}{tt}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we define a fixed interpretation for our
syntactic logical connectives, first unary and
then binary. We give these mappings in the form
of functions from unary and binary operators
(which act to compose logical expressions into
new expressions), to Boolean operations (which
compose Boolean values into Boolean results).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} interpretations of unary operators}
\PYG{k+kd}{def} \PYG{n}{un\PYGZus{}op\PYGZus{}sem} \PYG{o}{:} \PYG{n}{unop} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{opNot} \PYG{o}{:=} \PYG{n}{bnot}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} interpretations of binary operators}
\PYG{k+kd}{def} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem} \PYG{o}{:} \PYG{n}{binop} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{opAnd} \PYG{o}{:=} \PYG{n}{band}
\PYG{n+nb+bp}{|} \PYG{n}{opOr}  \PYG{o}{:=} \PYG{n}{bor}
\PYG{n+nb+bp}{|} \PYG{n}{opImp} \PYG{o}{:=} \PYG{n}{bimp}
\PYG{n+nb+bp}{|} \PYG{n}{opIff} \PYG{o}{:=} \PYG{n}{biff}
\PYG{n+nb+bp}{|} \PYG{n}{opXor} \PYG{o}{:=} \PYG{n}{bxor}
\end{sphinxVerbatim}

\sphinxAtStartPar
And now here’s our overal expression semantic evaluation
function. It works as described, computing the value of
sub\sphinxhyphen{}expressions and composing the Boolean results into
final Boolean meanings for any given expression under any
give interpretation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} semantic evaluation (meaning of expressions)}
\PYG{k+kd}{def} \PYG{n}{pEval} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pLit} \PYG{n}{b}\PYG{o}{)}          \PYG{n}{i} \PYG{o}{:=} \PYG{n}{b}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{o}{[}\PYG{n}{v}\PYG{o}{]}\PYG{o}{)}             \PYG{n}{i} \PYG{o}{:=} \PYG{n}{i} \PYG{n}{v}                  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} our [] notation on the left}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pUnOp} \PYG{n}{op} \PYG{n}{e}\PYG{o}{)}      \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{un\PYGZus{}op\PYGZus{}sem} \PYG{n}{op}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} our ¬ notation; Lean\PYGZsq{}s bnot}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{pBinOp} \PYG{n}{op} \PYG{n}{e1} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{bin\PYGZus{}op\PYGZus{}sem} \PYG{n}{op}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} BUG FIXED :\PYGZhy{})!}
\end{sphinxVerbatim}


\subsection{Formal Validation}
\label{\detokenize{A_01_Propositional_Logic:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} proof of one key property: \PYGZdq{}commutativity of ∧\PYGZdq{} in the logic we\PYGZsq{}ve specified,, as required}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}commutes} \PYG{o}{:}
  \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
    \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
    \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{∧} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n}{e2} \PYG{n+nb+bp}{∧} \PYG{n}{e1}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} assume that e1 e2 and i are arbitrary}
\PYG{k}{assume} \PYG{n}{e1} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} unfold definition of pEval for given arguments}
\PYG{n}{unfold} \PYG{n}{pEval}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} unfold definition of bin\PYGZus{}op\PYGZus{}sem}
\PYG{n}{unfold} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} case analysis on Boolean value (pEval e1 i)}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} within first case, nested case analysis on (pEval e2 i)}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} goal proved by reflexivity of equality}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} second case for (pEval e2 i) within first case for  (pEval e1 i)}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} onto second case for (pEval e1 i)}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} again nested case analysis on (pEval e2 i)}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} and both cases are again true by reflexivity of equality}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} QED}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Examples}
\label{\detokenize{A_01_Propositional_Logic:examples}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} tell Lean to explain given notations}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{¬}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{∧}
\PYG{k}{\PYGZsh{}print} \PYG{k+kd}{notation} \PYG{n+nb+bp}{↑}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variables}
\PYG{k+kd}{def} \PYG{n}{v₀} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}
\PYG{k+kd}{def} \PYG{n}{v₁} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}
\PYG{k+kd}{def} \PYG{n}{v₂} \PYG{o}{:=} \PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} variable expressions}
\PYG{k+kd}{def} \PYG{n}{X} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₀}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Y} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₁}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{Z} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{v₂}\PYG{o}{]}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} operator expressions}
\PYG{k+kd}{def} \PYG{n}{e1} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e2} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}
\PYG{k+kd}{def} \PYG{n}{e3} \PYG{o}{:=} \PYG{n+nb+bp}{¬}\PYG{n}{Z}
\PYG{k+kd}{def} \PYG{n}{e4} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{e2}
\PYG{k+kd}{def} \PYG{n}{e5} \PYG{o}{:=} \PYG{n}{e1} \PYG{n+nb+bp}{↔} \PYG{n}{e1}
\PYG{k+kd}{def} \PYG{n}{e6} \PYG{o}{:=} \PYG{n}{X} \PYG{n+nb+bp}{⊕} \PYG{n+nb+bp}{¬}\PYG{n}{X}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} an interpretation}
\PYG{k+kd}{def} \PYG{n}{an\PYGZus{}interp} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{0}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{tt} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} X}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{1}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{ff} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Y}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{prop\PYGZus{}var.mk} \PYG{l+m+mi}{2}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{tt} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Z}
\PYG{n+nb+bp}{|} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{n}{ff}               \PYG{c+c1}{\PYGZhy{}\PYGZhy{} any other variable}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} evaluation}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pEval} \PYG{n}{X} \PYG{n}{an\PYGZus{}interp}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pEval} \PYG{n}{Y} \PYG{n}{an\PYGZus{}interp}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{an\PYGZus{}interp}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect false}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pEval} \PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{Y}\PYG{o}{)} \PYG{n}{an\PYGZus{}interp}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} oops}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} applying theorem!}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}commutes} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{an\PYGZus{}interp}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} result is a proof that ff = ff}
\end{sphinxVerbatim}


\subsection{Exercises}
\label{\detokenize{A_01_Propositional_Logic:exercises}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Formally state and prove that in our language, or (∨) is commutative (1 minute!)

\item {} 
\sphinxAtStartPar
Formally state and prove that in our language, not (¬) is involutive (a few minutes).
Hints: Put parens around (¬¬e). Open the Lean infoview with CTRL/CMD\sphinxhyphen{}SHIFT\sphinxhyphen{}RETURN/ENTER.
If you get hung up on Lean syntax, ask a friend (or instructor) for help to get unstuck.

\end{enumerate}


\subsection{Solutions}
\label{\detokenize{A_01_Propositional_Logic:solutions}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} The proof that ∨ is commutative is basically identical to that for ∧}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}commutes} \PYG{o}{:}
  \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{e1} \PYG{n}{e2} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
    \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
    \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n}{e1} \PYG{n+nb+bp}{∨} \PYG{n}{e2}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n}{e2} \PYG{n+nb+bp}{∨} \PYG{n}{e1}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Suppose e1 e2 and i are arbitrary expressions and interpretation}
\PYG{k}{assume} \PYG{n}{e1} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} unfold definitions of pEval and bin\PYGZus{}op\PYGZus{}sem applied to their arguments}
\PYG{n}{unfold} \PYG{n}{pEval}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} proof by simple case analysis on possible results of evaluating e1 and e2 under i}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e1} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e2} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} QED: By showing it\PYGZsq{}s true for arbitrary e1/e2/i we\PYGZsq{}ve shown it\PYGZsq{}s true for *all*}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Prove not is involutive}
\PYG{k+kd}{theorem} \PYG{n}{not\PYGZus{}involutive}\PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{e} \PYG{n}{i}\PYG{o}{,} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{o}{(}\PYG{n}{pEval} \PYG{o}{(}\PYG{n+nb+bp}{¬}\PYG{n+nb+bp}{¬}\PYG{n}{e}\PYG{o}{)} \PYG{n}{i}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{e} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{pEval}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{un\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{n}{cases} \PYG{o}{(}\PYG{n}{pEval} \PYG{n}{e} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,}
\PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{apply} \PYG{n}{rfl} \PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{end} \PYG{n}{cs6501}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nb+bp}{.}\PYG{n}{A\PYGZus{}05\PYGZus{}prop\PYGZus{}logic\PYGZus{}properties}
\PYG{k+kn}{namespace} \PYG{n}{cs6501}
\end{sphinxVerbatim}


\section{Algebraic Axioms}
\label{\detokenize{A_01_Propositional_Logic:algebraic-axioms}}
\sphinxAtStartPar
We’ve seen that it’s not enough to prove just a few
theorems about a construction (here our syntax and
semantics for propositional logic). So how will we
confirm \sphinxstyleemphasis{for sure} that our model (implementation)
of propositional logic is completely valid?

\sphinxAtStartPar
We’ll offer two different methods. First, in this
chapter, we’ll prove that our specification satisfies
the \sphinxstyleemphasis{algebraic axioms} of propositional logic. Second,
in the next chapter, we’ll prove that the \sphinxstyleemphasis{inference
rules} of propositional logic are valid in our model.

\sphinxAtStartPar
Along the way we’ll take the opportunity to see more
of what Lean can do for us:
\sphinxhyphen{} Scott/semantic bracket notation for \sphinxstyleemphasis{meaning\sphinxhyphen{}of}
\sphinxhyphen{} declare automatically introduced variables
\sphinxhyphen{} use of implicit arguments to further improve notation
\sphinxhyphen{} universally quantified variables are function arguments
\sphinxhyphen{} “sorry” to bail out of a proof and accept proposition as axiom

\sphinxAtStartPar
To avoid duplication of code from the last chapter,
we’ll import all of the definitions in its Lean file
for use here.


\subsection{Algebraic Axioms}
\label{\detokenize{A_01_Propositional_Logic:id9}}
\sphinxAtStartPar
First, then, we will formalize propositional logic as an
\sphinxstyleemphasis{algebra,} with Boolean\sphinxhyphen{}valued (as opposed to numeric) terms
and operations, and then we will show that our operations and
terms satisfy the axioms of propositional logic. For example,
we will have to show that our specifications of ∧ and ∨ are
both commutative and associative.

\sphinxAtStartPar
These properties are analogous to the usual commutativity,
associativity, distributivity, and other such properties of
the natural numbers and the usual algebra on them. As we go
through the analogous properties for propositional logic,
take note of the common properties of both algebras.

\sphinxAtStartPar
In the rest of this chapter we will formally state and
prove that our Lean model of propositional logic satisfies
all of the axioms/properties required to be a correct model
of the logic:
\begin{itemize}
\item {} 
\sphinxAtStartPar
commutativity

\item {} 
\sphinxAtStartPar
associativity

\item {} 
\sphinxAtStartPar
distributivity

\item {} 
\sphinxAtStartPar
DeMorgan’s laws

\item {} 
\sphinxAtStartPar
double negation elimination

\item {} 
\sphinxAtStartPar
excluded middle

\item {} 
\sphinxAtStartPar
no contradiction

\item {} 
\sphinxAtStartPar
implication

\item {} 
\sphinxAtStartPar
and simplification

\item {} 
\sphinxAtStartPar
or simplification

\end{itemize}


\subsection{Commutativity}
\label{\detokenize{A_01_Propositional_Logic:commutativity}}
\sphinxAtStartPar
The first two axioms that that the and and or operators
(∧, ∨) are commutative. One will often see these rules
written in textbooks and tutorials as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
(p ∧ q) = (q ∧ p)

\item {} 
\sphinxAtStartPar
(p ∨ q) = (q ∨ p)

\end{itemize}

\sphinxAtStartPar
This kind of presentation hides a few assumptions. First,
it assumes p and q are taken to be arbitrary expressions
in propositional logic. Second, it assumes that what is
really being compared here are not the expressions per se
but their semantic meanings. Third it assumes that equality
of meanings hold under all possible interpretations.

\sphinxAtStartPar
To be completely formal in Lean, we need to be explicit
about these matters. We need to define variables, such as
p and q, to be arbitrary expressions. Second, we need to
be clear that the quantities that are equal are not the
propositions themselves but their \sphinxstyleemphasis{meanings} under all
possible interpretations.

\sphinxAtStartPar
We have already seen, in the last chapter, how to do this.
For example, we defined the commutative property of ∧ as
follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:}
\PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{p} \PYG{n}{q} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
  \PYG{n}{pEval} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{pEval} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)} \PYG{n}{i} \PYG{o}{:=}
\PYG{n}{and\PYGZus{}commutes}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} proof from last chapter}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can read this as “for any expressions, p and q, the
meaning of \sphinxstyleemphasis{p ∧ q} is equal to that of \sphinxstyleemphasis{q ∧ p} under all
interpretations.”


\subsubsection{Another Notation}
\label{\detokenize{A_01_Propositional_Logic:another-notation}}
\sphinxAtStartPar
As we’ve seen, mathematical theories are often
augmented with concrete syntactic notations that
make it easier for people to read and write such
mathemantics. We would typically write \sphinxstyleemphasis{3 + 4},
for example, in lieu of \sphinxstyleemphasis{nat.add 3 4}. For that
matter, we write \sphinxstyleemphasis{3} for (succ(succ(succ zero))).
Good notations are important.

\sphinxAtStartPar
One area in our specification that could use an
improvement is where we apply the \sphinxstyleemphasis{pEval} semantic
\sphinxstyleemphasis{meaning\sphinxhyphen{}of} operator to a given expression. The
standard notation for sucg a “meaning\sphinxhyphen{}of” operator
is a pair of \sphinxstyleemphasis{denotation} or \sphinxstyleemphasis{Scott} brackets.

\sphinxAtStartPar
We thus write \sphinxstyleemphasis{⟦ e ⟧} as “the meaning of \sphinxstyleemphasis{e}” and
define this notation to desugar to \sphinxstyleemphasis{pEval e}. We
thus  write \sphinxstyleemphasis{⟦ e ⟧ i} to mean the truth (Boolean)
value of \sphinxstyleemphasis{e} under the interpretation i. Thus, the
expression, \sphinxstyleemphasis{⟦ e ⟧ i}, desugars to  \sphinxstyleemphasis{pEval e i},
which in turn reduces to the Boolean meaning of
\sphinxstyleemphasis{e} under \sphinxstyleemphasis{i}.

\sphinxAtStartPar
With this notation in hand, we’ll be able to write
all of the algebraic axioms of propositional logic
in an easy to read, mathematically fairly standard
style. So let’s go ahead and define this notation,
and then use it to specify the commutative property
of logical ∧ using it.
Here’s the notation definition. When an operation,
such as pEval is represented by tokens on either side
of an argument, we call this an outfix notation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{notation} \PYG{o}{(}\PYG{n}{name} \PYG{o}{:=} \PYG{n}{pEval}\PYG{o}{)} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⟦} \PYG{n+nb+bp}{`} \PYG{n}{p} \PYG{n+nb+bp}{`} \PYG{n+nb+bp}{⟧} \PYG{n+nb+bp}{`}  \PYG{o}{:=}  \PYG{n}{pEval} \PYG{n}{p}
\end{sphinxVerbatim}


\subsubsection{Variable Declarations}
\label{\detokenize{A_01_Propositional_Logic:variable-declarations}}
\sphinxAtStartPar
It’s common when specifying multiple of properties of a
given object or collection of objects to introduce the
same variables at the beginning of each definition. For
example, we started our definition of the commutative
property with \sphinxstyleemphasis{∀ (p q : prop\_expr) (i : prop\_var → bool)}.
Lean allows us to avoid having to do this by declaring
such variables once, in a \sphinxstyleemphasis{section} of a specification,
and then to use them in multiple definitions without
the need for redundant introductions. Let’s see how it
works.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} start a section}
\PYG{k+kn}{section} \PYG{n}{prop\PYGZus{}logic\PYGZus{}axioms}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Let p, q, r, and i be arbitrary expressions and an}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} interpretation}
\PYG{k+kd}{variables} \PYG{o}{(}\PYG{n}{p} \PYG{n}{q} \PYG{n}{r} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we can write expressions with these variables
without explicitly introducing them. As an aside, in
this example, we add prime marks to the names used in
imported chapter to avoid conflicts with names used in
that file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{o}{:=} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{)}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}commutes\PYGZsq{}} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{p}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsubsection{Specialization of Generalizations}
\label{\detokenize{A_01_Propositional_Logic:specialization-of-generalizations}}
\sphinxAtStartPar
Observe: We can \sphinxstyleemphasis{apply} these theorems
to particular objects to specalize the
generalized statement to the particular
objects.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{p} \PYG{n}{q} \PYG{n}{i}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can use notations not only in writing
propositions to be proved but also in our
proof\sphinxhyphen{}building scripts. In addition to doing
that in what follows, we illustrate two new
elements of the Lean proof script (or tactic)
language. First, we can sequentially compose
tactics into larger tactics using semi\sphinxhyphen{}colon.
Second we can use \sphinxstyleemphasis{repeat} to repeated apply a
tactic until it fails to apply. The result
can be a nicely compacted proof script.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} by unfolding definitions and case analysis}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{p} \PYG{n}{q} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{and\PYGZus{}commutes\PYGZsq{}} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{p} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{q} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{n+nb+bp}{;} \PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{apply} \PYG{n}{rfl} \PYG{o}{\PYGZcb{}} \PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Associativity}
\label{\detokenize{A_01_Propositional_Logic:associativity}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}associative\PYGZus{}axiom} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}associative\PYGZus{}axiom} \PYG{o}{:=}   \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Distributivity}
\label{\detokenize{A_01_Propositional_Logic:distributivity}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}dist\PYGZus{}and\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}dist\PYGZus{}or\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{q} \PYG{n+nb+bp}{∨} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{r}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{DeMorgan’s Laws}
\label{\detokenize{A_01_Propositional_Logic:demorgan-s-laws}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{demorgan\PYGZus{}not\PYGZus{}over\PYGZus{}and\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{¬}\PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\PYG{k+kd}{def} \PYG{n}{demorgan\PYGZus{}not\PYGZus{}over\PYGZus{}or\PYGZus{}axiom} \PYG{o}{:=}  \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{¬}\PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Negation}
\label{\detokenize{A_01_Propositional_Logic:negation}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{negation\PYGZus{}elimination\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i}
\end{sphinxVerbatim}


\subsection{Excluded Middle}
\label{\detokenize{A_01_Propositional_Logic:excluded-middle}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{excluded\PYGZus{}middle\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{⊤}\PYG{n+nb+bp}{⟧} \PYG{n}{i}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} or just tt}
\end{sphinxVerbatim}


\subsection{No Contradiction}
\label{\detokenize{A_01_Propositional_Logic:no-contradiction}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{no\PYGZus{}contradiction\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n}{p} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{¬}\PYG{n}{p}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{⊥}\PYG{n+nb+bp}{⟧} \PYG{n}{i}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} or just tt}
\end{sphinxVerbatim}


\subsection{Implication}
\label{\detokenize{A_01_Propositional_Logic:implication}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{implication\PYGZus{}axiom} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{p} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{q}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{¬}\PYG{n}{p} \PYG{n+nb+bp}{∨} \PYG{n}{q}\PYG{n+nb+bp}{⟧} \PYG{n}{i}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} notation issue}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{implication\PYGZus{}axiom} \PYG{n}{p} \PYG{n}{q} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{implication\PYGZus{}axiom} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem} \PYG{n}{un\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{p} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{n+nb+bp}{;} \PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{q} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{n+nb+bp}{;} \PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{apply} \PYG{n}{rfl} \PYG{o}{\PYGZcb{}} \PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
The next two sections give the axioms for simplifying expressions
involving ∧ and ∨.


\subsection{And Simplification}
\label{\detokenize{A_01_Propositional_Logic:and-simplification}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} p ∧ p = p}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} p ∧ T = p}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} p ∧ F = F}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} p ∧ (p ∨ q) = p}
\end{sphinxVerbatim}


\subsection{Or Simplification}
\label{\detokenize{A_01_Propositional_Logic:or-simplification}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} p ∨ p = p}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} p ∨ T = T}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} p ∨ F = p}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} p ∨ (p ∧ q) = p}

\PYG{k+kd}{end} \PYG{n}{prop\PYGZus{}logic\PYGZus{}axioms}
\PYG{k+kd}{end} \PYG{n}{cs6501}
\end{sphinxVerbatim}


\subsection{Homework}
\label{\detokenize{A_01_Propositional_Logic:homework}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Formalize the and/or simplification rules.

\end{enumerate}

\sphinxAtStartPar
2. Use Lean’s \sphinxstyleemphasis{theorem} command to assert,
give, and name proofs that our Lean model
satisfies all of the algebraic axioms of
propositional logic, as formalized above.

\sphinxAtStartPar
Solving this problem is repetitive application
of what we’ve done already in a few examples,
but it’s still worth writing and running these
proofs scripts a few times to get a better feel
for the process.

\sphinxAtStartPar
3. Collaboratively refactor the “code” we’ve
developed into a mathematical library component
with an emphasis on good design.

\sphinxAtStartPar
What does that even mean? Good with respect to
what criteria, deciderata, needs, objectives?
\begin{itemize}
\item {} 
\sphinxAtStartPar
data type definitions

\item {} 
\sphinxAtStartPar
operation definitions

\item {} 
\sphinxAtStartPar
notation definitions

\item {} 
\sphinxAtStartPar
formal validation

\item {} 
\sphinxAtStartPar
some helpful examples

\end{itemize}


\section{Inference Rules}
\label{\detokenize{A_01_Propositional_Logic:inference-rules}}
\sphinxAtStartPar
In this chapter we will present another approach
to validating our model of propositional logic: by
verifying that it satisifies the \sphinxstyleemphasis{inference rules}
of this logic.

\sphinxAtStartPar
An inference rule is basically a function that takes
zero or more arguments, usually including what we call
\sphinxstyleemphasis{truth judgements} or \sphinxstyleemphasis{proofs} of certain propositions,
and that returns truth judgments or proofs of other
propositions, which are said to be \sphinxstyleemphasis{derived} or to be
\sphinxstyleemphasis{deduced} from the arguments.

\sphinxAtStartPar
For example, in both propositional and \sphinxstyleemphasis{first\sphinxhyphen{}order
predicate} logic, we have a rule, \sphinxstyleemphasis{and introduction},
that takes as arguments, or \sphinxstyleemphasis{premises}, truth judgments
for any two arbitrary propositions, \sphinxstyleemphasis{X} and \sphinxstyleemphasis{Y}, and
that returns a truth judgment for \sphinxstyleemphasis{X ∧ Y}.

\sphinxAtStartPar
A truth judgment is a determination that a proposition,
say \sphinxstyleemphasis{X}, is logically true, and can be written (in paper
and pencil logic as) \sphinxstyleemphasis{X : true}. The \sphinxstyleemphasis{and introduction}
rule thus states that \sphinxstyleemphasis{X : True, Y : True ⊢ X ∧ Y : True.}

\sphinxAtStartPar
This is usually shortened to \sphinxstyleemphasis{X, Y ⊢ X ∧ Y} based on the
assumption that everything to the left of the turnstile
is assumed to have already been judged to be true. Such
a rule can be pronounced as follows: in a context in which
you have already judged X and Y to be true you can always
conclude that X ∧ Y is true.

\sphinxAtStartPar
What’s different is that these rules are syntactic and
don’t presume that we have an algorithm for determining
truth. We do for propositional logic, but not predicate
logic. Learning the basic inference rules of the logic
is thus essential for reasoning about the truth of given
propositions expressed in predicate logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nb+bp}{.}\PYG{n}{A\PYGZus{}06\PYGZus{}prop\PYGZus{}logic\PYGZus{}algebraic\PYGZus{}axioms}
\PYG{k+kn}{namespace} \PYG{n}{cs6501}
\end{sphinxVerbatim}


\subsection{Inference Rules}
\label{\detokenize{A_01_Propositional_Logic:id10}}
\sphinxAtStartPar
Key idea: These are rules for reasoning about evidence.
What \sphinxstyleemphasis{evidence} do you need to derive a given conclusion?
These are the “introduction” rules. From a given piece of
evidence (and possibly with additional evidence) what new
forms of evidence can you derive? These are “elimination”
rules of the logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 1. ⊢ ⊤                     \PYGZhy{}\PYGZhy{} true introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 2. ⊥, X ⊢ X                \PYGZhy{}\PYGZhy{} false elimination}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 3. X, Y ⊢ X ∧ Y            \PYGZhy{}\PYGZhy{} and\PYGZus{}introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 4. X ∧ Y ⊢ X               \PYGZhy{}\PYGZhy{} and\PYGZus{}elimination\PYGZus{}left}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 5. X ∧ Y ⊢ Y               \PYGZhy{}\PYGZhy{} and\PYGZus{}elimination\PYGZus{}right}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 6. X ⊢ X ∨ Y               \PYGZhy{}\PYGZhy{} or introduction left}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 7. Y ⊢ X ∨ Y               \PYGZhy{}\PYGZhy{} or introduction right}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 8. X ∨ Y, X → Z, Y → Z ⊢ Z \PYGZhy{}\PYGZhy{} or elimination}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 9. ¬¬X ⊢ X                 \PYGZhy{}\PYGZhy{} negation elimination}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 10. X → ⊥ ⊢ ¬X             \PYGZhy{}\PYGZhy{} negation introduction}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 11. (X ⊢ Y) ⊢ (X → Y)      \PYGZhy{}\PYGZhy{} a little complicated}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 12. X → Y, X ⊢ Y           \PYGZhy{}\PYGZhy{} arrow elimination}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 13. X → Y, Y → X ⊢ X ↔ Y    \PYGZhy{}\PYGZhy{} iff introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 14. X ↔ Y ⊢ X → Y          \PYGZhy{}\PYGZhy{} iff elimination left}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 15. X ↔ Y ⊢ Y → X          \PYGZhy{}\PYGZhy{} iff elimination right}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{open} \PYG{n}{cs6501}

\PYG{k+kd}{theorem} \PYG{n}{and\PYGZus{}intro\PYGZus{}valid} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{X} \PYG{n}{Y} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
    \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{n}{X}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{n}{Y}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{i}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{X\PYGZus{}true} \PYG{n}{Y\PYGZus{}true}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} axioms of eq}
\PYG{n}{rw} \PYG{n}{X\PYGZus{}true}\PYG{o}{,}
\PYG{n}{rw} \PYG{n}{Y\PYGZus{}true}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{theorem} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}valid} \PYG{o}{:}
\PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{X} \PYG{n}{Y} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
\PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{n}{X}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{i}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h\PYGZus{}and}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{X} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{Y} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h\PYGZus{}and}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h\PYGZus{}and}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{Y} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h\PYGZus{}and}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{theorem} \PYG{n}{or\PYGZus{}intro\PYGZus{}left\PYGZus{}valid} \PYG{o}{:}
\PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{X} \PYG{n}{Y} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
\PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{i}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{X\PYGZus{}true}\PYG{o}{,}
\PYG{n}{rw} \PYG{n}{X\PYGZus{}true}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{theorem} \PYG{n}{or\PYGZus{}elim\PYGZus{}valid} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{X} \PYG{n}{Y} \PYG{n}{Z} \PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)} \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}\PYG{o}{,}
\PYG{o}{(}\PYG{n+nb+bp}{⟦} \PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}\PYG{o}{)} \PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→}
\PYG{o}{(}\PYG{n+nb+bp}{⟦} \PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{Z}\PYG{o}{)} \PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→}
\PYG{o}{(}\PYG{n+nb+bp}{⟦} \PYG{o}{(}\PYG{n}{Y} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{Z}\PYG{o}{)} \PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→}
\PYG{o}{(}\PYG{n+nb+bp}{⟦} \PYG{n}{Z} \PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} expand definitions as assume premises}
\PYG{n}{unfold} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{Z} \PYG{n}{i}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h\PYGZus{}xory} \PYG{n}{h\PYGZus{}xz} \PYG{n}{h\PYGZus{}yz}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} the rest is by nested case analysis}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} this script is refined from my original}
\PYG{n}{cases} \PYG{o}{(}\PYG{n+nb+bp}{⟦} \PYG{n}{X} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} case analysis on bool (⟦ X ⟧ i)}
\PYG{n}{repeat} \PYG{o}{\PYGZob{}}
  \PYG{n}{repeat} \PYG{o}{\PYGZob{}}      \PYG{c+c1}{\PYGZhy{}\PYGZhy{}  case analysis on bool (⟦ Y ⟧ i)}
    \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{Y} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
    \PYG{n}{repeat} \PYG{o}{\PYGZob{}}    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} case analysis on bool (⟦ Z ⟧ i)}
      \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{Z} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
      \PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{I}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{h}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{y}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{r}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{t}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{p}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{m}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{/}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{m}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{\PYGZdq{}}\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{p}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{.}\PYG{c+cm}{\PYGZdq{}}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{\PYGZhy{}/}
      \PYG{n}{contradiction}\PYG{o}{,}
      \PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
    \PYG{o}{\PYGZcb{}}\PYG{o}{,}
  \PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Practice}
\label{\detokenize{A_01_Propositional_Logic:practice}}
\sphinxAtStartPar
In the style of the preceding examples, formally state,
name, and prove that each of the remaining inference are
also valid in our logic. Identify any rules that fail to be
provable in the presence of the bug we injected in bimp.
You can do this by completing the proofs and seeing how
they break when bugs are added to our definitions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Write your formal propositions and proofs here:}



\PYG{k+kd}{end} \PYG{n}{cs6501}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nb+bp}{.}\PYG{n}{A\PYGZus{}06\PYGZus{}prop\PYGZus{}logic\PYGZus{}algebraic\PYGZus{}axioms}
\PYG{k+kn}{namespace} \PYG{n}{cs6501}
\end{sphinxVerbatim}


\section{Inference Rules Validation}
\label{\detokenize{A_01_Propositional_Logic:inference-rules-validation}}
\sphinxAtStartPar
This chapter pulls together in one place a formal
validation of the claim that our model of propositional
logic satisfies all of the =inference rules of that logic.

\sphinxAtStartPar
The first section of this chapter refactors the partial
solution we developed in class, grouping definitions of
the propositions that represent them, and separately a
proof that each rule expresses in our model is valid.
These sections also afford opportunities to intruduce
a few more concepts in type theory and Lean.

\sphinxAtStartPar
To begin we import some definitions and declare a set
of variables available for use in this file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{section} \PYG{n}{rule\PYGZus{}validation}
\PYG{k+kd}{variables}
  \PYG{o}{(}\PYG{n}{X} \PYG{n}{Y} \PYG{n}{Z}\PYG{o}{:} \PYG{n}{prop\PYGZus{}expr}\PYG{o}{)}
  \PYG{o}{(}\PYG{n}{i} \PYG{o}{:} \PYG{n}{prop\PYGZus{}var} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)}
\end{sphinxVerbatim}


\subsection{Inference Rule Statements}
\label{\detokenize{A_01_Propositional_Logic:inference-rule-statements}}
\sphinxAtStartPar
We start with a refactoring of the results of the last
chapter, into formal statements of the inference rules
and formal proofs that these rules are valid (truth\sphinxhyphen{}
preserving under all interpretations) in our model of
propositional logic.

\sphinxAtStartPar
Key idea: These are rules for reasoning about evidence.
What \sphinxstyleemphasis{evidence} do you need to derive a given conclusion?
These are the “introduction” rules. From a given piece of
evidence (and possibly with additional evidence) what new
forms of evidence can you derive? These are “elimination”
rules of the logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} remember, we can now use X, Y, Z, i}

\PYG{k+kd}{def} \PYG{n}{true\PYGZus{}intro\PYGZus{}rule} \PYG{o}{:=} \PYG{n+nb+bp}{⟦} \PYG{n+nb+bp}{⊤} \PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}
\PYG{k+kd}{def} \PYG{n}{false\PYGZus{}elim\PYGZus{}rule} \PYG{o}{:=} \PYG{n+nb+bp}{⟦}\PYG{n+nb+bp}{⊥}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt} \PYG{n+nb+bp}{→} \PYG{n+nb+bp}{⟦}\PYG{n}{X}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} X is any proposition}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}intro\PYGZus{}rule} \PYG{o}{:=} \PYG{n+nb+bp}{⟦} \PYG{n}{X} \PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt} \PYG{n+nb+bp}{→} \PYG{n+nb+bp}{⟦} \PYG{n}{Y} \PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt} \PYG{n+nb+bp}{→} \PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{o}{:=} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{n}{X}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}elim\PYGZus{}right\PYGZus{}rule} \PYG{o}{:=} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{n}{Y}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}intro\PYGZus{}left\PYGZus{}rule} \PYG{o}{:=} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{n}{X}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}intro\PYGZus{}right\PYGZus{}rule} \PYG{o}{:=} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{n}{Y}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)}
\PYG{k+kd}{def} \PYG{n}{or\PYGZus{}elim\PYGZus{}rule} \PYG{o}{:=}   \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{∨} \PYG{n}{Y}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→}
                      \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{X} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{Z}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→}
                      \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{Y} \PYG{n+nb+bp}{=}\PYG{n+nb+bp}{\PYGZgt{}} \PYG{n}{Z}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)} \PYG{n+nb+bp}{→}
                      \PYG{o}{(}\PYG{n+nb+bp}{⟦}\PYG{o}{(}\PYG{n}{Z}\PYG{o}{)}\PYG{n+nb+bp}{⟧} \PYG{n}{i} \PYG{n+nb+bp}{=} \PYG{n}{tt}\PYG{o}{)}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} formalize the rest}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 9. ¬¬X ⊢ X                 \PYGZhy{}\PYGZhy{} negation elimination}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 10. X → ⊥ ⊢ ¬X             \PYGZhy{}\PYGZhy{} negation introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 11. (X ⊢ Y) ⊢ (X → Y)      \PYGZhy{}\PYGZhy{} a little complicated}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 12. X → Y, X ⊢ Y           \PYGZhy{}\PYGZhy{} arrow elimination}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 13. X → Y, Y → X ⊢ X ↔ Y    \PYGZhy{}\PYGZhy{} iff introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 14. X ↔ Y ⊢ X → Y          \PYGZhy{}\PYGZhy{} iff elimination left}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 15. X ↔ Y ⊢ Y → X          \PYGZhy{}\PYGZhy{} iff elimination right}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{open} \PYG{n}{cs6501}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} note:}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}intro\PYGZus{}rule} \PYG{n}{e1} \PYG{n}{e2} \PYG{n}{i}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} prove it}
\PYG{k+kd}{theorem} \PYG{n}{and\PYGZus{}intro} \PYG{o}{:} \PYG{n}{and\PYGZus{}intro\PYGZus{}rule} \PYG{n}{e1} \PYG{n}{e2} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{X\PYGZus{}true} \PYG{n}{Y\PYGZus{}true}\PYG{o}{,}
\PYG{n}{unfold} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} axioms of eq}
\PYG{n}{rw} \PYG{n}{X\PYGZus{}true}\PYG{o}{,}
\PYG{n}{rw} \PYG{n}{Y\PYGZus{}true}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{theorem} \PYG{n}{and\PYGZus{}elim\PYGZus{}left} \PYG{o}{:} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} case analysis}
\PYG{k}{assume} \PYG{n}{h\PYGZus{}and}\PYG{o}{,}
\PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{X} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} cases analysis on X}
\PYG{o}{\PYGZob{}} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} case X (evaluates to) false}
  \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{Y} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} nested case analysis on Y}
    \PYG{n}{cases} \PYG{n}{h\PYGZus{}and}\PYG{o}{,}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} contradiction}
    \PYG{n}{cases} \PYG{n}{h\PYGZus{}and}\PYG{o}{,}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} contradiction}
\PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{o}{\PYGZob{}} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} case X (evaluates to) true}
  \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{Y} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} nested case analysis on Y}
  \PYG{n}{cases} \PYG{n}{h\PYGZus{}and}\PYG{o}{,}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} contradiction}
  \PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} ahh, equality}
\PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{theorem} \PYG{n}{or\PYGZus{}intro\PYGZus{}left} \PYG{o}{:} \PYG{n}{or\PYGZus{}intro\PYGZus{}left\PYGZus{}rule} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{i}
\PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{or\PYGZus{}intro\PYGZus{}left\PYGZus{}rule} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{X\PYGZus{}true}\PYG{o}{,}
\PYG{n}{rw} \PYG{n}{X\PYGZus{}true}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{theorem} \PYG{n}{or\PYGZus{}elim} \PYG{o}{:} \PYG{n}{or\PYGZus{}elim\PYGZus{}rule} \PYG{n}{X} \PYG{n}{Y} \PYG{n}{Z} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} expand definitions as assume premises}
\PYG{n}{unfold} \PYG{n}{or\PYGZus{}elim\PYGZus{}rule} \PYG{n}{pEval} \PYG{n}{bin\PYGZus{}op\PYGZus{}sem}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h\PYGZus{}xory} \PYG{n}{h\PYGZus{}xz} \PYG{n}{h\PYGZus{}yz}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} the rest is by nested case analysis}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} this script is refined from my original}
\PYG{n}{cases} \PYG{o}{(}\PYG{n+nb+bp}{⟦} \PYG{n}{X} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{)}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} case analysis on bool (⟦ X ⟧ i)}
\PYG{n}{repeat} \PYG{o}{\PYGZob{}}
  \PYG{n}{repeat} \PYG{o}{\PYGZob{}}      \PYG{c+c1}{\PYGZhy{}\PYGZhy{}  case analysis on bool (⟦ Y ⟧ i)}
    \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{Y} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
    \PYG{n}{repeat} \PYG{o}{\PYGZob{}}    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} case analysis on bool (⟦ Z ⟧ i)}
      \PYG{n}{cases} \PYG{n+nb+bp}{⟦} \PYG{n}{Z} \PYG{n+nb+bp}{⟧} \PYG{n}{i}\PYG{o}{,}
      \PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{I}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{h}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{y}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{r}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{t}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{p}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{m}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{/}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{m}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{\PYGZdq{}}\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{p}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{.}\PYG{c+cm}{\PYGZdq{}}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{\PYGZhy{}/}
      \PYG{n}{contradiction}\PYG{o}{,}
      \PYG{n}{apply} \PYG{n}{rfl}\PYG{o}{,}
    \PYG{o}{\PYGZcb{}}\PYG{o}{,}
  \PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Proofs}
\label{\detokenize{A_01_Propositional_Logic:proofs}}
\sphinxAtStartPar
In the style of the preceding examples, give formal proofs
of that the remaining inference rules are valid in our own
model of propositional logic.

\sphinxAtStartPar
Identify any rules that fail to be provably valid in the
presence of the bug we’d injected in bimp. Which rule
validation proofs break when you re\sphinxhyphen{}activate that bug?

\sphinxAtStartPar
To get you started, the following proof shosws that the
false elimination inference rule is valid in our logic.
For any proposition, e, and interpretation, i, in
our logic, if ⊥ implies e, so from the truth of
⊥, the truth of any expression follows. But ⊥
can’t ever be (evaluate to) true, because we’ve
defined the logic otherwise. But wait, is there
another way to formalize the axiom? If so, are
the two ways equivalent?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{theorem} \PYG{n}{false\PYGZus{}elim} \PYG{o}{:} \PYG{n}{false\PYGZus{}elim\PYGZus{}rule} \PYG{n}{X} \PYG{n}{i} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{false\PYGZus{}elim\PYGZus{}rule} \PYG{n}{pEval}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} contradiction, can\PYGZsq{}t hppen, no cases!}
          \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Lean determines tt = ff is impossible}
\PYG{k+kd}{end}


\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Define the remaning propositions and proofs here:}


\PYG{k+kd}{end} \PYG{n}{rule\PYGZus{}validation} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} section}
\PYG{k+kd}{end} \PYG{n}{cs6501}          \PYG{c+c1}{\PYGZhy{}\PYGZhy{} namepsace}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Constructive Logic}
\label{\detokenize{A_02_Constructive_Logic:constructive-logic}}\label{\detokenize{A_02_Constructive_Logic:introduction}}\label{\detokenize{A_02_Constructive_Logic::doc}}

\section{Higher\sphinxhyphen{}Order Predicate Logic}
\label{\detokenize{A_02_Constructive_Logic:higher-order-predicate-logic}}
\sphinxAtStartPar
The term, \sphinxstyleemphasis{predicate logic}, used informally, is usually taken to
refer to first\sphinxhyphen{}order predicate logic (often extended with theories,
e.g., of natural number arithmetic). However, in this course, you
will learn higher\sphinxhyphen{}order constructive predicate logic. First\sphinxhyphen{}order
logic is a special restricted case.

\sphinxAtStartPar
We’ve organized the course so far to prepare you to quickly pick
up higher\sphinxhyphen{}order predicate logic as it’s \sphinxstyleemphasis{embedded} in the logic of
the Lean prover, by definitions provided by \sphinxstyleemphasis{mathlib}, Lean’s main
library of mathematical definitions.

\sphinxAtStartPar
Major similarities and changes include the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Propositions become types, not just logical expressions

\item {} 
\sphinxAtStartPar
Truth judgments (⟦E⟧ i = tt) replaced by proof judgments (e : E)

\item {} 
\sphinxAtStartPar
Functions and applications are essential parts of predicate logic

\item {} 
\sphinxAtStartPar
Predicates are functions from values to propositions \sphinxstyleemphasis{about them}

\item {} 
\sphinxAtStartPar
We adopt all of the usual propositional logic connectives

\item {} 
\sphinxAtStartPar
We adopt generalized versions of the usual inference rules

\item {} 
\sphinxAtStartPar
We gain two new ones: universal and existential quantifiers

\item {} 
\sphinxAtStartPar
We gain new inference rules for the ∀ and ∃ quantifiers

\item {} 
\sphinxAtStartPar
Generalizing (∀) over types gives us parametric polymorphism

\end{itemize}


\section{Propositions as Types}
\label{\detokenize{A_02_Constructive_Logic:propositions-as-types}}
\sphinxAtStartPar
In the last section, we build on all of the ideas of
the last chapter to gain an understanding of higher
order predicate logic in Lean. Each section of this
chapter focuses on a dimension in which the latter is
different, often a powerful generalization, of ideas
from the last chapter.

\sphinxAtStartPar
As an example, in the last chapter, we represented
propositions as terms of our data type, \sphinxstyleemphasis{prop\_expr}.
We  also saw that we could formulate inference rules of
propositional logic to provide a way to reason about
the truth of given propositions. In this chapter, we
will represent propositions as types of a special kind,
instead, and proofs as values of these types. We will
then adopt exacty the same inference rules we saw in
the last chapter, but generalized to this far more
expressive logic.

\sphinxAtStartPar
To warm up for the idea that propositions are (represented as)
types (in type theory), as an example we’ll first look at the
types related to the natural number, 1. Then we’ll analyze the
types of a few propositions, namely 1 = 1 and 0 = 1. The take
away message will be that propositions are special types that
live in their own \sphinxstyleemphasis{type universe} and values of such types (if
there are any) serve as \sphinxstyleemphasis{proofs} of such propositions.


\subsection{Computational Types}
\label{\detokenize{A_02_Constructive_Logic:computational-types}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} The type of 1 is nat}
\PYG{k}{\PYGZsh{}check} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Type type of nat is *Type*}
\PYG{k}{\PYGZsh{}check} \PYG{n}{nat}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} The type of all basic computational types is *Type*}
\PYG{k}{\PYGZsh{}check} \PYG{n}{bool}
\PYG{k}{\PYGZsh{}check} \PYG{n}{string}
\PYG{k}{\PYGZsh{}check} \PYG{n}{list} \PYG{n}{bool}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A natural question: What\PYGZsq{}s the type of Type, etc?}
\PYG{k}{\PYGZsh{}check} \PYG{k+kt}{Type}
\PYG{k}{\PYGZsh{}check} \PYG{k+kt}{Type} \PYG{l+m+mi}{0}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Type is shorthand for Type 0}
\PYG{k}{\PYGZsh{}check} \PYG{k+kt}{Type} \PYG{l+m+mi}{1}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} It\PYGZsq{}s type universes all the way up}
\PYG{k}{\PYGZsh{}check} \PYG{k+kt}{Type} \PYG{l+m+mi}{2}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} etc.}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{W}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{c}\PYG{c+cm}{h}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{\PYGZdq{}}\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{u}\PYG{c+cm}{t}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{\PYGZdq{}}
\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{k}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{:}

\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{.}\PYG{c+cm}{.}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{s}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{b}\PYG{c+cm}{j}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{a}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{0}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{b}\PYG{c+cm}{j}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{s}\PYG{c+cm}{)}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{0}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{e}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}

\PYG{c+cm}{T}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{U}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{s}
\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}
\PYG{c+cm}{\PYGZhy{}/}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} What universes do various objects inhabit}
\PYG{k}{\PYGZsh{}check} \PYG{n}{nat}             \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Type 0}
\PYG{k}{\PYGZsh{}check} \PYG{n}{list} \PYG{n}{nat}        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} list of nats : Type 0}

\PYG{k+kd}{def} \PYG{n}{list\PYGZus{}of\PYGZus{}types} \PYG{o}{:} \PYG{n}{list} \PYG{k+kt}{Type} \PYG{o}{:=} \PYG{o}{[}\PYG{n}{nat}\PYG{o}{,} \PYG{n}{bool}\PYG{o}{,} \PYG{n}{string}\PYG{o}{]}
\PYG{k}{\PYGZsh{}check} \PYG{n}{list} \PYG{o}{(}\PYG{k+kt}{Type} \PYG{l+m+mi}{0}\PYG{o}{)}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} list of Type 0s : Type 1}
\PYG{k}{\PYGZsh{}check} \PYG{n}{list} \PYG{o}{(}\PYG{k+kt}{Type} \PYG{l+m+mi}{1}\PYG{o}{)}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} list of Type 1s : Type 2}
\end{sphinxVerbatim}


\subsection{Logical Types (Propositions)}
\label{\detokenize{A_02_Constructive_Logic:logical-types-propositions}}
\sphinxAtStartPar
Now we’ll turn to the idea that propositions are types of
a logical kind. In Lean and related proof assistants and in
type theory more generally, propositions are represented as
\sphinxstyleemphasis{types} that inhabit a special type universe: in Lean, Prop.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{l+m+mi}{1} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} 1 = 1 is a proposition, thus of type Prop}
\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{∃} \PYG{o}{(}\PYG{n}{a} \PYG{n}{b} \PYG{n}{c} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)}\PYG{o}{,} \PYG{n}{a}\PYG{n+nb+bp}{*}\PYG{n}{a} \PYG{n+nb+bp}{+} \PYG{n}{b}\PYG{n+nb+bp}{*}\PYG{n}{b} \PYG{n+nb+bp}{=} \PYG{n}{c}\PYG{n+nb+bp}{*}\PYG{n}{c} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} also of type Prop}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Example: Here\PYGZsq{}s a proof of 1 = 1}
\PYG{k+kd}{def} \PYG{n}{proof\PYGZus{}of\PYGZus{}1\PYGZus{}eq\PYGZus{}1} \PYG{o}{:=} \PYG{n}{eq.refl} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} What is its type?}
\PYG{k}{\PYGZsh{}check} \PYG{n}{proof\PYGZus{}of\PYGZus{}1\PYGZus{}eq\PYGZus{}1}
\end{sphinxVerbatim}

\sphinxAtStartPar
In Lean, types are terms, too, and so they have types, as we
have already seen. So what is the type of \sphinxstyleemphasis{1 = 1}. It’s Prop.
As we’ve said, logical types (propositions) inhabit the type
universe, Prop, also known as Sort 0.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{l+m+mi}{1} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1}
\PYG{k}{\PYGZsh{}check} \PYG{k+kt}{Prop}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we can clearly see the type hierarchy. Each proposition
is a type, and all such types are in turn of type, Prop. We we
have the following picture of the type hierarchy for the
terms we’ve just constructed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} type is 1 = 1}
\PYG{k}{\PYGZsh{}check} \PYG{n}{proof\PYGZus{}of\PYGZus{}1\PYGZus{}eq\PYGZus{}1}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} type is Prop}
\PYG{k}{\PYGZsh{}check} \PYG{l+m+mi}{1} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
You might finally ask, what is the type of Prop? It’s Type!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{k+kt}{Prop}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{W}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{w}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{w}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{o}\PYG{c+cm}{w}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{k}\PYG{c+cm}{.}

\PYG{c+cm}{P}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{S}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{0}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZgt{}}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{S}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{0}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZgt{}}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{S}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{2}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{\PYGZgt{}}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{c}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{=}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}
\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{|}
\PYG{c+cm}{e}\PYG{c+cm}{q}\PYG{c+cm}{.}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{ }\PYG{c+cm}{[}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{l}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{]}
\PYG{c+cm}{\PYGZhy{}/}
\end{sphinxVerbatim}


\subsection{Type Universe Levels}
\label{\detokenize{A_02_Constructive_Logic:type-universe-levels}}
\sphinxAtStartPar
In the top row we have a hierarchy of type universes, starting
with Sort 0 and extending up. Prop is the common name in Lean for
Sort 0, and Type is the common name for Sort 1. In the second row
are examples of types that inhabit each of the universes. \sphinxstyleemphasis{1 = 1}
for example is a logical type (a proposition) in Prop, while nat
is a computational type in Type. Finally, \sphinxstyleemphasis{list Type} is the type
of lists of terms each of type Type, i.e., lists of computational
types. The bottom row gives examples of values of each of the types
above: \sphinxstyleemphasis{eq.refl 1} is a proof/value of (type) \sphinxstyleemphasis{1 = 1}; 1 is a value
of type \sphinxstyleemphasis{nat}; and \sphinxstyleemphasis{{[}nat, bool, string{]}}, because it contains as
elements values of type Type 0 is itself a value of type Type 1.

\sphinxAtStartPar
As a final comment, Lean allows one to generalize over these
type universes. To do so you declare one or more \sphinxstyleemphasis{universe
variable} which you can then use in decaring types. Lean can
also infer universe levels.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} declare two possible different type Universe levels}
\PYG{k+kd}{universes} \PYG{n}{u} \PYG{n}{v}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{}}
\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{@}\PYG{n}{prod.mk}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Here\PYGZsq{}s a function that takes two types in arbitrary universes}
\PYG{k+kd}{def} \PYG{n}{mk\PYGZus{}pair} \PYG{o}{(}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Sort} \PYG{n}{u}\PYG{o}{)} \PYG{o}{(}\PYG{n}{β} \PYG{o}{:} \PYG{k+kt}{Sort} \PYG{n}{v}\PYG{o}{)} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{α}\PYG{o}{,} \PYG{n}{β}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Here are examples of type pairs we can form.}
\PYG{k}{\PYGZsh{}check} \PYG{n}{mk\PYGZus{}pair} \PYG{n}{nat} \PYG{n}{bool}
\PYG{k}{\PYGZsh{}check} \PYG{n}{mk\PYGZus{}pair} \PYG{o}{(}\PYG{l+m+mi}{1}\PYG{n+nb+bp}{=}\PYG{l+m+mi}{1}\PYG{o}{)} \PYG{o}{(}\PYG{l+m+mi}{2}\PYG{n+nb+bp}{=}\PYG{l+m+mi}{1}\PYG{o}{)}
\PYG{k}{\PYGZsh{}check} \PYG{n}{mk\PYGZus{}pair} \PYG{o}{(}\PYG{l+m+mi}{1}\PYG{n+nb+bp}{=}\PYG{l+m+mi}{1}\PYG{o}{)} \PYG{o}{(}\PYG{n}{list} \PYG{k+kt}{Type}\PYG{o}{)}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{A}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{g}\PYG{c+cm}{h}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{o}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{m}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{p}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}
\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{G}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{a}\PYG{c+cm}{k}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}
\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{v}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{*}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{n}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}

\PYG{k+kd}{def} \PYG{n}{my\PYGZus{}id} \PYG{o}{(}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Sort} \PYG{n}{u}\PYG{o}{)} \PYG{o}{(}\PYG{n}{a} \PYG{o}{:} \PYG{n}{α}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{a}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} applications to objects of various types}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{my\PYGZus{}id} \PYG{k+kt}{Prop} \PYG{o}{(}\PYG{l+m+mi}{1}\PYG{n+nb+bp}{=}\PYG{l+m+mi}{1}\PYG{o}{)}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{my\PYGZus{}id} \PYG{n}{nat} \PYG{l+m+mi}{1}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{my\PYGZus{}id} \PYG{o}{(}\PYG{n}{list} \PYG{k+kt}{Type}\PYG{o}{)} \PYG{o}{[}\PYG{n}{nat}\PYG{o}{,}\PYG{n}{nat}\PYG{o}{,}\PYG{n}{bool}\PYG{o}{]}
\end{sphinxVerbatim}


\subsection{Implicit Arguments}
\label{\detokenize{A_02_Constructive_Logic:implicit-arguments}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} With \PYGZob{}\PYGZcb{} we tell Lean that α should be inferred automatically}
\PYG{k+kd}{def} \PYG{n}{my\PYGZus{}id\PYGZsq{}} \PYG{o}{\PYGZob{}} \PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Sort} \PYG{n}{u} \PYG{o}{\PYGZcb{}} \PYG{o}{(}\PYG{n}{a} \PYG{o}{:} \PYG{n}{α}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{a}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Now we don\PYGZsq{}t provide the type arguments explicitly}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{my\PYGZus{}id\PYGZsq{}} \PYG{o}{(}\PYG{l+m+mi}{1}\PYG{n+nb+bp}{=}\PYG{l+m+mi}{1}\PYG{o}{)}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{my\PYGZus{}id\PYGZsq{}} \PYG{l+m+mi}{1}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{my\PYGZus{}id\PYGZsq{}} \PYG{o}{[}\PYG{n}{nat}\PYG{o}{,}\PYG{n}{nat}\PYG{o}{,}\PYG{n}{bool}\PYG{o}{]}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} If necessary through, we can turn off implicit inference using @}
\PYG{k}{\PYGZsh{}reduce} \PYG{n+nb+bp}{@}\PYG{n}{my\PYGZus{}id\PYGZsq{}} \PYG{k+kt}{Prop} \PYG{o}{(}\PYG{l+m+mi}{1}\PYG{n+nb+bp}{=}\PYG{l+m+mi}{1}\PYG{o}{)}
\PYG{k}{\PYGZsh{}reduce} \PYG{n+nb+bp}{@}\PYG{n}{my\PYGZus{}id\PYGZsq{}} \PYG{n}{nat} \PYG{l+m+mi}{1}
\PYG{k}{\PYGZsh{}reduce} \PYG{n+nb+bp}{@}\PYG{n}{my\PYGZus{}id\PYGZsq{}} \PYG{o}{(}\PYG{n}{list} \PYG{k+kt}{Type}\PYG{o}{)} \PYG{o}{[}\PYG{n}{nat}\PYG{o}{,}\PYG{n}{nat}\PYG{o}{,}\PYG{n}{bool}\PYG{o}{]}
\end{sphinxVerbatim}


\section{From Truth to Proof}
\label{\detokenize{A_02_Constructive_Logic:from-truth-to-proof}}
\sphinxAtStartPar
In both propositional and first order predicate logic,
inference rules are defined in terms of \sphinxstyleemphasis{truth judgments}.
For example, in our propositional logic, we defined the
\sphinxstyleemphasis{and elimination left} rule as (⟦ P ∧ Q ⟧ i == tt) →
⟦ P ⟧ i = tt. You can read it as saying, if we’ve judged
that P ∧ Q is true under some interpretation, i, then it
must be that P is also true under that interpretation.

\sphinxAtStartPar
In the logic of Lean, by contrast, inference rules are
defined in terms of \sphinxstyleemphasis{proof} judgments. In Lean, if \sphinxstyleemphasis{P}
is a proposition, then to express the idea that p is a
proof of P, we write (p : P). We can also read this proof
judgement as a type judgment: that p is a value of type P.
The and elimination left rule thus changes to the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule\PYGZsq{}} \PYG{o}{:=} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{P} \PYG{n}{Q} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)}\PYG{o}{,} \PYG{n}{P} \PYG{n+nb+bp}{∧} \PYG{n}{Q} \PYG{n+nb+bp}{→} \PYG{n}{P}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can read the proposition as saying the following:
if P and Q are arbitrary propositions, then if you are
given a \sphinxstyleemphasis{proof} (value) of (type) P ∧ Q, then you can
derive a proof (value) of (type) P.

\sphinxAtStartPar
Written in the typical inference rule styles you will
find in the literature, we’d see something like this:
\sphinxstyleemphasis{(P Q : Prop) (p : P) (q : P) ⊢ ⟨p,q⟩ : P ∧ Q}.

\sphinxAtStartPar
In a textbook, it’d often be assumed or implicit that
\sphinxstyleemphasis{P} and \sphinxstyleemphasis{Q} are propositions, in which case this rule
would be shortened to \sphinxstyleemphasis{P, Q ⊢ P ∧ Q}.

\sphinxAtStartPar
Using Lean’s \sphinxstyleemphasis{variables} declaration, we can achieve
the same clarity with complete formality.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Let P, Q, and R be arbitrary propositions}
\PYG{k+kd}{variables} \PYG{o}{(}\PYG{n}{P} \PYG{n}{Q} \PYG{n}{R} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Now we can write the rule without the forall}
\PYG{k+kd}{def} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{o}{:=} \PYG{n}{P} \PYG{n+nb+bp}{∧} \PYG{n}{Q} \PYG{n+nb+bp}{→} \PYG{n}{P}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{L}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{o}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{n}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{w}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{x}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}
\PYG{c+cm}{s}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{e}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{m}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{t}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{r}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{e}
\PYG{c+cm}{j}\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{P}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{o}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{H}\PYG{c+cm}{o}\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{,}
\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{l}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{P}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{Q}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{l}
\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{v}\PYG{c+cm}{i}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{d}
\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{s}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{o}\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{e}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{m}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{t}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{r}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{e}
\PYG{c+cm}{*}\PYG{c+cm}{a}\PYG{c+cm}{p}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{w}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{o}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{s}
\PYG{c+cm}{(}\PYG{c+cm}{s}\PYG{c+cm}{a}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{P}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{Q}\PYG{c+cm}{)}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{y}\PYG{c+cm}{i}\PYG{c+cm}{e}\PYG{c+cm}{l}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{i}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{o}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}
\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{t}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule\PYGZsq{}}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} just a proposition}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule}    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} function to proposition}

\PYG{k}{\PYGZsh{}check} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule}         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Prop → Prop → Prop}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule}        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} A proposition}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{n}{P} \PYG{n}{Q}    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Namely, P ∧ Q → P}

\PYG{k}{\PYGZsh{}check} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule\PYGZsq{}}       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} just Prop}
\PYG{k}{\PYGZsh{}check} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule\PYGZsq{}} \PYG{n}{P} \PYG{n}{Q}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Can\PYGZsq{}t be applied}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule applies to *any* propositions}
\PYG{k+kd}{variables} \PYG{o}{(}\PYG{n}{A} \PYG{n}{B} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)}
\PYG{k}{\PYGZsh{}check} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{n}{A} \PYG{n}{B}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{n}{A} \PYG{n}{B}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can now assert the validity of this rule, and prove
it. Of course the proof in this case will be nothing
but the application of Lean’s version, and.elim\_left.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{theorem} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}valid} \PYG{o}{:} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{n}{P} \PYG{n}{Q} \PYG{o}{:=}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} assume h is a proof of P → Q, show P}
\PYG{k+kd}{begin}
\PYG{n}{unfold} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule}\PYG{o}{,}
\PYG{n}{intro} \PYG{n}{h}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} apply and.elim\PYGZus{}left h}
\PYG{n}{exact} \PYG{n}{h.left}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} The theorem now applies generally to any propositions}

\PYG{k+kd}{theorem} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}valid\PYGZus{}2} \PYG{o}{:} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}rule} \PYG{n}{A} \PYG{n}{B} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{apply} \PYG{n}{and\PYGZus{}elim\PYGZus{}left\PYGZus{}valid}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Practice Example}
\label{\detokenize{A_02_Constructive_Logic:practice-example}}
\sphinxAtStartPar
Exercise: Define two propositions (types in Prop) with
made up names, each having two proof constructors also
with made up names. Recall that we define types with an
\sphinxstyleemphasis{inductive} definition. Here’s the exact definition of
the bool type, for example.

\sphinxAtStartPar
inductive bool : Type
| tt
| ff

\sphinxAtStartPar
The big difference now is that we want to represent
logical propositions, so we will define types not in
the universe, Type, but in Prop, the universe that all
logical propositions inhabit. Now it’s easy as the next
example shows. We define two propositions, each with
two “proofs,” and show that we can construct a proof
of the the conjunction of the two propositions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A proposition called KevinIsFromCville with two proofs}
\PYG{k+kd}{inductive} \PYG{n}{KevinIsFromCville} \PYG{o}{:} \PYG{k+kt}{Prop}
\PYG{n+nb+bp}{|} \PYG{n}{DL}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} driver\PYGZsq{}s license}
\PYG{n+nb+bp}{|} \PYG{n}{EB}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} electric bill}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Another similar proposition}
\PYG{k+kd}{inductive} \PYG{n}{NickIsFromNewHampshire} \PYG{o}{:} \PYG{k+kt}{Prop}
\PYG{n+nb+bp}{|} \PYG{n}{DL}      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} driver\PYGZsq{}s license}
\PYG{n+nb+bp}{|} \PYG{n}{EB}      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} electric bill}
\PYG{n+nb+bp}{|} \PYG{n}{LFODLP}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} secret code}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Because we can prove each one we can prove the conjunction}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{KevinIsFromCville} \PYG{n+nb+bp}{∧}  \PYG{n}{NickIsFromNewHampshire} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{apply} \PYG{n}{and.intro} \PYG{n}{\PYGZus{}} \PYG{n}{\PYGZus{}}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{KevinIsFromCville.EB}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{NickIsFromNewHampshire.LFODLP}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Similarly, from a proof of a conjunctions we can prove each}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{KevinIsFromCville} \PYG{n+nb+bp}{∧}  \PYG{n}{NickIsFromNewHampshire} \PYG{n+nb+bp}{→} \PYG{n}{KevinIsFromCville} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{assumption}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\section{Inference Rules}
\label{\detokenize{A_02_Constructive_Logic:inference-rules}}
\sphinxAtStartPar
Next we’ll see that most of the inference rules
of propositional logic have analogues in constructive
predicate logic, provided to us by \sphinxstyleemphasis{mathlib}, Lean’s
library of mathematical definitions.

\sphinxAtStartPar
Your next major task is to know and understand these
inference rules. For each connective, learn its related
introduction (proof constructing) and elimination (proof
consuming) rules. Grasp the sense of each rule clerly.
And learn how to to compose them, e.g., in proof scripts,
to produce proofs of more complex propositions.

\sphinxAtStartPar
This new inference rule is just an “upgraded”
version of the and\sphinxhyphen{}elimination\sphinxhyphen{}left inference rule from
from the last chapter. The major task in the rest of this
chapter is to “lift” your established understanding of all
of the inference rules of propositional logic to the level
of higher\sphinxhyphen{}order constructive logic. Along the way we’ll see
a few places where the “classical” rules don’t work.
We now go through each rule from propositional logic and
give its analog in the predicate logic of the Lean prover.


\subsection{true (⊤)}
\label{\detokenize{A_02_Constructive_Logic:true}}
\sphinxAtStartPar
In propositional logic, we had the rule that ⊤, always
evaluates to true (tt in Lean). The definition said this:
\sphinxstyleemphasis{true\_intro\_rule := ⟦ ⊤ ⟧ i = tt}.

\sphinxAtStartPar
In Lean, by contrast, there is a proposition, \sphinxstyleemphasis{true}, that
has proof, called \sphinxstyleemphasis{intro}. We write \sphinxstyleemphasis{true.intro} to refer
to it in its namespace.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{true}                   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} a proposition}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{true} \PYG{o}{:=} \PYG{n}{true.intro}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} a proof of it}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we’ll see exactly how the proposition, true, with
true.intro as a proof, how it is all defined. It’s simple.
Propositions are types, so true is a type, but one that
inhabits Prop; and it has one constant constructor and
that’s the one and only proof, \sphinxstyleemphasis{intro}.That’s it!

\sphinxAtStartPar
inductive true : Prop
| intro : true

\sphinxAtStartPar
Sadly, a proof of true is pretty useless. A value of this type
doesn’t even provide one bit of information, as a Boolean value
would. There’s no interesting elimination rule for true.


\subsection{false}
\label{\detokenize{A_02_Constructive_Logic:false}}
\sphinxAtStartPar
In propositional logic, we had the propositional expression
(prop\_expr), ⊥, for \sphinxstyleemphasis{false}. In Lean, by contrast, \sphinxstyleemphasis{false} is
a \sphinxstyleemphasis{proposition}, which is to say, a type, called \sphinxstyleemphasis{false}.
Because we want this proposition never to be true, we define
it as a type with no values/proofs at all–as an uninhabited
type.

\sphinxAtStartPar
inductive false : Prop

\sphinxAtStartPar
There is no way ever to produce a proof of \sphinxstyleemphasis{false} because
the type has no value constructors. There is no introduction
rule false.

\sphinxAtStartPar
In propositional logic, the false elimination rule said that
if an expression evaluates to ff, then it follows (implication)
that any other expression evaluates to tt. The rule in Lean is
called false.elim. It says that from a proof of false, a proof
(or value) of \sphinxstyleemphasis{any} type in any type universe can be produced:
not only proofs of other propositions but values of any types.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{false}
\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{@}\PYG{n}{false.elim}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} false.elim : Π \PYGZob{}C : Sort u\PYGZus{}1\PYGZcb{}, false → C}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} explicit application of Lean\PYGZsq{}s false.elim rule}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{false} \PYG{n+nb+bp}{→} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{f}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{false.elim} \PYG{n}{f}\PYG{o}{,}       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} So what is C (\PYGZus{})? It\PYGZsq{}s the goal, 0 = 1.}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} exact @false.elim \PYGZus{} f,    \PYGZhy{}\PYGZhy{} Note that C is an implicit argument!}
\PYG{k+kd}{end}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{W}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{W}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{e}\PYG{c+cm}{t}
\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{o}\PYG{c+cm}{s}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{m}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{A}\PYG{c+cm}{s}
\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{t}
\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{false} \PYG{n+nb+bp}{→} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{f}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{f}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{F}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{m}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{k}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{\PYGZdq{}}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{\PYGZdq{}}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{y}
\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{W}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{s}
\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{P}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{false} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{f}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{f}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} contradiction,  \PYGZhy{}\PYGZhy{} this tactic works here, too}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{and ∧}
\label{\detokenize{A_02_Constructive_Logic:and}}
\sphinxAtStartPar
From propositional logic we had three inference rules defining
the meaning of \sphinxstyleemphasis{and}, one introduction and two elimination rules.
These rules re\sphinxhyphen{}appear in both first\sphinxhyphen{}order predicate logic and in
the higher\sphinxhyphen{}order logic of Lean, but now in a much richer logic.
In this chapter we’ll see how this is done, using \sphinxstyleemphasis{and} as an
easy example.
\begin{itemize}
\item {} 
\sphinxAtStartPar
and\_intro\_rule := ⟦ X ⟧ i = tt → ⟦ Y ⟧ i = tt → ⟦(X ∧ Y)⟧ i = tt

\item {} 
\sphinxAtStartPar
and\_elim\_left\_rule := (⟦(X ∧ Y)⟧ i = tt) → (⟦X⟧ i = tt)

\item {} 
\sphinxAtStartPar
and\_elim\_right\_rule := (⟦(X ∧ Y)⟧ i = tt) → (⟦Y⟧ i = tt)

\end{itemize}


\subsubsection{Proposition Builders}
\label{\detokenize{A_02_Constructive_Logic:proposition-builders}}
\sphinxAtStartPar
A key idea in Lean’s definitions is that \sphinxstyleemphasis{and} is a \sphinxstyleemphasis{polymorphic}
data type. That is to say, its akin to a function takes any two
propositions (types in Prop) as arguments and yields a new Type.
This new type encodes the proposition that is the conjunction of
the given proposition arguments. Let’s see how \sphinxstyleemphasis{and} is defined.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{structure} \PYG{n}{and} \PYG{o}{(}\PYG{n}{A} \PYG{n}{B} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)} \PYG{o}{:} \PYG{k+kt}{Prop} \PYG{o}{:=}
\PYG{n}{intro} \PYG{o}{:}\PYG{o}{:} \PYG{o}{(}\PYG{n}{left} \PYG{o}{:} \PYG{n}{A}\PYG{o}{)} \PYG{o}{(}\PYG{n}{right} \PYG{o}{:} \PYG{n}{B}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxstyleemphasis{structure} keyword is shorthand for \sphinxstyleemphasis{inductive} and can be
used (only) when a type has just one constructor. The name of the
constructor here is \sphinxstyleemphasis{intro}. It takes two arguments, \sphinxstyleemphasis{left}, a
proof (value) of (type) \sphinxstyleemphasis{A}, and \sphinxstyleemphasis{right}, a proof of \sphinxstyleemphasis{B}.

\sphinxAtStartPar
A benefit of using the \sphinxstyleemphasis{structure} keyword is that Lean generates
field access functions with the given field names. For example, if
\sphinxstyleemphasis{(h : A ∧ B)}, then \sphinxstyleemphasis{(h.left : A)} and \sphinxstyleemphasis{(h.right : B)}.


\subsubsection{Introduction: Proof Constructors}
\label{\detokenize{A_02_Constructive_Logic:introduction-proof-constructors}}
\sphinxAtStartPar
The second key idea is that the constructors of a logical type
define what terms count as proofs, i.e., values of the type.

\sphinxAtStartPar
In the case of a conjunction, there is just one constructor,
namely \sphinxstyleemphasis{intro,} takes two proof values as arguments and yielding
a proof of the conjunction of the propositions that they prove.

\sphinxAtStartPar
Note: It’s important to distinguish clearly between \sphinxstyleemphasis{and} and
\sphinxstyleemphasis{intro} in your mind. The \sphinxstyleemphasis{and} connective (∧) is a proposition
builder, a type builder. It takes two \sphinxstyleemphasis{propositions} (types),
\sphinxstyleemphasis{(A B : Prop)} as its arguments and yields a new proposition
(type) as a result, namely \sphinxstyleemphasis{(and A B),} also written as \sphinxstyleemphasis{A ∧ B}.

\sphinxAtStartPar
On the other hand, \sphinxstyleemphasis{and.intro} is a \sphinxstyleemphasis{proof/value constructor.}
It takes two \sphinxstyleemphasis{proof values, (a : A)} and \sphinxstyleemphasis{(b : B)} as arguments,
and yields a new proof/value/term, \sphinxstyleemphasis{⟨ a, b ⟩ : A ∧ B}. There is
no other way to construct a proof of a conjunction, \sphinxstyleemphasis{A ∧ B,} than
to use this constructor.


\subsubsection{Elimination: Case Analysis}
\label{\detokenize{A_02_Constructive_Logic:elimination-case-analysis}}
\sphinxAtStartPar
Now that we’ve seen how to (1) construct a conjunction from two
given propositions, and (2) construct a proof of one, we turn to
the question, what can we \sphinxstyleemphasis{do} with such a proof if we have one.

\sphinxAtStartPar
The answer, in general, is that we can analyze how it could have
been built, with an aim to show that a given proof goal follows
in every case. If we can show that, then we’ve proved it always
holds.

\sphinxAtStartPar
An already familiar example is our earlier case analysis of values
of type bool. When we do case analysis on an arbitrary bool value,
we have to consider the two ways (constructors) that a bool can be
constructed: using the \sphinxstyleemphasis{tt} constructor or the \sphinxstyleemphasis{ff} constructor. A
proof by case analysis on a bool, b, thus requires two sub\sphinxhyphen{}proofs:
one that shows a given goal follows if \sphinxstyleemphasis{b} is \sphinxstyleemphasis{tt} and another that
shows it follows if \sphinxstyleemphasis{b} is \sphinxstyleemphasis{ff}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{(}\PYG{n}{b} \PYG{o}{:} \PYG{n}{bool}\PYG{o}{)} \PYG{o}{:}  \PYG{n}{bnot} \PYG{o}{(}\PYG{n}{bnot} \PYG{n}{b}\PYG{o}{)} \PYG{n+nb+bp}{=} \PYG{n}{b} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{cases} \PYG{n}{b}\PYG{o}{,}              \PYG{c+c1}{\PYGZhy{}\PYGZhy{} NB: one case per constructor}
\PYG{n}{repeat} \PYG{o}{\PYGZob{}} \PYG{n}{apply} \PYG{n}{rfl} \PYG{o}{\PYGZcb{}}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} prove goal *in each case*}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} QED.               \PYGZhy{}\PYGZhy{} thus proving it in *all* cases}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
Turning to a proof of a conjunction, \sphinxstyleemphasis{A ∧ B}, only two
small details change. First, there \sphinxstyleemphasis{and} has just one
constructor. So when we do case analysis, we’ll get only
one case to consider. Second, the constructor now takes
two arguments, rather than zero as with tt and ff. So,
in that one case, we’ll be entitled to assume that the
two proof arguments must have been given. These will be
the \sphinxstyleemphasis{left} and \sphinxstyleemphasis{right} proofs of \sphinxstyleemphasis{A} and \sphinxstyleemphasis{B} separately.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Case analysis on *proof* values}
\PYG{k+kd}{example} \PYG{o}{(}\PYG{n}{X} \PYG{n}{Y}\PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)} \PYG{o}{:} \PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y} \PYG{n+nb+bp}{→} \PYG{n}{X} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} a proof we can *use*}
\PYG{n}{cases} \PYG{n}{h} \PYG{k}{with} \PYG{n}{x} \PYG{n}{y}\PYG{o}{,}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} analyze each possible case}
\PYG{n}{exact} \PYG{n}{x}\PYG{o}{,}            \PYG{c+c1}{\PYGZhy{}\PYGZhy{} also known as destructuring}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} We can even use \PYGZdq{}case analysis\PYGZdq{} programming notation!}
\PYG{k+kd}{example} \PYG{o}{(}\PYG{n}{X} \PYG{n}{Y}\PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)} \PYG{o}{:} \PYG{n}{X} \PYG{n+nb+bp}{∧} \PYG{n}{Y} \PYG{n+nb+bp}{→} \PYG{n}{X}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{and.intro} \PYG{n}{a} \PYG{n}{b}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{a}
\end{sphinxVerbatim}


\subsection{or ∨}
\label{\detokenize{A_02_Constructive_Logic:or}}\begin{itemize}
\item {} 
\sphinxAtStartPar
def or\_intro\_left\_rule := (⟦X⟧ i = tt) → (⟦(X ∨ Y)⟧ i = tt)

\item {} 
\sphinxAtStartPar
def or\_intro\_right\_rule := (⟦Y⟧ i = tt) → (⟦(X ∨ Y)⟧ i = tt)

\item {} 
\sphinxAtStartPar
def or\_elim\_rule :=   (⟦(X ∨ Y)⟧ i = tt) → (⟦(X => Z)⟧ i = tt) → (⟦(Y => Z)⟧ i = tt) → (⟦(Z)⟧ i = tt)

\end{itemize}

\sphinxAtStartPar
Just as with ∧, the ∨ connective in Lean is represented as
a logical type, polymorphic in two propositional arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{or} \PYG{o}{(}\PYG{n}{A} \PYG{n}{B} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)} \PYG{o}{:} \PYG{k+kt}{Prop}
\PYG{n+nb+bp}{|} \PYG{n}{inl} \PYG{o}{(}\PYG{n}{h} \PYG{o}{:} \PYG{n}{A}\PYG{o}{)} \PYG{o}{:} \PYG{n}{or}
\PYG{n+nb+bp}{|} \PYG{n}{inr} \PYG{o}{(}\PYG{n}{h} \PYG{o}{:} \PYG{n}{B}\PYG{o}{)} \PYG{o}{:} \PYG{n}{or}
\PYG{k+kd}{end} \PYG{n}{hidden}
\end{sphinxVerbatim}

\sphinxAtStartPar
But whereas the intended meaning of ∧ is that each of two
given propositions has a proof, the intended meaning of ∨
is that \sphinxstyleemphasis{at least one of} the propositions has a proof. This
difference shows up in how proofs of disjunctions are created
and used.


\subsubsection{Introduction Rules}
\label{\detokenize{A_02_Constructive_Logic:introduction-rules}}
\sphinxAtStartPar
We now have two constructors. The first, \sphinxstyleemphasis{or.inl}, constructs
a proof of \sphinxstyleemphasis{A ∨ B} from a proof, (a : A). The second, \sphinxstyleemphasis{or.inr},
constructs a proof of \sphinxstyleemphasis{A ∨ B} from a proof of \sphinxstyleemphasis{B}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Example using a lambda expression. Be sure you understand it.}
\PYG{k+kd}{example} \PYG{o}{(}\PYG{n}{A} \PYG{n}{B} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)} \PYG{o}{:} \PYG{n}{A} \PYG{n+nb+bp}{→} \PYG{n}{A} \PYG{n+nb+bp}{∨} \PYG{n}{B} \PYG{o}{:=} \PYG{k}{fun} \PYG{o}{(}\PYG{n}{a} \PYG{o}{:} \PYG{n}{A}\PYG{o}{)}\PYG{o}{,} \PYG{n}{or.inl} \PYG{n}{a}
\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{O}\PYG{c+cm}{k}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{y}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{ }\PYG{c+cm}{m}\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{h}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{I}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{l}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{d}
\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{:}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{m}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{s}
\PYG{c+cm}{w}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{∀}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{g}\PYG{c+cm}{h}\PYG{c+cm}{t}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{Y}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{y}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{o}\PYG{c+cm}{.}
\PYG{c+cm}{A}\PYG{c+cm}{l}\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{d}\PYG{c+cm}{o}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{a}\PYG{c+cm}{*}\PYG{c+cm}{m}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{s}\PYG{c+cm}{u}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{f}
\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{A}\PYG{c+cm}{*}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{h}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{u}\PYG{c+cm}{i}\PYG{c+cm}{l}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{A}\PYG{c+cm}{ }\PYG{c+cm}{∨}\PYG{c+cm}{ }\PYG{c+cm}{B}\PYG{c+cm}{*}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{T}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{s}
\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\end{sphinxVerbatim}


\subsubsection{Elimination Rules}
\label{\detokenize{A_02_Constructive_Logic:elimination-rules}}
\sphinxAtStartPar
How do we use a proof of a conjunction, \sphinxstyleemphasis{A ∨ B}? In general,
what you’ll want to show is that if you have a proof, h, of
\sphinxstyleemphasis{A ∨ B}  then you can obtain a proof of a goal proposition,
let’s call it C.

\sphinxAtStartPar
The proof is constructed by case analysis on h. As \sphinxstyleemphasis{(h : A ∨ B)}
(read that as \sphinxstyleemphasis{h is a proof of A ∨ B}), there are two cases that
we have to consider: \sphinxstyleemphasis{h} could be \sphinxstyleemphasis{or.inl a}, where \sphinxstyleemphasis{(a : A)}, or
\sphinxstyleemphasis{h} could be \sphinxstyleemphasis{or.inr b}, where \sphinxstyleemphasis{(b : B).}

\sphinxAtStartPar
But that’s not yet enough to prove \sphinxstyleemphasis{C}. In addition, we’ll need
proofs that \sphinxstyleemphasis{A → C} and \sphinxstyleemphasis{B → C}. In other words, to show that
\sphinxstyleemphasis{A ∨ B → C}, we need to show that that true \sphinxstyleemphasis{in either case} in
a case analysis of a proof of \sphinxstyleemphasis{A ∨ B}. The elimination rule for
∨ is thus akin to what we saw in propositional logic.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} or.elim : ∀ \PYGZob{}a b c : Prop\PYGZcb{}, a ∨ b → (a → c) → (b → c) → c}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} deduce c from proofs of a ∨ b, a → c, and b → c,}
\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{@}\PYG{n}{or.elim}

\PYG{k+kd}{example} \PYG{o}{(}\PYG{n}{P} \PYG{n}{Q} \PYG{n}{R} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)} \PYG{o}{:} \PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{n}{Q} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{→} \PYG{n}{R}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{Q} \PYG{n+nb+bp}{→} \PYG{n}{R}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{R}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{or.inl} \PYG{n}{p}\PYG{o}{)} \PYG{n}{pr} \PYG{n}{qr} \PYG{o}{:=} \PYG{n}{pr} \PYG{n}{p}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{or.inr} \PYG{n}{q}\PYG{o}{)} \PYG{n}{pr} \PYG{n}{qr} \PYG{o}{:=} \PYG{n}{qr} \PYG{n}{q}
\end{sphinxVerbatim}


\subsubsection{Examples}
\label{\detokenize{A_02_Constructive_Logic:examples}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{P} \PYG{n}{Q}\PYG{o}{,} \PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{n}{Q} \PYG{n+nb+bp}{→} \PYG{n}{Q} \PYG{n+nb+bp}{∨} \PYG{n}{P} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{P} \PYG{n}{Q} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h} \PYG{k}{with} \PYG{n}{p} \PYG{n}{q}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{or.inr} \PYG{n}{p}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{or.inl} \PYG{n}{q}\PYG{o}{,}
\PYG{k+kd}{end}


\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{P} \PYG{n}{Q} \PYG{n}{R}\PYG{o}{,} \PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{Q} \PYG{n+nb+bp}{∨} \PYG{n}{R}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{n}{Q}\PYG{o}{)} \PYG{n+nb+bp}{∨} \PYG{n}{R} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{P} \PYG{n}{Q} \PYG{n}{R} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h} \PYG{k}{with} \PYG{n}{p} \PYG{n}{qr}\PYG{o}{,}
\PYG{n}{left}\PYG{n+nb+bp}{;} \PYG{n}{left}\PYG{n+nb+bp}{;} \PYG{n}{assumption}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{qr} \PYG{k}{with} \PYG{n}{q} \PYG{n}{r}\PYG{o}{,}
\PYG{n}{left}\PYG{n+nb+bp}{;} \PYG{n}{exact} \PYG{n}{or.inr} \PYG{n}{q}\PYG{o}{,}
\PYG{n}{right}\PYG{n+nb+bp}{;} \PYG{n}{assumption}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{not (¬)}
\label{\detokenize{A_02_Constructive_Logic:not}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} ¬¬X ⊢ X                 \PYGZhy{}\PYGZhy{} negation elimination}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} X → ⊥ ⊢ ¬X             \PYGZhy{}\PYGZhy{} negation introduction}
\end{sphinxVerbatim}


\subsubsection{Introduction}
\label{\detokenize{A_02_Constructive_Logic:id1}}
\sphinxAtStartPar
We saw in propositional logic that if \sphinxstyleemphasis{X → false} then
\sphinxstyleemphasis{X} must be false. That’s easy to see: \sphinxstyleemphasis{true → false} is
false, so \sphinxstyleemphasis{X} can’t be \sphinxstyleemphasis{true}. On the other hand, \sphinxstyleemphasis{false
→ false} is true. \sphinxstyleemphasis{X} can only be \sphinxstyleemphasis{false}. Now, saying \sphinxstyleemphasis{X
is false} in propositional logic is equivalent to saying
¬X is true, giving us our constructive ¬ introduction rule:
X → ⊥ ⊢ ¬X. This is the rule of ¬ introduction: to prove
\sphinxstyleemphasis{¬X} it will suffice to prove \sphinxstyleemphasis{X → false}.

\sphinxAtStartPar
The same idea reappears in the constructive logic of Lean.
In fact, Lean simply \sphinxstyleemphasis{defines} \sphinxstyleemphasis{¬X} to mean \sphinxstyleemphasis{X → false.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} def not (a : Prop) := a → false}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} prefix `¬`:40 := not}
\PYG{k}{\PYGZsh{}check} \PYG{n}{not}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{¬} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{show} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1} \PYG{n+nb+bp}{→} \PYG{n}{false}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s think about what \sphinxstyleemphasis{a → false} means, where \sphinxstyleemphasis{a} is any
proposition. In Lean, a proof of an implication is a function,
namely one that would turn \sphinxstyleemphasis{any} proof of \sphinxstyleemphasis{a} into a proof of
false. So, \sphinxstyleemphasis{if there were} a proof of \sphinxstyleemphasis{a} then one could have
a proof of \sphinxstyleemphasis{false.} That can’t happen because there is no proof
of false. So there must be no proof of \sphinxstyleemphasis{a}. Therefore \sphinxstyleemphasis{a} is
false, and we can write that as \sphinxstyleemphasis{¬a}.

\sphinxAtStartPar
To prove a proposition, \sphinxstyleemphasis{¬a}, we thus just have to prove that
\sphinxstyleemphasis{a → false}. To do this, we assume we have a proof of \sphinxstyleemphasis{a} and
show that that leads to an impossibility, which shows that the
assumption was wrong, thus \sphinxstyleemphasis{¬a} must be true. You can pronounce
\sphinxstyleemphasis{¬a} as \sphinxstyleemphasis{not a} or \sphinxstyleemphasis{a is false}, but it can also help to think
of it as saying \sphinxstyleemphasis{there provably can be no proof of a.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1} \PYG{n+nb+bp}{→} \PYG{n}{false} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{¬} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{≠} \PYG{l+m+mi}{1} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsubsection{Elimination}
\label{\detokenize{A_02_Constructive_Logic:elimination}}
\sphinxAtStartPar
In propositional logic, we have the rule of (double) negation
elimination: \sphinxstyleemphasis{¬¬X → X}. An easy way to think about this is that
two negations cancel out: negation is an involution. As we’ll
now see, this rule is also defines proof by contradiction.

\sphinxAtStartPar
To see that, one can read the rule as saying that to prove \sphinxstyleemphasis{X}
it will suffice to assume \sphinxstyleemphasis{¬X} and show that that leads to a
a contradiction, thus proving that \sphinxstyleemphasis{¬X} is false, thus \sphinxstyleemphasis{¬¬X}.
From there in classical logic it’s just a final step to \sphinxstyleemphasis{X}.

\sphinxAtStartPar
Is this inference rule valid in Lean? Let’s try to prove that
it is. Our goal is to prove ∀ X, ¬¬X → X. We first rewrite the
inner \sphinxstyleemphasis{¬X} on the left of the → as \sphinxstyleemphasis{(X → false)}. \sphinxstyleemphasis{¬¬X} becomes
\sphinxstyleemphasis{¬(X → false)}. Rewriting again gives \sphinxstyleemphasis{(X → false) → false.}
Our goal, then, is to prove ((X → false) → false) → X. We get
a start by assuming (h : (X → false) → false), but then find
that from \sphinxstyleemphasis{h} there’s no way to squeeze out a proof of \sphinxstyleemphasis{X}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{X} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)}\PYG{o}{,} \PYG{n+nb+bp}{¬}\PYG{n+nb+bp}{¬}\PYG{n}{X} \PYG{n+nb+bp}{→} \PYG{n}{X} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{X} \PYG{n}{h}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} can\PYGZsq{}t do case analysis on a function}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} we\PYGZsq{}re stuck with nowhere left to go!}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
What we’ve found then is that (double) negation elimination,
and thus proof by contradiction, is not valid in Lean (or in
similar constructive logic proof assistants). This shows that
in Lean a proposition, \sphinxstyleemphasis{X}, being proved \sphinxstyleemphasis{not false} (\sphinxstyleemphasis{¬¬X})
does not imply that \sphinxstyleemphasis{X} is true. From a proof of the former we
can’t obtain a proof of the latter. From a proof that \sphinxstyleemphasis{¬X is
false} we have no way to derive a proof of \sphinxstyleemphasis{X}.


\subsubsection{Constructive vs. Classical}
\label{\detokenize{A_02_Constructive_Logic:constructive-vs-classical}}
\sphinxAtStartPar
In constructive logic, a proposition can thus be provably true
(by a proof), it can be provably false (by a proof that there is
no proof of it), or it can be provably not false, which is to
say that there must exist a proof, but where one cannot be
constructed from the given premise alone.

\sphinxAtStartPar
We’ll see the the same constructivity requirement again when we
discuss proofs of existence. In a nutshell, a constructive proof
exhibits a specific “witness” to show that one does exist. To be
constructive means that a proof of existence requires an actual
witness.

\sphinxAtStartPar
With respect to negation elimination, it’s not enough to know
that there’s an unspecified proof of \sphinxstyleemphasis{X} “out there.” To know
that \sphinxstyleemphasis{X} is true/valid, one has to \sphinxstyleemphasis{exhibit} such a proof: to
have one in hand, that can actually be inspected and verified.

\sphinxAtStartPar
Consider \sphinxstyleemphasis{em} again. Given any proposition, \sphinxstyleemphasis{X}, \sphinxstyleemphasis{(em X)} is
a proof of \sphinxstyleemphasis{X ∨ ¬X}. Now consider the introduction rules for
∨ in constructive logic: to construct a proof of \sphinxstyleemphasis{X} you have
to have either a proof of \sphinxstyleemphasis{X} or a proof of \sphinxstyleemphasis{¬X} in hand. The
\sphinxstyleemphasis{em} axiom gives you a proof of \sphinxstyleemphasis{X ∨ ¬X} without requiring a
proof of either disjunction. It’s thus non\sphinxhyphen{}constructive.

\sphinxAtStartPar
Classical logic and mathematics do not adopt the constraint
of constructivity, and consequently there are theorems that
can be proved in classical mathematics but not in constructive
mathematics. Again, it’s easy to turn Lean classical simply
by opening the classical namespace (the accepted signal that
one will admit classical reasoning) and using \sphinxstyleemphasis{em} in your
proofs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A proof of 0 = 0 by contradition}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{0} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{by\PYGZus{}contradiction}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} applies ¬¬P → P}
\PYG{k}{have} \PYG{n}{eq0} \PYG{o}{:=} \PYG{n}{eq.refl} \PYG{l+m+mi}{0}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsubsection{Excluded Middle}
\label{\detokenize{A_02_Constructive_Logic:excluded-middle}}
\sphinxAtStartPar
We’ve seen that in \sphinxstyleemphasis{constructive} logic, knowing that it’s
false that there’s no proof is not the same as, and is weaker
than, actually having a proof. Knowing that a proposition is
not false is not the same as actually having a proof in hand.
What makes constructive logic constructive is that a proof is
required to judge a proposition as being true.

\sphinxAtStartPar
In classical predicate and propositional logic, by contrast,
negation elimination is an axiom. To prove a proposition, \sphinxstyleemphasis{X},
by contradiction, one assumes \sphinxstyleemphasis{¬X}, shows that from that one
can derive a contradiction, thus proving \sphinxstyleemphasis{¬¬X}, and from there
(here it comes) by negation elimination one finally concludes
\sphinxstyleemphasis{X}, thereby satisfying the original goal.

\sphinxAtStartPar
In summary, negation elimination is not an axiom in constructive
logic, so any proof that relies on \sphinxstyleemphasis{∀ X, ¬¬X → X} gets blocked at
this point. The reason it’s not an axiom is that it would make
the logic non\sphinxhyphen{}constructive: while a proof that X is not false
might suggest that there exists a proof of X, it does not give
you such a proof, which is what constructive logic requires.

\sphinxAtStartPar
In constructive logic there are not just two truth states
for any proposition. We’ve seen that we can know that a
proposition is true (by having a proof of it), know that
it is false (by having a proof it entails a contradiction),
and know that it’s not false but without having constructed
a proof that it’s true. We can know that something is not
false without having a proof of it, and without a proof we
can’t judge it to be true, either.

\sphinxAtStartPar
In classical logic, the \sphinxstyleemphasis{axiom (“law”) of the excluded middle}
rules out this middle possibility, declaring as an assumption
that for any given proposition, P, there is a proof of P ∨ ¬P.

\sphinxAtStartPar
This axiom then enables proof by contradiction. That’s an easy
proof. We need to prove that if \sphinxstyleemphasis{P ∨ ¬ P} then \sphinxstyleemphasis{¬¬P → P}. The
proof is by case analysis on an assumped proof of \sphinxstyleemphasis{P ∨ ¬ P}.
In the first case, we assume a proof of P, so the implication
is true trivially. In the case where we have a proof of ¬P, we
have a contradiction between ¬P and ¬¬P, and so this case can’t
actually arise and needn’t be considered any further.

\sphinxAtStartPar
In Lean, you can declare anything you want to be an additional
axiom. If you’re careless, you will make the logic inconsistent
and thus useless. For example, don’t assume \sphinxstyleemphasis{true ↔ false}. On
the other hand, you may add any axiom that is independent of the
given ones and you’ll still have a consistent logic in which
propositions that lack proofs in constructive logic now have
proofs.

\sphinxAtStartPar
The law of the excluded middle, \sphinxstyleemphasis{∀ P, P ∨ ¬P} is declared as an
\sphinxstyleemphasis{axiom} in the \sphinxstyleemphasis{classical} namespace, where \sphinxstyleemphasis{classical.em} (or
just \sphinxstyleemphasis{em} if you \sphinxstyleemphasis{open classical}) is assumed to be a proof of
\sphinxstyleemphasis{em : ∀ P, P ∨ ¬P}.

\sphinxAtStartPar
Now the key to understanding the power of excluded middle is
that it allows you to do case analysis on any \sphinxstyleemphasis{proposition} in
our otherwise constructive logic. How’s that? Assume \sphinxstyleemphasis{X} is an
arbitrary proposition. Then \sphinxstyleemphasis{(em X)} is a proof of X ∨ ¬X.

\sphinxAtStartPar
Note that \sphinxstyleemphasis{em}, being universally quantified is essentially
a function. It can be \sphinxstyleemphasis{applied} to yield a specific instance
of the general rule. Ok, so what can we do with a “free proof”
of \sphinxstyleemphasis{X ∨ ¬X}? Case analysis! There will be just two cases. In
the first case, we’d have a proof of \sphinxstyleemphasis{X}. In the second, we’d
have a proof of \sphinxstyleemphasis{¬X}. And those are the only cases that need
to be considered.


\subsubsection{Examples}
\label{\detokenize{A_02_Constructive_Logic:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{@}\PYG{n}{classical.em}

\PYG{k+kd}{theorem} \PYG{n}{foo} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{P}\PYG{o}{,} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{¬} \PYG{n}{P}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n+nb+bp}{¬}\PYG{n+nb+bp}{¬}\PYG{n}{P} \PYG{n+nb+bp}{→} \PYG{n}{P}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{P}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{em}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{notNotP}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{em}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} case 1}
\PYG{n}{assumption}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{0} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{by\PYGZus{}contradiction}\PYG{o}{,}
\PYG{k}{have} \PYG{n}{zez} \PYG{o}{:=} \PYG{n}{eq.refl} \PYG{l+m+mi}{0}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{theorem} \PYG{n}{demorgan1} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{P} \PYG{n}{Q}\PYG{o}{,} \PYG{n+nb+bp}{¬}\PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{∧} \PYG{n}{Q}\PYG{o}{)} \PYG{n+nb+bp}{↔} \PYG{o}{(}\PYG{n+nb+bp}{¬}\PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{n+nb+bp}{¬} \PYG{n}{Q}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{P} \PYG{n}{Q}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}apply iff.intro \PYGZus{} \PYGZus{},}
\PYG{n}{split}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} FORWARD}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}


\PYG{k}{have} \PYG{n}{ponp} \PYG{o}{:=} \PYG{n}{classical.em} \PYG{n}{P}\PYG{o}{,}
\PYG{k}{have} \PYG{n}{qonq} \PYG{o}{:=} \PYG{n}{classical.em} \PYG{n}{Q}\PYG{o}{,}

\PYG{n}{cases} \PYG{n}{ponp} \PYG{k}{with} \PYG{n}{p} \PYG{n}{np}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{qonq} \PYG{k}{with} \PYG{n}{q} \PYG{n}{nq}\PYG{o}{,}
\PYG{k}{have} \PYG{n}{pandq} \PYG{o}{:=} \PYG{n}{and.intro} \PYG{n}{p} \PYG{n}{q}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}

\PYG{n}{apply} \PYG{n}{or.inr} \PYG{n}{nq}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{or.inl} \PYG{n}{np}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} BACKWARDS}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}

\PYG{k}{assume} \PYG{n}{pandq}\PYG{o}{,}
\PYG{k}{have} \PYG{n}{p} \PYG{o}{:=} \PYG{n}{and.elim\PYGZus{}left} \PYG{n}{pandq}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} cases pandq with p q,}
\PYG{n}{contradiction}\PYG{o}{,}

\PYG{k}{assume} \PYG{n}{pandq}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{pandq} \PYG{k}{with} \PYG{n}{p} \PYG{n}{q}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}

\PYG{k+kd}{end}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{P} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)}\PYG{o}{,} \PYG{n+nb+bp}{¬} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{∧} \PYG{n+nb+bp}{¬}\PYG{n}{P}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{P}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h} \PYG{k}{with} \PYG{n}{p} \PYG{n}{np}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{false.elim} \PYG{o}{(}\PYG{n}{np} \PYG{n}{p}\PYG{o}{)}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{P} \PYG{n}{Q} \PYG{n}{R}\PYG{o}{,} \PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{o}{(}\PYG{n}{Q} \PYG{n+nb+bp}{∧} \PYG{n}{R}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{n}{Q}\PYG{o}{)} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{∨} \PYG{n}{R}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{P} \PYG{n}{Q} \PYG{n}{R}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{and.intro} \PYG{n}{\PYGZus{}} \PYG{n}{\PYGZus{}}\PYG{o}{,}

\PYG{n}{cases} \PYG{n}{h} \PYG{k}{with} \PYG{n}{p} \PYG{n}{qandr}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{or.inl} \PYG{n}{p}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{qandr} \PYG{k}{with} \PYG{n}{q} \PYG{n}{r}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{or.inr} \PYG{n}{q}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{or.inl} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{exact} \PYG{o}{(}\PYG{n}{or.inr} \PYG{n}{h\PYGZus{}right}\PYG{o}{)}

\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsubsection{Exercises}
\label{\detokenize{A_02_Constructive_Logic:exercises}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Give a formal proof of the claim that excluded middle implies proof by contradiction.

\item {} 
\sphinxAtStartPar
Determine whether, and if so prove, that the two statements are equivalent: excluded middle and proof by contradiction.

\item {} 
\sphinxAtStartPar
Try to Prove each of DeMorgan’s laws in Lean to identify the non\sphinxhyphen{}constructive ones

\item {} 
\sphinxAtStartPar
Finish the proofs of DeMorgan’s laws using the axiom of the excluded middle \sphinxstyleemphasis{(em)}.

\end{enumerate}


\subsection{iff ↔}
\label{\detokenize{A_02_Constructive_Logic:iff}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 13. X → Y, Y → X ⊢ X ↔ Y   \PYGZhy{}\PYGZhy{} iff introduction}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 14. X ↔ Y ⊢ X → Y          \PYGZhy{}\PYGZhy{} iff elimination left}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} 15. X ↔ Y ⊢ Y → X          \PYGZhy{}\PYGZhy{} iff elimination right}
\end{sphinxVerbatim}

\sphinxAtStartPar
We want \sphinxstyleemphasis{P ↔ Q} to be equivalent to (P → Q) ∧ (Q → P).

\sphinxAtStartPar
The
introduction rule, \sphinxstyleemphasis{iff.intro,} like \sphinxstyleemphasis{and.intro}, thus
takes two implications proofs, one in each direction and
yields a proof of the biimplication.

\sphinxAtStartPar
The \sphinxstyleemphasis{iff} left and right elimination rules are similarly akin
to those for \sphinxstyleemphasis{and}: from a proof, \sphinxstyleemphasis{h : P ↔ Q}, they derive
proofs of the respective forwards and backwards implications,
\sphinxstyleemphasis{P → Q} and \sphinxstyleemphasis{Q → P}. Such proofs are functions, and thus can
be applied to arguments in subsequent proofs steps.

\sphinxAtStartPar
The names of the \sphinxstyleemphasis{iff} left and right elimination rules in
Lean are \sphinxstyleemphasis{iff.mp} and \sphinxstyleemphasis{iff.mpr.} Case analysis on a proof,
\sphinxstyleemphasis{h : P ↔ Q,} using the \sphinxstyleemphasis{cases} tactic, will derive proofs of
both implications at once.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{(}\PYG{n}{P} \PYG{n}{Q} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{)} \PYG{o}{:} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{↔} \PYG{n}{Q}\PYG{o}{)} \PYG{n+nb+bp}{↔} \PYG{o}{(}\PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{→} \PYG{n}{Q}\PYG{o}{)} \PYG{n+nb+bp}{∧} \PYG{o}{(}\PYG{n}{Q} \PYG{n+nb+bp}{→} \PYG{n}{P}\PYG{o}{)}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{split}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} FORWARD}
\PYG{k}{assume} \PYG{n}{piffq}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{piffq} \PYG{k}{with} \PYG{n}{pq} \PYG{n}{qp}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{and.intro} \PYG{n}{pq} \PYG{n}{qp}\PYG{o}{,}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} BACKWARD}
\PYG{k}{assume} \PYG{n}{pqqp}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{pqqp} \PYG{k}{with} \PYG{n}{pq} \PYG{n}{qp}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{iff.intro} \PYG{n}{pq} \PYG{n}{qp}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}


\subsection{Conclusion}
\label{\detokenize{A_02_Constructive_Logic:conclusion}}
\sphinxAtStartPar
In this section you’ve encountered analogs in
higher\sphinxhyphen{}order logic of the reasoning principles
that you saw (in weaker forms) in propositional
logic, but now as rules for and expressed in a
higher\sphinxhyphen{}order predicae logic itself embedded in
the higher\sphinxhyphen{}order logic of Lean.

\sphinxAtStartPar
Just as we ourselves specified an embedding
of propositional logic in Lean, so the Lean
library authors have given us a higher\sphinxhyphen{}order
predicate logic embedded in Lean. We have
already met propositions as types in Prop,
functions, predicates as functions to Prop.
We know the inference rules.

\sphinxAtStartPar
But what we’ve not yet met formally are the
quantifiers of predicate logic (higher\sphinxhyphen{}order or
not), ∀ and ∃. In Lean, these quantifiers are
represented using \sphinxstyleemphasis{dependent types}. In the
next chapter we take up these topics,

\sphinxstepscope


\chapter{Recursive Types}
\label{\detokenize{A_03_Recursive_Types:recursive-types}}\label{\detokenize{A_03_Recursive_Types:introduction}}\label{\detokenize{A_03_Recursive_Types::doc}}

\section{Introduction}
\label{\detokenize{A_03_Recursive_Types:id1}}
\sphinxAtStartPar
In this chapter we’ll look at inductive data types
definitions that specify objects that have recursive
structure. In particular, we’ll look at the \sphinxstyleemphasis{nat} and
polymorphic \sphinxstyleemphasis{list} types, with an eye to seeing some
interesting algebraic commonalities.


\section{Natural Numbers}
\label{\detokenize{A_03_Recursive_Types:natural-numbers}}

\subsection{Data Type}
\label{\detokenize{A_03_Recursive_Types:data-type}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{nat}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} notations for writing succ applications}
\PYG{k+kd}{def} \PYG{n}{three\PYGZsq{}}  \PYG{o}{:=} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{o}{(}\PYG{n}{nat.zero}\PYG{o}{)}\PYG{o}{)}\PYG{o}{)}\PYG{o}{)}
\PYG{k+kd}{def} \PYG{n}{three}  \PYG{o}{:=} \PYG{n}{nat.zero.succ.succ.succ}
\end{sphinxVerbatim}


\subsection{Operations}
\label{\detokenize{A_03_Recursive_Types:operations}}
\sphinxAtStartPar
Having seen how the \sphinxstyleemphasis{nat} data type is defined, we now look
at how to define functions taking \sphinxstyleemphasis{nat} values as arguments.
As we’ve seen before, many such functions here will again be
defined by case analysis on an incoming nat argument value.
That means considering two cases separately: the incoming value
is either zero or non\sphinxhyphen{}zero: that is, either \sphinxstyleemphasis{nat.zero,} or
\sphinxstyleemphasis{nat.succ n’} for some “one\sphinxhyphen{}smaller” value, \sphinxstyleemphasis{n’}. For example,
if the incoming argument is \sphinxstyleemphasis{succ(succ(succ zero))}, i.e., 3,
then (a) it does not match \sphinxstyleemphasis{nat.zero}, but (b) it does match
\sphinxstyleemphasis{nat.succ n’}, with \sphinxstyleemphasis{n’} is bound to \sphinxstyleemphasis{succ(succ zero)}, i.e., 2.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} increment is just succ application}
\PYG{k+kd}{def} \PYG{n}{inc} \PYG{o}{(}\PYG{n}{n\PYGZsq{}} \PYG{o}{:} \PYG{n}{nat}\PYG{o}{)} \PYG{o}{:} \PYG{n}{nat} \PYG{o}{:=} \PYG{n}{n\PYGZsq{}.succ}
\PYG{k+kd}{def} \PYG{n}{three\PYGZsq{}\PYGZsq{}} \PYG{o}{:=} \PYG{n}{inc}\PYG{o}{(}\PYG{n}{inc}\PYG{o}{(}\PYG{n}{inc} \PYG{n}{nat.zero}\PYG{o}{)}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
A predecessor (one less than) function can be defined by
case analysis on a nat argument. Here we’ll define \sphinxstyleemphasis{pred’}
to return 0 when applied to 0, and otherwise to return the
one smaller value, \sphinxstyleemphasis{n’}, when applied to any non\sphinxhyphen{}zero value,
\sphinxstyleemphasis{nat.succ n’}.

\sphinxAtStartPar
Rather than “implementing a function” think “proving a function
type.” A “proof” of function type, \sphinxstyleemphasis{nat → nat,} is any function
that converts any given nat into some resulting nat.

\sphinxAtStartPar
When proving a proposition (a type in Prop), any proof (value
of that type) will do. When proving function or other data type,
however, the particular value of the type that you construct is
usually important. Here, for example, we don’t want any function
that takes and returns a nat, but one that returns the right nat
for the given argument.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{pred\PYGZsq{}} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{n}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{n} \PYG{k}{with} \PYG{n}{n\PYGZsq{}}\PYG{o}{,}
\PYG{n}{exact} \PYG{l+m+mi}{0}\PYG{o}{,}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} when n is zero}
\PYG{n}{exact} \PYG{n}{n\PYGZsq{}}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} when n is succ n\PYGZsq{}}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} quick test}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{pred\PYGZsq{}} \PYG{l+m+mi}{6}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{pred\PYGZsq{}} \PYG{l+m+mi}{6} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{5} \PYG{o}{:=} \PYG{n}{rfl}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here’s the same function just specified
using pattern matching notation (which,
as we’ve seen generalizes case analysis).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{pred} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{nat.zero} \PYG{o}{:=} \PYG{n}{nat.zero}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} loop at zero}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{n}{n\PYGZsq{}}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{n\PYGZsq{}}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{pred} \PYG{l+m+mi}{5}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{pred} \PYG{l+m+mi}{5} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{4} \PYG{o}{:=} \PYG{n}{rfl}
\end{sphinxVerbatim}

\sphinxAtStartPar
Pattern matching generalizes case analysis
by giving you a means to return different
results based on deeper analysis of argument
structures using pattern matching/unification.
This example implements subtract\sphinxhyphen{}two, looping
at zero. Notice how the third pattern matches
to the sub\sphinxhyphen{}natural\sphinxhyphen{}number object nested two
succ\sphinxhyphen{}levels deep.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} this example illustrates pattern matching}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} for more fine\PYGZhy{}grained case analysis}
\PYG{k+kd}{def} \PYG{n}{sub2} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{nat.zero} \PYG{o}{:=} \PYG{n}{nat.zero}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{n}{nat.zero}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{nat.zero}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{n}{n\PYGZsq{}}\PYG{o}{)}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{n\PYGZsq{}}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} addition increments the second argument}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} the first argument number of times}
\PYG{k+kd}{def} \PYG{n}{plus} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{nat.zero} \PYG{n}{m} \PYG{o}{:=} \PYG{n}{m}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{n}{n\PYGZsq{}}\PYG{o}{)} \PYG{n}{m} \PYG{o}{:=} \PYG{n}{nat.succ} \PYG{o}{(}\PYG{n}{plus} \PYG{n}{n\PYGZsq{}} \PYG{n}{m}\PYG{o}{)}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{plus} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} multiplication adds the second argument}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} to itself the first argumen number of times}
\PYG{k+kd}{def} \PYG{n}{times} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{l+m+mi}{0} \PYG{n}{m} \PYG{o}{:=} \PYG{l+m+mi}{0}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{n\PYGZsq{}}\PYG{n+nb+bp}{+}\PYG{l+m+mi}{1}\PYG{o}{)} \PYG{n}{m} \PYG{o}{:=} \PYG{n}{plus} \PYG{n}{m} \PYG{o}{(}\PYG{n}{times} \PYG{n}{n\PYGZsq{}} \PYG{n}{m}\PYG{o}{)}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{times} \PYG{l+m+mi}{5} \PYG{l+m+mi}{4}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{times} \PYG{l+m+mi}{1} \PYG{l+m+mi}{20}


\PYG{c+c1}{\PYGZhy{}\PYGZhy{} substraction illustrates case analysis on}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} multiple (here two) arguments at once}
\PYG{k+kd}{def} \PYG{n}{subtract} \PYG{o}{:}  \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{l+m+mi}{0} \PYG{n}{\PYGZus{}} \PYG{o}{:=} \PYG{l+m+mi}{0}
\PYG{n+nb+bp}{|} \PYG{n}{n} \PYG{l+m+mi}{0} \PYG{o}{:=} \PYG{n}{n}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{n\PYGZsq{}} \PYG{n+nb+bp}{+} \PYG{l+m+mi}{1}\PYG{o}{)} \PYG{o}{(}\PYG{n}{m\PYGZsq{}} \PYG{n+nb+bp}{+} \PYG{l+m+mi}{1}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{subtract} \PYG{n}{n\PYGZsq{}} \PYG{n}{m\PYGZsq{}}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{subtract} \PYG{l+m+mi}{7} \PYG{l+m+mi}{5}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{subtract} \PYG{l+m+mi}{7} \PYG{l+m+mi}{0}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{subtract} \PYG{l+m+mi}{5} \PYG{l+m+mi}{7}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{subtract} \PYG{l+m+mi}{0} \PYG{l+m+mi}{7}


\PYG{c+c1}{\PYGZhy{}\PYGZhy{} exponentiation is multiplication of the second}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} argument by itself the first argument number of times}
\PYG{k+kd}{def} \PYG{n}{power} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{n} \PYG{n}{nat.zero} \PYG{o}{:=} \PYG{l+m+mi}{1}
\PYG{n+nb+bp}{|} \PYG{n}{n} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{n}{m\PYGZsq{}}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{times} \PYG{n}{n} \PYG{o}{(}\PYG{n}{power} \PYG{n}{n} \PYG{n}{m\PYGZsq{}}\PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} a few test cases}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{power} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1} \PYG{o}{:=} \PYG{n}{rfl}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{power} \PYG{l+m+mi}{2} \PYG{l+m+mi}{8} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{256} \PYG{o}{:=} \PYG{n}{rfl}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{power} \PYG{l+m+mi}{2} \PYG{l+m+mi}{10} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{1024} \PYG{o}{:=} \PYG{n}{rfl}
\end{sphinxVerbatim}


\section{Polymorphic Lists}
\label{\detokenize{A_03_Recursive_Types:polymorphic-lists}}

\subsection{Data Type}
\label{\detokenize{A_03_Recursive_Types:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{list}
\end{sphinxVerbatim}

\sphinxAtStartPar
The list data type is surprising similar to the nat
data type. Where as a larger nat is constructed from
only a smaller nat, a larger list is constructed from
a new first element (the \sphinxstyleemphasis{head} of the new list) and
a smaller list (the \sphinxstyleemphasis{tail} of the new list). This type
builder enables us to represent lists of values of any
type and of any finite length.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{universe} \PYG{n}{u}
\PYG{k+kd}{inductive} \PYG{n}{list} \PYG{o}{(}\PYG{n}{T} \PYG{o}{:} \PYG{k+kt}{Type} \PYG{n}{u}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{nil} \PYG{o}{:} \PYG{n}{list}
\PYG{n+nb+bp}{|} \PYG{n}{cons} \PYG{o}{(}\PYG{n}{hd} \PYG{o}{:} \PYG{n}{T}\PYG{o}{)} \PYG{o}{(}\PYG{n}{tl} \PYG{o}{:} \PYG{n}{list}\PYG{o}{)} \PYG{o}{:} \PYG{n}{list}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} example: let\PYGZsq{}s represent the list of nats, [1,2,3]}
\PYG{k+kd}{def} \PYG{n}{three\PYGZus{}list\PYGZus{}nat\PYGZsq{}\PYGZsq{}} \PYG{o}{:=}
  \PYG{n}{list.cons}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} takes two arguments}
    \PYG{l+m+mi}{1}         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} head of new list}
    \PYG{o}{(}         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} tail list of the new list}
      \PYG{n}{list.cons}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} etc.}
        \PYG{l+m+mi}{2}
        \PYG{o}{(}
          \PYG{n}{list.cons}
            \PYG{l+m+mi}{3}
            \PYG{n}{list.nil}
        \PYG{o}{)}
    \PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} it seems to have worked}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{three\PYGZus{}list\PYGZus{}nat\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{Notations}
\label{\detokenize{A_03_Recursive_Types:notations}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} notation, :: is infix for cons}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} [] notation adds nil at end}
\PYG{k+kd}{def} \PYG{n}{three\PYGZus{}list\PYGZus{}nat\PYGZsq{}\PYGZsq{}\PYGZsq{}} \PYG{o}{:=} \PYG{l+m+mi}{1}\PYG{o}{:}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{o}{:}\PYG{n}{list.nil}
\PYG{k+kd}{def} \PYG{n}{three\PYGZus{}list\PYGZus{}nat\PYGZsq{}\PYGZsq{}\PYGZsq{}\PYGZsq{}} \PYG{o}{:=} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}
\PYG{k+kd}{def} \PYG{n}{four\PYGZus{}list\PYGZus{}nat} \PYG{o}{:=} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{o}{:}\PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} fun!}
\end{sphinxVerbatim}


\subsection{Operations}
\label{\detokenize{A_03_Recursive_Types:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} list prepend analogous to nat increment}
\PYG{k+kd}{def} \PYG{n}{prepend\PYGZsq{}} \PYG{o}{(}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{)} \PYG{o}{(}\PYG{n}{a} \PYG{o}{:} \PYG{n}{α}\PYG{o}{)} \PYG{o}{(}\PYG{n}{l} \PYG{o}{:} \PYG{n}{list} \PYG{n}{α}\PYG{o}{)} \PYG{o}{:=}
  \PYG{n}{list.cons} \PYG{n}{a} \PYG{n}{l}

\PYG{k+kd}{def} \PYG{n}{three\PYGZus{}list\PYGZus{}nat\PYGZsq{}} \PYG{o}{:=}
  \PYG{n}{prepend\PYGZsq{}} \PYG{n}{nat}
    \PYG{l+m+mi}{1}
    \PYG{o}{(}\PYG{n}{prepend\PYGZsq{}} \PYG{n}{nat}
      \PYG{l+m+mi}{2}
      \PYG{o}{(}\PYG{n}{prepend\PYGZsq{}} \PYG{n}{nat}
        \PYG{l+m+mi}{3}
        \PYG{n}{list.nil}
      \PYG{o}{)}
    \PYG{o}{)}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{three\PYGZus{}list\PYGZus{}nat\PYGZsq{}}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} here with an implicit type parameter, making it equivalent to cons}
\PYG{k+kd}{def} \PYG{n}{prepend} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{\PYGZcb{}} \PYG{o}{(}\PYG{n}{a} \PYG{o}{:} \PYG{n}{α}\PYG{o}{)} \PYG{o}{(}\PYG{n}{l} \PYG{o}{:} \PYG{n}{list} \PYG{n}{α}\PYG{o}{)} \PYG{o}{:=}
  \PYG{n}{list.cons} \PYG{n}{a} \PYG{n}{l}

\PYG{k+kd}{def} \PYG{n}{three\PYGZus{}list\PYGZus{}nat} \PYG{o}{:=}
  \PYG{n}{prepend}
    \PYG{l+m+mi}{1}
    \PYG{o}{(}\PYG{n}{prepend}
      \PYG{l+m+mi}{2}
      \PYG{o}{(}\PYG{n}{prepend}
        \PYG{l+m+mi}{3}
        \PYG{n}{list.nil}
      \PYG{o}{)}
    \PYG{o}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} okay, that looks good}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} but know that to which it desugars}

\PYG{k+kd}{example} \PYG{o}{:=} \PYG{n}{prepend\PYGZsq{}} \PYG{n}{nat} \PYG{l+m+mi}{2} \PYG{o}{[}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{prepend\PYGZsq{}} \PYG{n}{nat} \PYG{l+m+mi}{2} \PYG{o}{[}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}

\PYG{k+kd}{example} \PYG{o}{:=} \PYG{n}{prepend} \PYG{l+m+mi}{2} \PYG{o}{[}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{prepend} \PYG{l+m+mi}{2} \PYG{o}{[}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}

\PYG{k}{\PYGZsh{}eval} \PYG{l+m+mi}{2}\PYG{o}{:}\PYG{o}{:}\PYG{o}{[}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}
\end{sphinxVerbatim}


\subsection{Partial Functions}
\label{\detokenize{A_03_Recursive_Types:partial-functions}}
\sphinxAtStartPar
Now we face some interesting issues. Our aim is to define
functions that \sphinxstyleemphasis{analyze} lists and return parts of them.
The problem is that there are no parts when a given list
is empty.

\sphinxAtStartPar
When we defined pred, above, we defined pred of zero to be
zero (rather than to be undefined). Doing that makes the
function total and easily represented as a function (lambda
abstractraction) in Lean. However, in a different application
we really might want to define pred 0 to be undefined, not 0.

\sphinxAtStartPar
A similar set of issues arises when we consider head and
tail functions on lists. When given non\sphinxhyphen{}empty lists there
is no problem. But what to do with an empty list argument?
There is no head or tail element to return, yet some value
of the specified type \sphinxstyleemphasis{has to be} returned.

\sphinxAtStartPar
Let’s see some fo the solutions that are available.


\subsubsection{Default Value}
\label{\detokenize{A_03_Recursive_Types:default-value}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} a version of tail that \PYGZdq{}loops at zero\PYGZdq{}}
\PYG{k+kd}{def} \PYG{n}{tail\PYGZsq{}} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{\PYGZcb{}}\PYG{o}{,} \PYG{n}{list} \PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{α}
\PYG{n+nb+bp}{|} \PYG{n}{α} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{list.nil}
\PYG{n+nb+bp}{|} \PYG{n}{α} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{t}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{tail\PYGZsq{}} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
One nice thing about this solution
is that the function type is still about as natural as
can be: list α → list α.


\subsubsection{Option Values}
\label{\detokenize{A_03_Recursive_Types:option-values}}
\sphinxAtStartPar
The next solution changes the type of the function,
so that return value is in the form of a \sphinxstyleemphasis{variant}
type, a value of which is either \sphinxstyleemphasis{none} or \sphinxstyleemphasis{some
valid return value}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{head\PYGZsq{}\PYGZsq{}} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{\PYGZcb{}}\PYG{o}{,} \PYG{n}{list} \PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{option} \PYG{n}{α}
\PYG{n+nb+bp}{|} \PYG{n}{α} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{none}
\PYG{n+nb+bp}{|} \PYG{n}{α} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{some} \PYG{n}{h}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{head\PYGZsq{}\PYGZsq{}} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}
\PYG{k}{\PYGZsh{}eval} \PYG{n+nb+bp}{@}\PYG{n}{head\PYGZsq{}\PYGZsq{}} \PYG{n}{nat} \PYG{o}{[}\PYG{o}{]}
\end{sphinxVerbatim}


\subsubsection{Precondition}
\label{\detokenize{A_03_Recursive_Types:precondition}}
\sphinxAtStartPar
Finally, we can define a version of head’ that (1) typechecks
as being a total function, (2) can never actually be applied
fully to an empty list, in which case (3) no real result has
to be specified to “prove the return type” because such a case
can’t happen. It would be a contradiction if it did, and so it
can be dismissed as an impossibility. Magic: It \sphinxstyleemphasis{is} a total
function, but it can never be fully appied to an empty list
because a required proof argument, for \sphinxstyleemphasis{that} list, can never
be given; so one can dismiss this case by false elimination,
without having to give an actual proof of the conclusion.

\sphinxAtStartPar
Consider a head function. It returns the head element from
a non\sphinxhyphen{}empty list, but is undefined mathematically when it’s
applied to an empty list. The key idea in the next design
is that we can embed a \sphinxstyleemphasis{precondition} for application of
the function, namely that the given list not be empty. Let’s
see how e might first write the function using a tactic
script, to take advantage of your familiarity with using
it to build proofs.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{head\PYGZsq{}} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{\PYGZcb{}} \PYG{o}{(}\PYG{n}{l} \PYG{o}{:} \PYG{n}{list} \PYG{n}{α}\PYG{o}{)}\PYG{o}{,} \PYG{o}{(}\PYG{n}{l} \PYG{n+nb+bp}{≠} \PYG{n}{list.nil}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{α}
\PYG{n+nb+bp}{|}  \PYG{n}{α} \PYG{n}{l} \PYG{n}{p} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{cases} \PYG{n}{l}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{l\PYGZus{}hd}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} When applying it a proof about the first argument has to be given}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{head\PYGZsq{}} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]} \PYG{k+kd}{begin} \PYG{n}{contradiction} \PYG{k+kd}{end}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} proof as a proof script}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{head\PYGZsq{}} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]} \PYG{o}{(}\PYG{k+kd}{by} \PYG{n}{contradiction}\PYG{o}{)}        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} alternative syntax, fyi}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{head\PYGZsq{}} \PYG{o}{(}\PYG{o}{[}\PYG{o}{]} \PYG{o}{:} \PYG{n}{list} \PYG{n}{nat}\PYG{o}{)} \PYG{n}{\PYGZus{}}                 \PYG{c+c1}{\PYGZhy{}\PYGZhy{} you\PYGZsq{}ll need a proof of list.nil ≠ list.nil!}
\end{sphinxVerbatim}


\subsection{Exercises}
\label{\detokenize{A_03_Recursive_Types:exercises}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Write a version of the pred function that can only be called for argument values greater than 0.

\item {} 
\sphinxAtStartPar
Write a version of the pred function that returns an option nat value “in the usual way”

\item {} 
\sphinxAtStartPar
Write a tail function that can only be called with a non\sphinxhyphen{}empty list, using our “by cases” notation for function definition. It should look like tail’. Note 1: Where a proof value is required, you can always use tactic mode to construct the required proof, in a begin..end block. If such a proof is a single tactic long, you can write by <tactic>. For example, try by contradiction as the \sphinxstyleemphasis{result} when your new tail function is applied to an empty list. Here’s how I wrote the function type. You should provide the cases (on l). Here’s the type: def tail \{α : Type\} : ∀ (l : list α), (l ≠ list.nil) → list α.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} implement the function, no need to (do not try) to match on α}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} it\PYGZsq{}s named before the colon and is global to this definition}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} we do want to match (do case analysis) on l, so it\PYGZsq{}s after :}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} def tail \PYGZob{}α : Type\PYGZcb{} : ∀ (l : list α), (l ≠ list.nil) → list α}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} |}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} |}
\end{sphinxVerbatim}


\subsection{Solutions}
\label{\detokenize{A_03_Recursive_Types:solutions}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} let\PYGZsq{}s implement a \PYGZdq{}safe\PYGZdq{} pred function using tactics}
\PYG{k+kd}{def} \PYG{n}{pred\PYGZsq{}} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{nat}\PYG{o}{)}\PYG{o}{,} \PYG{o}{(}\PYG{n}{n} \PYG{n+nb+bp}{≠} \PYG{n}{nat.zero}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{ℕ} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{n}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{n} \PYG{k}{with} \PYG{n}{n\PYGZsq{}}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}
\PYG{n}{exact} \PYG{n}{n\PYGZsq{}}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pred\PYGZsq{}} \PYG{l+m+mi}{5} \PYG{n}{\PYGZus{}}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pred\PYGZsq{}} \PYG{l+m+mi}{2} \PYG{n}{\PYGZus{}}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{pred\PYGZsq{}} \PYG{l+m+mi}{0} \PYG{n}{\PYGZus{}}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} here\PYGZsq{}s the same predecessor function presented differently}
\PYG{k+kd}{def} \PYG{n}{pred\PYGZsq{}\PYGZsq{}} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{nat}\PYG{o}{)}\PYG{o}{,} \PYG{o}{(}\PYG{n}{n} \PYG{n+nb+bp}{≠} \PYG{n}{nat.zero}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{ℕ}
\PYG{n+nb+bp}{|} \PYG{n}{nat.zero} \PYG{n}{h} \PYG{o}{:=} \PYG{k+kd}{by} \PYG{n}{contradiction}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{n}{n\PYGZsq{}}\PYG{o}{)} \PYG{n}{h} \PYG{o}{:=} \PYG{n}{n\PYGZsq{}}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} a different safe predecessor function using an option return}
\PYG{k+kd}{def} \PYG{n}{pred\PYGZsq{}\PYGZsq{}\PYGZsq{}} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{option} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{nat.zero} \PYG{o}{:=} \PYG{n}{option.none}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{n}{n\PYGZsq{}}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{some} \PYG{n}{n\PYGZsq{}}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} the same ideas work for safe head and tail functions on lists}
\PYG{k+kd}{universe} \PYG{n}{u}
\PYG{k+kd}{def} \PYG{n}{tail} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Type} \PYG{n}{u}\PYG{o}{\PYGZcb{}} \PYG{o}{(}\PYG{n}{l} \PYG{o}{:} \PYG{n}{list} \PYG{n}{α}\PYG{o}{)}\PYG{o}{,} \PYG{o}{(}\PYG{n}{l} \PYG{n+nb+bp}{≠} \PYG{n}{list.nil}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{α}
\PYG{n+nb+bp}{|} \PYG{n}{α} \PYG{n}{list.nil} \PYG{n}{p} \PYG{o}{:=} \PYG{k+kd}{by} \PYG{n}{contradiction}
\PYG{n+nb+bp}{|} \PYG{n}{α} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{n}{p} \PYG{o}{:=} \PYG{n}{t}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} apply tail to [1,2,3] giving the proof as a tactic script}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{tail} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{p}\PYG{o}{,}
\PYG{n}{contradiction}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} cleaner this way}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{tail} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]} \PYG{o}{(}\PYG{k+kd}{by} \PYG{n}{contradiction}\PYG{o}{)}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{tail} \PYG{o}{[}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]} \PYG{o}{(}\PYG{k+kd}{by} \PYG{n}{contradiction}\PYG{o}{)}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{tail} \PYG{o}{[}\PYG{l+m+mi}{3}\PYG{o}{]} \PYG{o}{(}\PYG{k+kd}{by} \PYG{n}{contradiction}\PYG{o}{)}
\PYG{k}{\PYGZsh{}eval} \PYG{n+nb+bp}{@}\PYG{n}{tail} \PYG{n}{nat} \PYG{o}{[}\PYG{o}{]} \PYG{o}{(}\PYG{k+kd}{by} \PYG{n}{contradiction}\PYG{o}{)}      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} no can do!}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} let\PYGZsq{}s try it with a tactic script}
\PYG{k}{\PYGZsh{}eval} \PYG{n+nb+bp}{@}\PYG{n}{tail} \PYG{n}{nat} \PYG{o}{[}\PYG{o}{]}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{h}\PYG{o}{,}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} we\PYGZsq{}re stuck, and that\PYGZsq{}s good!}
\PYG{k+kd}{end}


\PYG{c+c1}{\PYGZhy{}\PYGZhy{} append: the list analog of natural number addition}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} please do compare/contrast list.append and nat.add}
\PYG{k+kd}{def} \PYG{n}{appnd} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{\PYGZcb{}} \PYG{o}{:} \PYG{n}{list} \PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{α}
\PYG{n+nb+bp}{|} \PYG{n}{list.nil} \PYG{n}{m} \PYG{o}{:=} \PYG{n}{m}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{n}{m} \PYG{o}{:=} \PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{appnd} \PYG{n}{t} \PYG{n}{m}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{appnd} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]} \PYG{o}{[}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{]}
\end{sphinxVerbatim}


\section{Higher\sphinxhyphen{}Order Functions}
\label{\detokenize{A_03_Recursive_Types:higher-order-functions}}
\sphinxAtStartPar
A higher\sphinxhyphen{}order function is simply a function that
takes functions as arguments and/or that returns a
function as a result.


\subsection{In Logic}
\label{\detokenize{A_03_Recursive_Types:in-logic}}
\sphinxAtStartPar
We’ve already seen this idea in logical reasoning,
where function values are proofs of implications.
In this chapter, we’ll see that same idea in the
realm of computation.

\sphinxAtStartPar
Let’s start by reviewing a logical example to
refresh memories. We’ll review the proof that
\sphinxstyleemphasis{implication is transitive}: if the truth of some
proposition, P, implies the truth of Q, and if the
truth of Q implies the truth of R, then the truth
of P implies that of R. Thinking computationally,
if we have a function, pq, that converts any proof
of P into a proof of Q (a proof of P → Q), and a
function, qr, that converts any proof of Q into a
proof of R (a proof of Q → R), then we can build
a function, pr, that converts any proof, p, of P,
into a proof of R (the desired proof of P → R) by
applying the proof of P → Q to p to get a proof of
Q, and by then applying the proof of Q → R to that
value to get a proof of R. Here it is formally.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{\PYGZob{}}\PYG{n}{P} \PYG{n}{Q} \PYG{n}{R} \PYG{o}{:} \PYG{k+kt}{Prop}\PYG{o}{\PYGZcb{}} \PYG{o}{:} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{→} \PYG{n}{Q}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{Q} \PYG{n+nb+bp}{→} \PYG{n}{R}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{P} \PYG{n+nb+bp}{→} \PYG{n}{R}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{pq} \PYG{n}{qr}\PYG{o}{,}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} assume P → Q and Q → R}
\PYG{k}{assume} \PYG{n}{p}\PYG{o}{,}       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} to show P → R, assume p a proof of P}
\PYG{n}{exact} \PYG{n}{qr} \PYG{o}{(}\PYG{n}{pq} \PYG{n}{p}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} and derive the desired proof of R}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
This proof is a higher\sphinxhyphen{}order function, albeit in the
realm of logic not computation with ordinary data. It
takes two function arguments (one proving of P → Q and
the second proving Q → R) and returns a function that,
by converting any proof of P into a proof of R, proves
P → R. Therefore, (P → Q) → (Q → R) → (P → R). That is,
\sphinxstyleemphasis{implication is transitive}.


\subsection{Composition}
\label{\detokenize{A_03_Recursive_Types:composition}}
\sphinxAtStartPar
What do we get when we construct the same argument not
for proofs of logical propositions but for functions on
ordinary data? What we get is a higher\sphinxhyphen{}order function
that performs \sphinxstyleemphasis{function composition}. Note the change
from Prop (logic) to Type (computation) in the following
definition.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{n}{β} \PYG{n}{γ} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{\PYGZcb{}} \PYG{o}{:} \PYG{o}{(}\PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{β}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{β} \PYG{n+nb+bp}{→} \PYG{n}{γ}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{o}{(}\PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{γ}\PYG{o}{)} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{αβ} \PYG{n}{βγ}\PYG{o}{,}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} assume f g}
\PYG{k}{assume} \PYG{n}{a} \PYG{o}{:} \PYG{n}{α}\PYG{o}{,}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} assume a}
\PYG{n}{exact} \PYG{n}{βγ} \PYG{o}{(}\PYG{n}{αβ} \PYG{n}{a}\PYG{o}{)} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} return λ a, g (f a)}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
Compare and contrast this definition with the statement
and proof of the transitivity of implication. See that
you’ve already been using higher\sphinxhyphen{}order functions albeit
to reason with functions that serve as proofs of logical
implications, rather than with with functions on ordinary
data.

\sphinxAtStartPar
Let’s write this definition a little more naturally,
and give it a name: \sphinxstyleemphasis{comp}, short for  \sphinxstyleemphasis{composition}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{comp} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{n}{β} \PYG{n}{γ} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{\PYGZcb{}} \PYG{o}{(}\PYG{n}{f} \PYG{o}{:} \PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{β}\PYG{o}{)} \PYG{o}{(}\PYG{n}{g} \PYG{o}{:} \PYG{n}{β} \PYG{n+nb+bp}{→} \PYG{n}{γ}\PYG{o}{)} \PYG{o}{:} \PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{γ} \PYG{o}{:=}
\PYG{k}{fun} \PYG{o}{(}\PYG{n}{a} \PYG{o}{:} \PYG{n}{α}\PYG{o}{)}\PYG{o}{,} \PYG{n}{g} \PYG{o}{(}\PYG{n}{f} \PYG{n}{a}\PYG{o}{)}
\end{sphinxVerbatim}


\subsubsection{Example}
\label{\detokenize{A_03_Recursive_Types:example}}
\sphinxAtStartPar
Let’s see an example. Suppose we have two functions, \sphinxstyleemphasis{inc}
that increments a natural number and sqr that squares one.
We can form a function that first increments then squares
its argument by \sphinxstyleemphasis{composing} these two functions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{inc} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{n} \PYG{n+nb+bp}{+} \PYG{l+m+mi}{1}
\PYG{k+kd}{def} \PYG{n}{sqr} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{n} \PYG{n+nb+bp}{*} \PYG{n}{n}
\PYG{k+kd}{def} \PYG{n}{inc\PYGZus{}then\PYGZus{}sqr} \PYG{o}{:=} \PYG{n}{comp} \PYG{n}{inc} \PYG{n}{sqr}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{inc\PYGZus{}then\PYGZus{}sqr} \PYG{l+m+mi}{5} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{36} \PYG{o}{:=} \PYG{n}{rfl}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} seems to work!}
\end{sphinxVerbatim}


\subsubsection{Notation}
\label{\detokenize{A_03_Recursive_Types:notation}}
\sphinxAtStartPar
Lean defines the infix operator ∘ as notation for function
composition. Note that the order of the function arguments
is reversed. (g ∘ f) is the function that applies g after
applying f to its argument. That is, (g ∘ f) x = g (f x).
We pronounce the function, (g ∘ f), as \sphinxstyleemphasis{g after f.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{inc\PYGZus{}then\PYGZus{}sqr\PYGZsq{}} \PYG{o}{:=} \PYG{n}{sqr} \PYG{n+nb+bp}{∘} \PYG{n}{inc}        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} composition!}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{inc\PYGZus{}then\PYGZus{}sqr\PYGZsq{}} \PYG{l+m+mi}{5} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{36} \PYG{o}{:=} \PYG{n}{rfl} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} seems to work!}
\end{sphinxVerbatim}


\subsubsection{Example With Two Types}
\label{\detokenize{A_03_Recursive_Types:example-with-two-types}}
\sphinxAtStartPar
In this example, given functions that compute the length
of a list and decrement a natural number, we construct a
function that takes a list of objects and returns one less
than its length. We first illustrate applications of Lean
functions for length and decrement and then use both our
notation and the Lean ∘ notation to construct the desired
function, which we apply to the list {[}1,2,3{]} yielding the
value, 2.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}eval} \PYG{n}{list.length} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} apply length function to list}
\PYG{k}{\PYGZsh{}eval} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}\PYG{n+nb+bp}{.}\PYG{n}{length}      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} function application notation}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{nat.pred} \PYG{l+m+mi}{3}          \PYG{c+c1}{\PYGZhy{}\PYGZhy{} apply decrement function to 3}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Apply composition of length and pred to list}
\PYG{k}{\PYGZsh{}eval} \PYG{o}{(}\PYG{n}{comp} \PYG{n}{list.length} \PYG{n}{nat.pred}\PYG{o}{)} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}
\PYG{k}{\PYGZsh{}eval} \PYG{o}{(}\PYG{n}{nat.pred} \PYG{n+nb+bp}{∘} \PYG{n}{list.length}\PYG{o}{)} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
The infix notation is best. Think of the argument, here the
list {[}1,2,3{]}, as moving left through list.length, yielding 3,
which then moves left through nat.pred, finally yielding 2.


\subsection{Map}
\label{\detokenize{A_03_Recursive_Types:map}}
\sphinxAtStartPar
In this section, we introduce the \sphinxstyleemphasis{map} function on lists.
It takes (1) a function that takes objects of some type
α and converts them into objects of some type β, and (2) a
list of objects of type α, and returns a list of objects
of type β, obtained by using the function to turn each each
α object in the given list into a corresponding β object
in the resulting list.

\sphinxAtStartPar
We build to a general definition of map starting with a
special case: of a function that takes a list of natural
numbers and returns a list in which each is increased by
one, by the application of \sphinxstyleemphasis{inc}, our increment function.

\sphinxAtStartPar
We define a function that “maps” the increment function
over a given list of natural numbers by case analysis on
any given list. If the given list is nil, we return nil;
otherwise, if the list is (h::t) we return the list with
the value of (inc h) at its head and the list obtained
by similarly incrementing each value in the tail of the
given list as its tail.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{inc\PYGZus{}list\PYGZus{}nat} \PYG{o}{:} \PYG{n}{list} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{list.nil}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{inc} \PYG{n}{h}\PYG{o}{)}\PYG{o}{:}\PYG{o}{:}\PYG{n}{inc\PYGZus{}list\PYGZus{}nat} \PYG{n}{t}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} it works}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{inc\PYGZus{}list\PYGZus{}nat}\PYG{o}{[}\PYG{o}{]}        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect []}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{inc\PYGZus{}list\PYGZus{}nat} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect [2,3,4]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Suppose that instead of incrementing each element
of a given list to obtain a new list, we want to
square each element. One way to do it is to clone
the function above and replace inc with sqr.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{sqr\PYGZus{}list\PYGZus{}nat} \PYG{o}{:} \PYG{n}{list} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{list.nil}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{o}{(}\PYG{n}{sqr} \PYG{n}{h}\PYG{o}{)}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sqr\PYGZus{}list\PYGZus{}nat} \PYG{n}{t}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} It works}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{sqr\PYGZus{}list\PYGZus{}nat} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Clearly we can clone and edit the preceding code
to produce a version that applies \sphinxstyleemphasis{any} function of
type nat → nat, instead of inc or sqr, to the head
of the given list, with all of the remaining code
unchanged, to map given lists of natural numbers
to new lists by replacement of existing elements
with new elements computed by application of the
given function.

\sphinxAtStartPar
That all the code remains the same but for the
\sphinxstyleemphasis{element} converting function suggests that we
can instead \sphinxstyleemphasis{generalize} by making this function
a \sphinxstyleemphasis{parameter} of the otherwise unchanging code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{any\PYGZus{}list\PYGZus{}nat} \PYG{o}{:} \PYG{o}{(}\PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{f} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{list.nil}
\PYG{n+nb+bp}{|} \PYG{n}{f} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{f} \PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{any\PYGZus{}list\PYGZus{}nat} \PYG{n}{f} \PYG{n}{t}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} It seems to work!}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{any\PYGZus{}list\PYGZus{}nat} \PYG{n}{sqr} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]} \PYG{n+nb+bp}{=} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{9}\PYG{o}{,}\PYG{l+m+mi}{16}\PYG{o}{,}\PYG{l+m+mi}{25}\PYG{o}{]} \PYG{o}{:=} \PYG{n}{rfl}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{any\PYGZus{}list\PYGZus{}nat} \PYG{n}{inc} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]} \PYG{n+nb+bp}{=} \PYG{o}{[}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{,}\PYG{l+m+mi}{6}\PYG{o}{]} \PYG{o}{:=} \PYG{n}{rfl}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{any\PYGZus{}list\PYGZus{}nat} \PYG{n}{nat.pred} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]} \PYG{n+nb+bp}{=} \PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{,}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{]} \PYG{o}{:=} \PYG{n}{rfl}
\end{sphinxVerbatim}

\sphinxAtStartPar
We’ve generalized the nat → nat function, but suppose we wanted
to convert a list of \sphinxstyleemphasis{strings} to a list of their natural number
lengths. We don’t have the machinery to do that yet, as we can
only map functions over lists of natural numbers. Otherwise we
get a type error.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}eval} \PYG{n}{any\PYGZus{}list\PYGZus{}nat} \PYG{n}{string.length} \PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Math}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{]}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} nope!}
\end{sphinxVerbatim}

\sphinxAtStartPar
One solution is simply to write a new version of our mapping
function specialized to map lists of strings to lists of nat
values, using any given string → nat function to perform the
element\sphinxhyphen{}wise mapping.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{xyz\PYGZus{}list\PYGZus{}nat} \PYG{o}{:} \PYG{o}{(}\PYG{n}{string} \PYG{n+nb+bp}{→} \PYG{n}{nat}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{string} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{f} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{list.nil}
\PYG{n+nb+bp}{|} \PYG{n}{f} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{f} \PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{xyz\PYGZus{}list\PYGZus{}nat} \PYG{n}{f} \PYG{n}{t}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} It seems to work}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{xyz\PYGZus{}list\PYGZus{}nat} \PYG{n}{string.length} \PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Math}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{]}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{B}\PYG{c+cm}{u}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{a}\PYG{c+cm}{m}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{m}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{w}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{t}
\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{m}\PYG{c+cm}{a}\PYG{c+cm}{p}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{B}\PYG{c+cm}{o}\PYG{c+cm}{o}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{.}\PYG{c+cm}{g}\PYG{c+cm}{.}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{f}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}
\PYG{c+cm}{w}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{c}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{t}\PYG{c+cm}{t}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{f}\PYG{c+cm}{f}\PYG{c+cm}{)}\PYG{c+cm}{.}
\PYG{c+cm}{C}\PYG{c+cm}{l}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{d}\PYG{c+cm}{u}\PYG{c+cm}{c}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{i}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}
\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k+kd}{def} \PYG{n}{map\PYGZus{}string\PYGZus{}bool} \PYG{o}{:} \PYG{o}{(}\PYG{n}{string} \PYG{n+nb+bp}{→} \PYG{n}{bool}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{string} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{bool}
\PYG{n+nb+bp}{|} \PYG{n}{f} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{list.nil}
\PYG{n+nb+bp}{|} \PYG{n}{f} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{f} \PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{map\PYGZus{}string\PYGZus{}bool} \PYG{n}{f} \PYG{n}{t}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} is\PYGZus{}even takes a nat and return tt if it\PYGZsq{}s even else ff}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}}
\PYG{k+kd}{def} \PYG{n}{is\PYGZus{}even} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{nat}\PYG{o}{)} \PYG{o}{:} \PYG{n}{bool} \PYG{o}{:=} \PYG{n}{n} \PYG{n+nb+bp}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{n+nb+bp}{=} \PYG{l+m+mi}{0}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{is\PYGZus{}even} \PYG{l+m+mi}{2}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{is\PYGZus{}even} \PYG{l+m+mi}{3}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{N}\PYG{c+cm}{o}\PYG{c+cm}{w}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{m}\PYG{c+cm}{a}\PYG{c+cm}{p}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{c}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}
\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{i}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}
\PYG{c+cm}{g}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{p}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{t}\PYG{c+cm}{/}\PYG{c+cm}{f}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}
\PYG{k+kd}{def} \PYG{n}{is\PYGZus{}even\PYGZus{}length} \PYG{o}{:=} \PYG{n}{is\PYGZus{}even} \PYG{n+nb+bp}{∘} \PYG{n}{string.length}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{map\PYGZus{}string\PYGZus{}bool} \PYG{n}{is\PYGZus{}even\PYGZus{}length} \PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Math}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course well run into exactly the same sort of problem,
of having to engage in error\sphinxhyphen{}prone cloning and editing of
code, if we want to now map lists of Boolean values to lists
of strings (e.g., mapping each tt to “T” and each ff to “F”).

\sphinxAtStartPar
And you can imagine many other examples: mapping lists of
employees to list of their corresponding salaries, or mapping
lists of Boolean values to lists of their negations, etc. The
possibilities are endless.

\sphinxAtStartPar
The answer should now we pretty clear: we need to further
generalize: not only over the function to apply to map each
list element, but also over the the types of element in the
input and output lists! Here, then, is a greatly generalized
version.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{map\PYGZus{}list} \PYG{o}{\PYGZob{}}\PYG{n}{α} \PYG{n}{β} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{\PYGZcb{}} \PYG{o}{:} \PYG{o}{(}\PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{β}\PYG{o}{)} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{β}
\PYG{n+nb+bp}{|} \PYG{n}{f} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{list.nil}
\PYG{n+nb+bp}{|} \PYG{n}{f} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{f} \PYG{n}{h} \PYG{o}{:}\PYG{o}{:} \PYG{n}{map\PYGZus{}list} \PYG{n}{f} \PYG{n}{t}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} It seems to work!}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{map\PYGZus{}list} \PYG{n}{nat.succ} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{map\PYGZus{}list} \PYG{n}{is\PYGZus{}even\PYGZus{}length} \PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{I}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Love}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Math}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
For now, we’ll be satisfied with this level of generality.
We will just observe that our mapping function still only
works for \sphinxstyleemphasis{lists} as element containers. What if you wanted
to map functions over other kinds of element “containers,”
e.g., to turn values of type \sphinxstyleemphasis{option α} into \sphinxstyleemphasis{option βs}?
Or trees of α values into corresponding trees of β values?

\sphinxAtStartPar
The key roadblock will be that there’s no way to do this
using exactly the same code for, say, lists and options.
So the kind of parametric polymorphism we’ve been using
will no longer be enough. The answer will be found in a
different kind of polymorphism, \sphinxstyleemphasis{ad hoc} polynorphism, of
which \sphinxstyleemphasis{operator overloading} (as in C++) is an example.
For instance, you can write complex number and string
classes and overload the + operator in each class to do
respective complex number addition and string append, but
the implementations of these operations will hardly share
the same code. Completely different implementations will
be needed, to be selected (by the compler in C++) based
on the types of the arguments to which the + operator is
applied.  More on this topic later.


\subsection{Fold}
\label{\detokenize{A_03_Recursive_Types:fold}}
\sphinxAtStartPar
We now turn to a very different higher\sphinxhyphen{}order function
appliable to lists. It’s called \sphinxstyleemphasis{fold} (or event better,
\sphinxstyleemphasis{fold\_right}) or \sphinxstyleemphasis{reduce}.

\sphinxAtStartPar
The fundamental purpose of this operation is to turn a
\sphinxstyleemphasis{binary} operation on the values of any given type (e.g.,
nat) into an operation that can be applied to \sphinxstyleemphasis{any} number
of arguments, where the arguments are packaged into a list
data structure.

\sphinxAtStartPar
The way the generalized version of the binary operation
works is that for the empty list it returns a base value,
and for a non\sphinxhyphen{}empty list, \sphinxstyleemphasis{h::t}, it applies the binary
operation to \sphinxstyleemphasis{h} and \sphinxstyleemphasis{to the result of applying the n\sphinxhyphen{}ary
version to the rest of the list, *t}.

\sphinxAtStartPar
As an example, fold will turn the addition function on
natural numbers (nat.add) into an operation that can be
applied to a list of any number of natural number values
to compute the sum of them all. Here, for example, is
such a program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{reduce\PYGZus{}sum} \PYG{o}{:} \PYG{n}{list} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{l+m+mi}{0}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{nat.add} \PYG{n}{h} \PYG{o}{(}\PYG{n}{reduce\PYGZus{}sum} \PYG{n}{t}\PYG{o}{)}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{reduce\PYGZus{}sum} \PYG{o}{[}\PYG{o}{]}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} sum of zero arguments}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{reduce\PYGZus{}sum} \PYG{o}{[}\PYG{l+m+mi}{5}\PYG{o}{]}          \PYG{c+c1}{\PYGZhy{}\PYGZhy{} sum of one argument}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{reduce\PYGZus{}sum} \PYG{o}{[}\PYG{l+m+mi}{5}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{]}        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} sum of two arguments}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{reduce\PYGZus{}sum} \PYG{o}{[}\PYG{l+m+mi}{5}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{1}\PYG{o}{]}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} sum of five arguments}
\end{sphinxVerbatim}

\sphinxAtStartPar
It should be clear that we will want to generalize
the binary operator from nat.add to \sphinxstyleemphasis{any} binary
operation on natural numbers. For example, we might
want a function that implements n\sphinxhyphen{}ary multiplication,
reducing any list of natural numbers to the product
of all the numbers in the list.

\sphinxAtStartPar
This is a little bit tricker than one might guess.
To see the problem, let’s clone and edit the code
we’ve got, substituting multiplication for addition,
in an attempt to implement n\sphinxhyphen{}ary multiplication.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{reduce\PYGZus{}prod\PYGZsq{}} \PYG{o}{:} \PYG{n}{list} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{l+m+mi}{0}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{nat.mul} \PYG{n}{h} \PYG{o}{(}\PYG{n}{reduce\PYGZus{}prod\PYGZsq{}} \PYG{n}{t}\PYG{o}{)}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{reduce\PYGZus{}prod\PYGZsq{}} \PYG{o}{[}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{1}\PYG{o}{]}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect 6 got 0!}

\PYG{c}{/\PYGZhy{}}
\PYG{c+cm}{T}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{o}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{g}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{u}\PYG{c+cm}{n}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{s}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{:}
\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{u}\PYG{c+cm}{c}\PYG{c+cm}{e}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{d}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{ }\PYG{c+cm}{[}\PYG{c+cm}{3}\PYG{c+cm}{,}\PYG{c+cm}{2}\PYG{c+cm}{,}\PYG{c+cm}{1}\PYG{c+cm}{]}\PYG{c+cm}{ }\PYG{c+cm}{=}
\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{ }\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{3}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{u}\PYG{c+cm}{c}\PYG{c+cm}{e}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{d}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{ }\PYG{c+cm}{[}\PYG{c+cm}{2}\PYG{c+cm}{,}\PYG{c+cm}{1}\PYG{c+cm}{]}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{=}
\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{ }\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{3}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{2}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{u}\PYG{c+cm}{c}\PYG{c+cm}{e}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{d}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{ }\PYG{c+cm}{[}\PYG{c+cm}{1}\PYG{c+cm}{]}\PYG{c+cm}{)}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{=}
\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{ }\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{3}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{2}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{u}\PYG{c+cm}{c}\PYG{c+cm}{e}\PYG{c+cm}{\PYGZus{}}\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{d}\PYG{c+cm}{\PYGZsq{}}\PYG{c+cm}{ }\PYG{c+cm}{[}\PYG{c+cm}{]}\PYG{c+cm}{)}\PYG{c+cm}{)}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{=}
\PYG{c+cm}{\PYGZhy{}}\PYG{c+cm}{ }\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{3}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{2}\PYG{c+cm}{ }\PYG{c+cm}{(}\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{0}\PYG{c+cm}{)}\PYG{c+cm}{)}\PYG{c+cm}{ }\PYG{c+cm}{=}\PYG{c+cm}{ }\PYG{c+cm}{0}\PYG{c+cm}{!}
\PYG{c+cm}{T}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{m}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{w}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{l}\PYG{c+cm}{e}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{s}\PYG{c+cm}{o}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{:}
\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{ }\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{f}\PYG{c+cm}{f}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}
\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{f}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{e}\PYG{c+cm}{m}\PYG{c+cm}{p}\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}
\PYG{c+cm}{m}\PYG{c+cm}{u}\PYG{c+cm}{l}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{p}\PYG{c+cm}{l}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{a}\PYG{c+cm}{d}\PYG{c+cm}{d}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{o}\PYG{c+cm}{n}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{S}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{c}\PYG{c+cm}{i}\PYG{c+cm}{f}\PYG{c+cm}{i}\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{,}
\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{e}\PYG{c+cm}{d}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{z}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{Y}\PYG{c+cm}{o}\PYG{c+cm}{u}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{o}\PYG{c+cm}{w}
\PYG{c+cm}{p}\PYG{c+cm}{r}\PYG{c+cm}{o}\PYG{c+cm}{b}\PYG{c+cm}{a}\PYG{c+cm}{b}\PYG{c+cm}{l}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{s}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{g}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{n}
\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{*}\PYG{c+cm}{i}\PYG{c+cm}{d}\PYG{c+cm}{e}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{i}\PYG{c+cm}{t}\PYG{c+cm}{y}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{n}\PYG{c+cm}{e}\PYG{c+cm}{u}\PYG{c+cm}{t}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{,}\PYG{c+cm}{ }\PYG{c+cm}{v}\PYG{c+cm}{a}\PYG{c+cm}{l}\PYG{c+cm}{u}\PYG{c+cm}{e}\PYG{c+cm}{*}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{h}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{e}\PYG{c+cm}{v}\PYG{c+cm}{e}\PYG{c+cm}{r}
\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{i}\PYG{c+cm}{n}\PYG{c+cm}{a}\PYG{c+cm}{r}\PYG{c+cm}{y}\PYG{c+cm}{ }\PYG{c+cm}{o}\PYG{c+cm}{p}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{a}\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{i}\PYG{c+cm}{s}\PYG{c+cm}{ }\PYG{c+cm}{f}\PYG{c+cm}{o}\PYG{c+cm}{r}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{h}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{b}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{c}\PYG{c+cm}{a}\PYG{c+cm}{s}\PYG{c+cm}{e}\PYG{c+cm}{.}\PYG{c+cm}{ }\PYG{c+cm}{H}\PYG{c+cm}{e}\PYG{c+cm}{r}\PYG{c+cm}{e}
\PYG{c+cm}{w}\PYG{c+cm}{e}\PYG{c+cm}{ }\PYG{c+cm}{w}\PYG{c+cm}{a}\PYG{c+cm}{n}\PYG{c+cm}{t}\PYG{c+cm}{ }\PYG{c+cm}{t}\PYG{c+cm}{o}\PYG{c+cm}{ }\PYG{c+cm}{r}\PYG{c+cm}{e}\PYG{c+cm}{t}\PYG{c+cm}{u}\PYG{c+cm}{r}\PYG{c+cm}{n}\PYG{c+cm}{ }\PYG{c+cm}{1}\PYG{c+cm}{.}
\PYG{c+cm}{\PYGZhy{}/}

\PYG{k+kd}{def} \PYG{n}{reduce\PYGZus{}prod} \PYG{o}{:} \PYG{n}{list} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{l+m+mi}{1}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{nat.mul} \PYG{n}{h} \PYG{o}{(}\PYG{n}{reduce\PYGZus{}prod} \PYG{n}{t}\PYG{o}{)}

\PYG{k}{\PYGZsh{}eval} \PYG{n}{reduce\PYGZus{}prod} \PYG{o}{[}\PYG{o}{]}          \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect 1}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{reduce\PYGZus{}prod} \PYG{o}{[}\PYG{l+m+mi}{5}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{1}\PYG{o}{]} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect 120}
\end{sphinxVerbatim}

\sphinxAtStartPar
So now we can correctly generalize fold\_nat over
binary operators by making the operator a parameter
but by also adding as a second parameter the right
identity element for whatever operator we provide
as an actual parameter.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{fold\PYGZus{}nat} \PYG{o}{(}\PYG{n}{op} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}\PYG{o}{)}\PYG{o}{:}  \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{list} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{id} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{id}
\PYG{n+nb+bp}{|} \PYG{n}{id} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{op} \PYG{n}{h} \PYG{o}{(}\PYG{n}{fold\PYGZus{}nat} \PYG{n}{id} \PYG{n}{t}\PYG{o}{)}


\PYG{c+c1}{\PYGZhy{}\PYGZhy{} It seems to work!}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{fold\PYGZus{}nat} \PYG{n}{nat.add} \PYG{l+m+mi}{0} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect 15}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{fold\PYGZus{}nat} \PYG{n}{nat.mul} \PYG{l+m+mi}{1} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} expect 120}
\end{sphinxVerbatim}

\sphinxAtStartPar
Yet a problem remains. There is nothing in our
solution that prevents us from passing the wrong
value for the identity element for the given binary
operator. The following function application runs
without any errors being reported but it gives the
wrong answer, because we pass the wrong identity
element for nat.mul.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}eval} \PYG{n}{fold\PYGZus{}nat} \PYG{n}{nat.mul} \PYG{l+m+mi}{0} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} oops, wrong}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will finish this chapter with a step toward our
ultimate solution: we will now construct a version
of fold\_nat (fold\_nat’) that \sphinxstyleemphasis{enforces consistency}
between the binary function and identity element
arguments by requiring, as an additional argument,
a proof that the putative identity element really
is one!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{fold\PYGZus{}nat\PYGZsq{}}
  \PYG{o}{(}\PYG{n}{op}\PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}\PYG{o}{)}
  \PYG{o}{(}\PYG{n}{id} \PYG{o}{:}\PYG{n}{nat}\PYG{o}{)}
  \PYG{o}{(}\PYG{n}{right\PYGZus{}id} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{nat}\PYG{o}{)}\PYG{o}{,} \PYG{n}{op} \PYG{n}{n} \PYG{n}{id} \PYG{n+nb+bp}{=} \PYG{n}{n}\PYG{o}{)} \PYG{o}{:}
  \PYG{n}{list} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{list.nil} \PYG{o}{:=} \PYG{n}{id}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{h}\PYG{o}{:}\PYG{o}{:}\PYG{n}{t}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{op} \PYG{n}{h} \PYG{o}{(}\PYG{n}{fold\PYGZus{}nat\PYGZsq{}} \PYG{n}{t}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s construct named proofs that 0 is an identity
when it appears as the second argument to nat.add.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{theorem} \PYG{n}{zero\PYGZus{}right\PYGZus{}id\PYGZus{}add} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{nat}\PYG{o}{)}\PYG{o}{,} \PYG{n}{nat.add} \PYG{n}{n} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{n}{n} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{n}\PYG{o}{,}
\PYG{n}{simp} \PYG{o}{[}\PYG{n}{nat.add}\PYG{o}{]}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Now we can safely use fold\PYGZus{}nat\PYGZsq{}}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{fold\PYGZus{}nat\PYGZsq{}} \PYG{n}{nat.add} \PYG{l+m+mi}{0} \PYG{n}{zero\PYGZus{}right\PYGZus{}id\PYGZus{}add} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} This application fails because the proof is wrong}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{fold\PYGZus{}nat\PYGZsq{}} \PYG{n}{nat.add} \PYG{l+m+mi}{1} \PYG{n}{zero\PYGZus{}right\PYGZus{}id\PYGZus{}add} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
As a closing point, we circle back to the notion that
fold generalizes any given binary operator to an n\sphinxhyphen{}ary
operator applicable to any number of arguments as long
as they’re arranged in a list. You can see this idea
in action by just partially applying fold\_nat’ to a
binary operator, it’s identity, and the required proof,
leaving the list argument TBD.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{n\PYGZus{}ary\PYGZus{}add} \PYG{o}{:=} \PYG{n}{fold\PYGZus{}nat\PYGZsq{}} \PYG{n}{nat.add} \PYG{l+m+mi}{0} \PYG{n}{zero\PYGZus{}right\PYGZus{}id\PYGZus{}add}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} It seems to work!}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{n\PYGZus{}ary\PYGZus{}add} \PYG{o}{[}\PYG{o}{]}            \PYG{c+c1}{\PYGZhy{}\PYGZhy{} zero arguments}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{n\PYGZus{}ary\PYGZus{}add} \PYG{o}{[}\PYG{l+m+mi}{5}\PYG{o}{]}           \PYG{c+c1}{\PYGZhy{}\PYGZhy{} one argument}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{n\PYGZus{}ary\PYGZus{}add} \PYG{o}{[}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}         \PYG{c+c1}{\PYGZhy{}\PYGZhy{} two arguments}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{n\PYGZus{}ary\PYGZus{}add} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}   \PYG{c+c1}{\PYGZhy{}\PYGZhy{} five arguments, etc!}
\end{sphinxVerbatim}

\sphinxAtStartPar
Soon we’ll be able similarly to turn binary multiplication
into n\sphinxhyphen{}ary multiplication, with a definitions like this:
\sphinxstyleemphasis{def n\_ary\_mul := fold\_nat’ nat.mul 1 one\_right\_id\_mul}. The
problem is we don’t yet have the machinery (namely proof by
induction) to construct the proof that 1 is a right identity
for nat.mul. That’ll come soon enough. For now, we can stub
it out and get something that works but without a proof that
1 is a right identity for natural number multiplication.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{n\PYGZus{}ary\PYGZus{}mul} \PYG{o}{:=} \PYG{n}{fold\PYGZus{}nat\PYGZsq{}} \PYG{n}{nat.mul} \PYG{l+m+mi}{1} \PYG{g+gr}{sorry}
\PYG{k}{\PYGZsh{}eval} \PYG{n}{n\PYGZus{}ary\PYGZus{}mul} \PYG{o}{[}\PYG{l+m+mi}{1}\PYG{o}{,}\PYG{l+m+mi}{2}\PYG{o}{,}\PYG{l+m+mi}{3}\PYG{o}{,}\PYG{l+m+mi}{4}\PYG{o}{,}\PYG{l+m+mi}{5}\PYG{o}{]}
\end{sphinxVerbatim}


\subsection{Summary}
\label{\detokenize{A_03_Recursive_Types:summary}}
\sphinxAtStartPar
Higher\sphinxhyphen{}order functions are functions that consume functions
as arguments and/or that return functions as results. In this
chapter we’ve produced highly general higher\sphinxhyphen{}order functions
for (1) composition of functions, (2) mapping functions over
lists to derive new lists, and (3) extending binary operators
to n\sphinxhyphen{}ary operators whose arguments are given as lists of any
length.


\subsection{Exercises}
\label{\detokenize{A_03_Recursive_Types:id4}}
\sphinxAtStartPar
1. Write a function, n\_ary\_append (without using fold) that
takes a list of lists of objects of some type, α (the type will
be \sphinxstyleemphasis{list (list α)}) and that reduces it to a single list of α
using \sphinxstyleemphasis{list.append} as a binary operation. For example, it’d
turn this list, {[}{[}1,2{]},{[}3,4{]},{[}5{]}{]} into the list {[}1,2,3,4,5{]}.
You may use Lean’s list.append function as a binary operator
that combines two lists into one.

\sphinxAtStartPar
2. Write a function (without using fold) that takes a a list
of lists of α and that returns the sum of the lengths of the
contained lists. For example applying your function to the
list, {[}{[}{]},{[}1,2,3{]},{[}1,2,3,4,5{]}{]}, should return 8: the sum of
0 for the first list, 3 for the second, and 5 for the third.
Your function will work by adding the length of the head of
the list of lists to the result of recursively reducing the
\sphinxstyleemphasis{rest} (tail) of the list of lists. You may use list.length
to compute the length of any list.

\sphinxAtStartPar
3. Write a function without using fold that takes a list of
lists of α and that returns true if the length of each of
the elements lists is even and false otherwise.


\section{Recursive Proofs}
\label{\detokenize{A_03_Recursive_Types:recursive-proofs}}

\subsection{Proof by Induction}
\label{\detokenize{A_03_Recursive_Types:proof-by-induction}}
\sphinxAtStartPar
There was something notably questionable in the last
chapter. We defined a \sphinxstyleemphasis{safe} version of \sphinxstyleemphasis{fold} by requiring
a proof that the value returned for an empty list be a
\sphinxstyleemphasis{right} (but not a \sphinxstyleemphasis{left}) identity element for the actual
binary operator parameter given to the fold function.

\sphinxAtStartPar
We then found it easy to prove that 0 is indeed a right
identity for nat.add. They key insight you need to have
is that it was easy to prove because it’s already given
to us as an \sphinxstyleemphasis{axiom}. In particular, the first rule in the
recursive definition of nat.add makes it so. Here’s the
definition of nat.add from Lean’s core library.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{add} \PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{n}{nat}
\PYG{n+nb+bp}{|} \PYG{n}{a}  \PYG{n}{zero}     \PYG{o}{:=} \PYG{n}{a}
\PYG{n+nb+bp}{|} \PYG{n}{a}  \PYG{o}{(}\PYG{n}{succ} \PYG{n}{b}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{succ} \PYG{o}{(}\PYG{n}{add} \PYG{n}{a} \PYG{n}{b}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Look at the first case/rule: any a added to zero
is equal to a. This rule establishes that zero is
a right identity for add.  Here again is our earlier
statement and proof.

\sphinxAtStartPar
Note that the \sphinxstyleemphasis{simp} tactict tries to fine, and if
found applies, rules/axioms from the definition of
any of the listed functions: here from just nat.add.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)}\PYG{o}{,} \PYG{n}{nat.add} \PYG{n}{n} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{=} \PYG{n}{n} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{n}\PYG{o}{,}
\PYG{n}{simp} \PYG{o}{[}\PYG{n}{nat.add}\PYG{o}{]}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
What’s \sphinxstyleemphasis{not} provided by the definition
of nat.add is an axiom that stipulates
zero is a \sphinxstyleemphasis{left} identity for nat.add.
If we try the same proof technique to
prove \sphinxstyleemphasis{∀ n, 0 + n = n}, with 0 now on
the left, we can’t! (When writing these
propositions and proofs, use nat.add in
a consistent manner instead of 0. It’s
a complication that’s annoying, but for
now just follow this simple instruction
and you’ll be fine.)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{n}\PYG{o}{,} \PYG{n}{nat.add} \PYG{n}{nat.zero} \PYG{n}{n} \PYG{n+nb+bp}{=} \PYG{n}{n} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{n}\PYG{o}{,}
\PYG{n}{simp} \PYG{o}{[}\PYG{n}{nat.add}\PYG{o}{]}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} oops, that didn\PYGZsq{}t help; we\PYGZsq{}re stuck!}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
Looking at what remains to be proved, we
might consider proof by case analysis on
n. So let’s try that.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{example} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{n}\PYG{o}{,} \PYG{n}{nat.add} \PYG{n}{nat.zero} \PYG{n}{n} \PYG{n+nb+bp}{=} \PYG{n}{n} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{k}{assume} \PYG{n}{n}\PYG{o}{,}
\PYG{n}{cases} \PYG{n}{n} \PYG{k}{with} \PYG{n}{n\PYGZsq{}}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} first case: zero\PYGZsq{}s also on the right}
\PYG{n}{simp} \PYG{o}{[}\PYG{n}{nat.add}\PYG{o}{]}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} second case, argument is succ of some n\PYGZsq{}}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} how to show 0 + (succ n\PYGZsq{}) = (succ n\PYGZsq{})}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} but again we\PYGZsq{}re stuck}
\PYG{n}{simp} \PYG{o}{[}\PYG{n}{nat.add}\PYG{o}{]}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} basically back where we started; stuck.}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxAtStartPar
The problem is that all we know about n’
is that it’s some natural number, and that
isn’t enough to work with to prove the goal.

\sphinxAtStartPar
What if we knew a little more? What if we
knew that 0 is a left zero for n’ as part
of the context in which are to prove that
it’s a zero for (succ n’)? Would that help?

\sphinxAtStartPar
It would. Suppose we know that \sphinxstyleemphasis{add 0 n’ = n’}
and that we want to prive that \sphinxstyleemphasis{add 0 (succ n’)
= (succ n’)}. Key insight: We can apply the
\sphinxstyleemphasis{second} axiom of addition,given by the second
rule in its definition, to rewrite the term,
\sphinxstyleemphasis{add 0 (succ n’)} to the term \sphinxstyleemphasis{succ (add 0 n’);}
then we can use the fact that (by assumption)
0 is a left 0 for n’ to rewrite the term
\sphinxstyleemphasis{succ (add 0 n’)} to \sphinxstyleemphasis{succ n’.} That’s it.
We’ve shown that 0 + succ n’ = succ n’.

\sphinxAtStartPar
But what could possibly justify assuming
that 0 + n’ = n’ in the first place? Well,
let’s see if it can be justified informally
before getting into formalities.

\sphinxAtStartPar
Let’s start by noting that by the first rule
of addition, 0 is a left zero for 0. This
proof gives us a base on which we can now
construct a proof that 0 is a left zero for 1.

\sphinxAtStartPar
Details: we want to show that 0 + 1 = 1. That
is, we want to show that 0 + succ 0 = succ 0.
By the second rule/axiom of add, the left side
is succ (0 + 0). \sphinxstyleemphasis{BE SURE YOU UNDERSTAND THIS
STEP.}  Now yy the first rule, 0 + 0 = 0, so
we can rewrite succ (0 + 0) to just succ 0.
With this expression on the left side, all
thatremains to prove is that succ 0 = succ 0,
and this is true of course by the reflexivity
of the equality relation.

\sphinxAtStartPar
To recap, we proved a “base case” (that
zero is a left identity for zero) using the
first axiom of addition. Then we applied the
second axiom to show that 0 is a left identity
for 1. With this proof in hand we can apply
the second axiom \sphinxstyleemphasis{again} to construct a proof
that zero is left identity for 2. From this
we can derive that 0 is a left identity for
3. Indeed to prove that 0 is a left identity
for \sphinxstyleemphasis{any} n, we start with a proof that it’s
a left identity for zero using the first
axiom, then we iteratively apply the second
axiom n times to prove it’s a left identity
for \sphinxstyleemphasis{any} n.

\sphinxAtStartPar
Let’s just program it to make it all clear.
Out program will take any value n and return
a proof that 0 is a left identity for it. It
does this in the reverse order, constructing
a proof for the case where n is non\sphinxhyphen{}zero, i.e.,
where n = succ n’ for some n’, and obtaining
a proof for n’ \sphinxstyleemphasis{by recursion}. The recursive
calls implement iteration until the base case
of n = 0 is reached, at which point a proof
for that case is returned, the recursion
unwinds, and we’re left with a proof that 0
is a left identity for that arbitrary n. The
existence of this function shows that we can
construct a proof of the proposition that 0
is a left identity for any n, and so it is
true \sphinxstyleemphasis{for all} n. And that’s what we wanted.
QED.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} a proof\PYGZhy{}returning function defined by cases}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} takes any n and returns a proof of 0 + n = n}
\PYG{k+kd}{def} \PYG{n}{zero\PYGZus{}left\PYGZus{}ident\PYGZus{}n} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{n}\PYG{o}{,} \PYG{o}{(}\PYG{n}{nat.add} \PYG{l+m+mi}{0} \PYG{n}{n} \PYG{n+nb+bp}{=} \PYG{n}{n}\PYG{o}{)}
\PYG{n+nb+bp}{|} \PYG{n}{nat.zero} \PYG{o}{:=} \PYG{k+kd}{by} \PYG{n}{simp} \PYG{o}{[}\PYG{n}{nat.add}\PYG{o}{]} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} base case}
\PYG{n+nb+bp}{|} \PYG{o}{(}\PYG{n}{nat.succ} \PYG{n}{n\PYGZsq{}}\PYG{o}{)} \PYG{o}{:=}              \PYG{c+c1}{\PYGZhy{}\PYGZhy{} recursive case}
  \PYG{k+kd}{begin}
  \PYG{n}{simp} \PYG{o}{[}\PYG{n}{nat.add}\PYG{o}{]}\PYG{o}{,}               \PYG{c+c1}{\PYGZhy{}\PYGZhy{} applies second rule and ...}
                                \PYG{c+c1}{\PYGZhy{}\PYGZhy{} removes succ on each side}
                                \PYG{c+c1}{\PYGZhy{}\PYGZhy{} by injectivity of constructors}
                                \PYG{c+c1}{\PYGZhy{}\PYGZhy{} inherent in inductive definitions}
  \PYG{n}{exact} \PYG{o}{(}\PYG{n}{zero\PYGZus{}left\PYGZus{}ident\PYGZus{}n} \PYG{n}{n\PYGZsq{}}\PYG{o}{)}\PYG{o}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} prove result recursively}
  \PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} eyeball check of the recursive structure of these proofs!}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{zero\PYGZus{}left\PYGZus{}ident\PYGZus{}n} \PYG{l+m+mi}{0}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} the proof term is unpretty (just eyeball it)}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{zero\PYGZus{}left\PYGZus{}ident\PYGZus{}n} \PYG{l+m+mi}{1}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} the proof for 1 buids on the proof for 0}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{zero\PYGZus{}left\PYGZus{}ident\PYGZus{}n} \PYG{l+m+mi}{2}     \PYG{c+c1}{\PYGZhy{}\PYGZhy{} the proof for 2 buids on the proof for 1}
                                \PYG{c+c1}{\PYGZhy{}\PYGZhy{} and we see we can build such a proof for any n}
                                \PYG{c+c1}{\PYGZhy{}\PYGZhy{} therefore 0 is a left identity for addition}
\end{sphinxVerbatim}

\sphinxAtStartPar
A bit more to come.


\subsection{Inductive Families}
\label{\detokenize{A_03_Recursive_Types:inductive-families}}
\sphinxAtStartPar
Coming soon.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{inductive} \PYG{n}{le} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{nat}\PYG{o}{)}\PYG{o}{:} \PYG{n}{nat} \PYG{n+nb+bp}{→} \PYG{k+kt}{Prop}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} n is an implicit firt argument to each constructor}
\PYG{n+nb+bp}{|} \PYG{n}{refl} \PYG{o}{:} \PYG{n}{le} \PYG{c}{/\PYGZhy{}}\PYG{c+cm}{n}\PYG{c+cm}{\PYGZhy{}/} \PYG{n}{n}
\PYG{n+nb+bp}{|} \PYG{n}{step} \PYG{o}{:} \PYG{n+nb+bp}{∀} \PYG{n}{m}\PYG{o}{,} \PYG{n}{le} \PYG{c}{/\PYGZhy{}}\PYG{c+cm}{n}\PYG{c+cm}{\PYGZhy{}/} \PYG{n}{m} \PYG{n+nb+bp}{→} \PYG{n}{le} \PYG{c}{/\PYGZhy{}}\PYG{c+cm}{n}\PYG{c+cm}{\PYGZhy{}/} \PYG{n}{m.succ}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} you can see it in the types of the constructors}
\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{@}\PYG{n}{le.refl}
\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{@}\PYG{n}{le.step}


\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{le} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{apply} \PYG{n}{le.refl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{le} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{apply} \PYG{n}{le.refl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{le} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{apply} \PYG{n}{le.step}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{le.refl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{k+kd}{example} \PYG{o}{:} \PYG{n}{le} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{apply} \PYG{n}{le.step}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{le.step}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{le.step}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{le.refl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} here\PYGZsq{}s the same example using Lean\PYGZsq{}s version of \PYGZdq{}le\PYGZdq{}}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} it\PYGZsq{}s called nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{n+nb+bp}{≤} \PYG{l+m+mi}{3} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{n}{apply} \PYG{n}{nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal.step}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal.step}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal.step}\PYG{o}{,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} apply nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal.step,}
\PYG{n}{apply} \PYG{n}{nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal.refl}\PYG{o}{,}
\PYG{k+kd}{end}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} repeat tactical goes too far; use iterate instead}
\PYG{k+kd}{example} \PYG{o}{:} \PYG{l+m+mi}{1} \PYG{n+nb+bp}{≤} \PYG{l+m+mi}{4} \PYG{o}{:=}
\PYG{k+kd}{begin}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} repeat \PYGZob{}apply nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal.step\PYGZcb{},}
\PYG{n}{iterate} \PYG{l+m+mi}{3} \PYG{o}{\PYGZob{}}\PYG{n}{apply} \PYG{n}{nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal.step}\PYG{o}{\PYGZcb{}}\PYG{o}{,}
\PYG{n}{apply} \PYG{n}{nat.less\PYGZus{}than\PYGZus{}or\PYGZus{}equal.refl}\PYG{o}{,}
\PYG{k+kd}{end}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Dependent Types}
\label{\detokenize{A_04_Dependent_Types:dependent-types}}\label{\detokenize{A_04_Dependent_Types:introduction}}\label{\detokenize{A_04_Dependent_Types::doc}}

\section{Σ Types}
\label{\detokenize{A_04_Dependent_Types:types}}

\section{Π Types}
\label{\detokenize{A_04_Dependent_Types:id1}}
\sphinxAtStartPar
A Pi type associates types with values.
We define a predicate, Q, as an example
to use in what follows. Q is true of any
natural number \sphinxstyleemphasis{n} by the reflexivity of
equality.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kd}{def} \PYG{n}{Q} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{nat}\PYG{o}{)} \PYG{o}{:=} \PYG{n}{n} \PYG{n+nb+bp}{=} \PYG{n}{n}
\PYG{k}{\PYGZsh{}check} \PYG{n}{Q}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} \PYGZdq{}propositions are types\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{Indexed Families}
\label{\detokenize{A_04_Dependent_Types:indexed-families}}
\sphinxAtStartPar
Note that each \sphinxstyleemphasis{n} to to which one applies
\sphinxstyleemphasis{Q} gives rised to a proposition–a type–that
\sphinxstyleemphasis{is about} (and in this sense, depends on) \sphinxstyleemphasis{n}.
Such a types is said to be a \sphinxstyleemphasis{dependent type}.

\sphinxAtStartPar
Parametric polymorphism, by contrast, arises
when \sphinxstyleemphasis{types} are parameters. For example, the
\sphinxstyleemphasis{list} type builder takes an \sphinxstyleemphasis{type} (of list
elements)  as an argument and reduces to the
type of lists of elements of that type. On the
other hand, here the result type depends on a
data \sphinxstyleemphasis{value}.

\sphinxAtStartPar
In effect, \sphinxstyleemphasis{Q} associates a separate type with
each nat value. We say that \sphinxstyleemphasis{Q} defines a family
of types \sphinxstyleemphasis{indexed by n}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Q n is a type (proposition) dependent on n}
\PYG{k}{\PYGZsh{}check} \PYG{n}{Q} \PYG{l+m+mi}{0}
\PYG{k}{\PYGZsh{}check} \PYG{n}{Q} \PYG{l+m+mi}{1}
\PYG{k}{\PYGZsh{}check} \PYG{n}{Q} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}


\subsection{Dependent Function Types}
\label{\detokenize{A_04_Dependent_Types:dependent-function-types}}
\sphinxAtStartPar
The next insight to gain is that we can now define
functions that return \sphinxstyleemphasis{values of dependent types}.
To continue the preceding example, we define a new
function that when given \sphinxstyleemphasis{n} returns not the type,
n = n, but a proof of it: a value of the dependent
type.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} A function from n : ℕ to *proofs (values)* of *Q n*}
\PYG{k+kd}{def} \PYG{n}{dep\PYGZus{}func\PYGZus{}prop} \PYG{o}{(}\PYG{n}{n} \PYG{o}{:} \PYG{n}{ℕ}\PYG{o}{)} \PYG{o}{:} \PYG{n}{Q} \PYG{n}{n} \PYG{o}{:=} \PYG{k+kd}{begin} \PYG{n}{unfold} \PYG{n}{Q} \PYG{k+kd}{end}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{\PYGZsh{}check} \PYG{n}{dep\PYGZus{}func\PYGZus{}prop}

\PYG{k}{\PYGZsh{}check} \PYG{n}{dep\PYGZus{}func\PYGZus{}prop} \PYG{l+m+mi}{0}
\PYG{k}{\PYGZsh{}check} \PYG{n}{dep\PYGZus{}func\PYGZus{}prop} \PYG{l+m+mi}{1}
\PYG{k}{\PYGZsh{}check} \PYG{n}{dep\PYGZus{}func\PYGZus{}prop} \PYG{l+m+mi}{2}

\PYG{k}{\PYGZsh{}reduce} \PYG{n}{dep\PYGZus{}func\PYGZus{}prop} \PYG{l+m+mi}{0}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{dep\PYGZus{}func\PYGZus{}prop} \PYG{l+m+mi}{1}
\PYG{k}{\PYGZsh{}reduce} \PYG{n}{dep\PYGZus{}func\PYGZus{}prop} \PYG{l+m+mi}{2}

\PYG{k+kd}{variables}
  \PYG{o}{(}\PYG{n}{α} \PYG{o}{:} \PYG{k+kt}{Type}\PYG{o}{)}          \PYG{c+c1}{\PYGZhy{}\PYGZhy{} a *data* type}
  \PYG{o}{(}\PYG{n}{P} \PYG{o}{:} \PYG{n}{α} \PYG{n+nb+bp}{→} \PYG{k+kt}{Prop}\PYG{o}{)}      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} predicate on α}

\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{∀} \PYG{o}{(}\PYG{n}{a} \PYG{o}{:} \PYG{n}{α}\PYG{o}{)}\PYG{o}{,} \PYG{n}{P} \PYG{n}{a}
\PYG{k}{\PYGZsh{}check} \PYG{n+nb+bp}{Π} \PYG{o}{(}\PYG{n}{a} \PYG{o}{:} \PYG{n}{α}\PYG{o}{)}\PYG{o}{,} \PYG{n}{P} \PYG{n}{a}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Index}
\label{\detokenize{genindex:index}}\label{\detokenize{genindex::doc}}


\renewcommand{\indexname}{Index}
\printindex
\end{document}