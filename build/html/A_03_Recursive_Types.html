<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4. Recursive Types &mdash; CS6501 Spring 2023 1.2.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Dependent Types" href="A_04_Dependent_Types.html" />
    <link rel="prev" title="3. Constructive Logic" href="A_02_Constructive_Logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CS6501 Spring 2023
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="A_00_Introduction.html">1. CS6501 Spring 2023</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_01_Propositional_Logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_02_Constructive_Logic.html">3. Constructive Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Recursive Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">4.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#natural-numbers">4.2. Natural Numbers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-type">4.2.1. Data Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operations">4.2.2. Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#polymorphic-lists">4.3. Polymorphic Lists</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">4.3.1. Data Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notations">4.3.2. Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">4.3.3. Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-functions">4.3.4. Partial Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default-value">4.3.4.1. Default Value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#option-values">4.3.4.2. Option Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#precondition">4.3.4.3. Precondition</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">4.3.5. Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solutions">4.3.6. Solutions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#higher-order-functions">4.4. Higher-Order Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#in-logic">4.4.1. In Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition">4.4.2. Composition</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example">4.4.2.1. Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#notation">4.4.2.2. Notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-with-two-types">4.4.2.3. Example With Two Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#map">4.4.3. Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fold">4.4.4. Fold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary">4.4.5. Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">4.4.6. Exercises</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#recursive-proofs">4.5. Recursive Proofs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#proof-by-induction">4.5.1. Proof by Induction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-families">4.5.2. Inductive Families</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="A_04_Dependent_Types.html">5. Dependent Types</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CS6501 Spring 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">4. </span>Recursive Types</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/A_03_Recursive_Types.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="recursive-types">
<span id="introduction"></span><h1><span class="section-number">4. </span>Recursive Types<a class="headerlink" href="#recursive-types" title="Permalink to this heading">&#61633;</a></h1>
<section id="id1">
<h2><span class="section-number">4.1. </span>Introduction<a class="headerlink" href="#id1" title="Permalink to this heading">&#61633;</a></h2>
<p>In this chapter we&#8217;ll look at inductive data types
definitions that specify objects that have recursive
structure. In particular, we&#8217;ll look at the <em>nat</em> and
polymorphic <em>list</em> types, with an eye to seeing some
interesting algebraic commonalities.</p>
</section>
<section id="natural-numbers">
<h2><span class="section-number">4.2. </span>Natural Numbers<a class="headerlink" href="#natural-numbers" title="Permalink to this heading">&#61633;</a></h2>
<section id="data-type">
<h3><span class="section-number">4.2.1. </span>Data Type<a class="headerlink" href="#data-type" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20nat" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_8.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">nat</span>
</pre></div>
</div>
</div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20notations%20for%20writing%20succ%20applications%0Adef%20three'%20%20%3A%3D%20(nat.succ%20(nat.succ%20(nat.succ%20(nat.zero))))%0Adef%20three%20%20%3A%3D%20nat.zero.succ.succ.succ" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_13.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- notations for writing succ applications</span>
<span class="kd">def</span> <span class="n">three&#39;</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.zero</span><span class="o">))))</span>
<span class="kd">def</span> <span class="n">three</span>  <span class="o">:=</span> <span class="n">nat.zero.succ.succ.succ</span>
</pre></div>
</div>
</div></section>
<section id="operations">
<h3><span class="section-number">4.2.2. </span>Operations<a class="headerlink" href="#operations" title="Permalink to this heading">&#61633;</a></h3>
<p>Having seen how the <em>nat</em> data type is defined, we now look
at how to define functions taking <em>nat</em> values as arguments.
As we&#8217;ve seen before, many such functions here will again be
defined by case analysis on an incoming nat argument value.
That means considering two cases separately: the incoming value
is either zero or non-zero: that is, either <em>nat.zero,</em> or
<em>nat.succ n&#8217;</em> for some &#8220;one-smaller&#8221; value, <em>n&#8217;</em>. For example,
if the incoming argument is <em>succ(succ(succ zero))</em>, i.e., 3,
then (a) it does not match <em>nat.zero</em>, but (b) it does match
<em>nat.succ n&#8217;</em>, with <em>n&#8217;</em> is bound to <em>succ(succ zero)</em>, i.e., 2.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20increment%20is%20just%20succ%20application%0Adef%20inc%20(n'%20%3A%20nat)%20%3A%20nat%20%3A%3D%20n'.succ%0Adef%20three''%20%3A%3D%20inc(inc(inc%20nat.zero))" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_33.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- increment is just succ application</span>
<span class="kd">def</span> <span class="n">inc</span> <span class="o">(</span><span class="n">n&#39;</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">n&#39;.succ</span>
<span class="kd">def</span> <span class="n">three&#39;&#39;</span> <span class="o">:=</span> <span class="n">inc</span><span class="o">(</span><span class="n">inc</span><span class="o">(</span><span class="n">inc</span> <span class="n">nat.zero</span><span class="o">))</span>
</pre></div>
</div>
</div><p>A predecessor (one less than) function can be defined by
case analysis on a nat argument. Here we&#8217;ll define <em>pred&#8217;</em>
to return 0 when applied to 0, and otherwise to return the
one smaller value, <em>n&#8217;</em>, when applied to any non-zero value,
<em>nat.succ n&#8217;</em>.</p>
<p>Rather than &#8220;implementing a function&#8221; think &#8220;proving a function
type.&#8221; A &#8220;proof&#8221; of function type, <em>nat &#8594; nat,</em> is any function
that converts any given nat into some resulting nat.</p>
<p>When proving a proposition (a type in Prop), any proof (value
of that type) will do. When proving function or other data type,
however, the particular value of the type that you construct is
usually important. Here, for example, we don&#8217;t want any function
that takes and returns a nat, but one that returns the right nat
for the given argument.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20pred'%20%3A%20nat%20%E2%86%92%20nat%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%0Aexact%200%2C%20%20--%20when%20n%20is%20zero%0Aexact%20n'%2C%20--%20when%20n%20is%20succ%20n'%0Aend%0A%0A--%20quick%20test%0A%23eval%20pred'%206%0Aexample%20%3A%20pred'%206%20%3D%205%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_56.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">pred&#39;</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="n">exact</span> <span class="mi">0</span><span class="o">,</span>  <span class="c1">-- when n is zero</span>
<span class="n">exact</span> <span class="n">n&#39;</span><span class="o">,</span> <span class="c1">-- when n is succ n&#39;</span>
<span class="kd">end</span>

<span class="c1">-- quick test</span>
<span class="k">#eval</span> <span class="n">pred&#39;</span> <span class="mi">6</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">pred&#39;</span> <span class="mi">6</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Here&#8217;s the same function just specified
using pattern matching notation (which,
as we&#8217;ve seen generalizes case analysis).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20pred%20%3A%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20%3A%3D%20nat.zero%20%20--%20loop%20at%20zero%0A%7C%20(nat.succ%20n')%20%3A%3D%20n'%0A%0A%23eval%20pred%205%0Aexample%20%3A%20pred%205%20%3D%204%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_74.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">nat.zero</span>  <span class="c1">-- loop at zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="k">#eval</span> <span class="n">pred</span> <span class="mi">5</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">pred</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Pattern matching generalizes case analysis
by giving you a means to return different
results based on deeper analysis of argument
structures using pattern matching/unification.
This example implements subtract-two, looping
at zero. Notice how the third pattern matches
to the sub-natural-number object nested two
succ-levels deep.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20this%20example%20illustrates%20pattern%20matching%0A--%20for%20more%20fine-grained%20case%20analysis%0Adef%20sub2%20%3A%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20%3A%3D%20nat.zero%0A%7C%20(nat.succ%20nat.zero)%20%3A%3D%20nat.zero%0A%7C%20(nat.succ%20(nat.succ%20n'))%20%3A%3D%20n'%0A%0A--%20addition%20increments%20the%20second%20argument%0A--%20the%20first%20argument%20number%20of%20times%0Adef%20plus%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20m%20%3A%3D%20m%0A%7C%20(nat.succ%20n')%20m%20%3A%3D%20nat.succ%20(plus%20n'%20m)%0A%0A%23eval%20plus%203%204%0A%0A--%20multiplication%20adds%20the%20second%20argument%0A--%20to%20itself%20the%20first%20argumen%20number%20of%20times%0Adef%20times%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%200%20m%20%3A%3D%200%0A%7C%20(n'%2B1)%20m%20%3A%3D%20plus%20m%20(times%20n'%20m)%0A%0A%23eval%20times%205%204%0A%23eval%20times%201%2020%0A%0A%0A--%20substraction%20illustrates%20case%20analysis%20on%0A--%20multiple%20(here%20two)%20arguments%20at%20once%0Adef%20subtract%20%3A%20%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%200%20_%20%3A%3D%200%0A%7C%20n%200%20%3A%3D%20n%0A%7C%20(n'%20%2B%201)%20(m'%20%2B%201)%20%3A%3D%20subtract%20n'%20m'%0A%0A%23eval%20subtract%207%205%0A%23eval%20subtract%207%200%0A%23eval%20subtract%205%207%0A%23eval%20subtract%200%207%0A%0A%0A--%20exponentiation%20is%20multiplication%20of%20the%20second%0A--%20argument%20by%20itself%20the%20first%20argument%20number%20of%20times%0Adef%20power%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20n%20nat.zero%20%3A%3D%201%0A%7C%20n%20(nat.succ%20m')%20%3A%3D%20times%20n%20(power%20n%20m')%0A%0A--%20a%20few%20test%20cases%0Aexample%20%3A%20power%202%200%20%3D%201%20%3A%3D%20rfl%0Aexample%20%3A%20power%202%208%20%3D%20256%20%3A%3D%20rfl%0Aexample%20%3A%20power%202%2010%20%3D%201024%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_92.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- this example illustrates pattern matching</span>
<span class="c1">-- for more fine-grained case analysis</span>
<span class="kd">def</span> <span class="n">sub2</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">nat.zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">))</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="c1">-- addition increments the second argument</span>
<span class="c1">-- the first argument number of times</span>
<span class="kd">def</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">nat.succ</span> <span class="o">(</span><span class="n">plus</span> <span class="n">n&#39;</span> <span class="n">m</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">plus</span> <span class="mi">3</span> <span class="mi">4</span>

<span class="c1">-- multiplication adds the second argument</span>
<span class="c1">-- to itself the first argumen number of times</span>
<span class="kd">def</span> <span class="n">times</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">m</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n&#39;</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">plus</span> <span class="n">m</span> <span class="o">(</span><span class="n">times</span> <span class="n">n&#39;</span> <span class="n">m</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">times</span> <span class="mi">5</span> <span class="mi">4</span>
<span class="k">#eval</span> <span class="n">times</span> <span class="mi">1</span> <span class="mi">20</span>


<span class="c1">-- substraction illustrates case analysis on</span>
<span class="c1">-- multiple (here two) arguments at once</span>
<span class="kd">def</span> <span class="n">subtract</span> <span class="o">:</span>  <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n&#39;</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m&#39;</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subtract</span> <span class="n">n&#39;</span> <span class="n">m&#39;</span>

<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">7</span> <span class="mi">5</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">7</span> <span class="mi">0</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">5</span> <span class="mi">7</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">0</span> <span class="mi">7</span>


<span class="c1">-- exponentiation is multiplication of the second</span>
<span class="c1">-- argument by itself the first argument number of times</span>
<span class="kd">def</span> <span class="n">power</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">m&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">times</span> <span class="n">n</span> <span class="o">(</span><span class="n">power</span> <span class="n">n</span> <span class="n">m&#39;</span><span class="o">)</span>

<span class="c1">-- a few test cases</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">8</span> <span class="bp">=</span> <span class="mi">256</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">10</span> <span class="bp">=</span> <span class="mi">1024</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div></section>
</section>
<section id="polymorphic-lists">
<h2><span class="section-number">4.3. </span>Polymorphic Lists<a class="headerlink" href="#polymorphic-lists" title="Permalink to this heading">&#61633;</a></h2>
<section id="id2">
<h3><span class="section-number">4.3.1. </span>Data Type<a class="headerlink" href="#id2" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20list" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_8.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">list</span>
</pre></div>
</div>
</div><p>The list data type is surprising similar to the nat
data type. Where as a larger nat is constructed from
only a smaller nat, a larger list is constructed from
a new first element (the <em>head</em> of the new list) and
a smaller list (the <em>tail</em> of the new list). This type
builder enables us to represent lists of values of any
type and of any finite length.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0Ainductive%20list%20(T%20%3A%20Type%20u)%0A%7C%20nil%20%3A%20list%0A%7C%20cons%20(hd%20%3A%20T)%20(tl%20%3A%20list)%20%3A%20list" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_20.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span>
</pre></div>
</div>
</div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20example%3A%20let's%20represent%20the%20list%20of%20nats%2C%20%5B1%2C2%2C3%5D%0Adef%20three_list_nat''%20%3A%3D%0A%20%20list.cons%20%20%20--%20takes%20two%20arguments%0A%20%20%20%201%20%20%20%20%20%20%20%20%20--%20head%20of%20new%20list%0A%20%20%20%20(%20%20%20%20%20%20%20%20%20--%20tail%20list%20of%20the%20new%20list%0A%20%20%20%20%20%20list.cons%20%20%20--%20etc.%0A%20%20%20%20%20%20%20%202%0A%20%20%20%20%20%20%20%20(%0A%20%20%20%20%20%20%20%20%20%20list.cons%0A%20%20%20%20%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A--%20it%20seems%20to%20have%20worked%0A%23reduce%20three_list_nat''" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_28.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- example: let&#39;s represent the list of nats, [1,2,3]</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;</span> <span class="o">:=</span>
  <span class="n">list.cons</span>   <span class="c1">-- takes two arguments</span>
    <span class="mi">1</span>         <span class="c1">-- head of new list</span>
    <span class="o">(</span>         <span class="c1">-- tail list of the new list</span>
      <span class="n">list.cons</span>   <span class="c1">-- etc.</span>
        <span class="mi">2</span>
        <span class="o">(</span>
          <span class="n">list.cons</span>
            <span class="mi">3</span>
            <span class="n">list.nil</span>
        <span class="o">)</span>
    <span class="o">)</span>

<span class="c1">-- it seems to have worked</span>
<span class="k">#reduce</span> <span class="n">three_list_nat&#39;&#39;</span>
</pre></div>
</div>
</div></section>
<section id="notations">
<h3><span class="section-number">4.3.2. </span>Notations<a class="headerlink" href="#notations" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20notation%2C%20%3A%3A%20is%20infix%20for%20cons%0A--%20%5B%5D%20notation%20adds%20nil%20at%20end%0Adef%20three_list_nat'''%20%3A%3D%201%3A%3A2%3A%3A3%3A%3Alist.nil%0Adef%20three_list_nat''''%20%3A%3D%20%5B1%2C2%2C3%5D%0Adef%20four_list_nat%20%3A%3D%200%3A%3A%5B1%2C2%2C3%5D%20%20%20%20%20%20%20--%20fun!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_50.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- notation, :: is infix for cons</span>
<span class="c1">-- [] notation adds nil at end</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;&#39;</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">::</span><span class="mi">2</span><span class="o">::</span><span class="mi">3</span><span class="o">::</span><span class="n">list.nil</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;&#39;&#39;</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">four_list_nat</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">::[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>       <span class="c1">-- fun!</span>
</pre></div>
</div>
</div></section>
<section id="id3">
<h3><span class="section-number">4.3.3. </span>Operations<a class="headerlink" href="#id3" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20list%20prepend%20analogous%20to%20nat%20increment%0Adef%20prepend'%20(%CE%B1%20%3A%20Type)%20(a%20%3A%20%CE%B1)%20(l%20%3A%20list%20%CE%B1)%20%3A%3D%0A%20%20list.cons%20a%20l%0A%0Adef%20three_list_nat'%20%3A%3D%0A%20%20prepend'%20nat%0A%20%20%20%201%0A%20%20%20%20(prepend'%20nat%0A%20%20%20%20%20%202%0A%20%20%20%20%20%20(prepend'%20nat%0A%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A%23eval%20three_list_nat'%0A%0A--%20here%20with%20an%20implicit%20type%20parameter%2C%20making%20it%20equivalent%20to%20cons%0Adef%20prepend%20%7B%CE%B1%20%3A%20Type%7D%20(a%20%3A%20%CE%B1)%20(l%20%3A%20list%20%CE%B1)%20%3A%3D%0A%20%20list.cons%20a%20l%0A%0Adef%20three_list_nat%20%3A%3D%0A%20%20prepend%0A%20%20%20%201%0A%20%20%20%20(prepend%0A%20%20%20%20%20%202%0A%20%20%20%20%20%20(prepend%0A%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A--%20okay%2C%20that%20looks%20good%0A--%20but%20know%20that%20to%20which%20it%20desugars%0A%0Aexample%20%3A%3D%20prepend'%20nat%202%20%5B3%2C4%2C5%5D%0A%23eval%20prepend'%20nat%202%20%5B3%2C4%2C5%5D%0A%0Aexample%20%3A%3D%20prepend%202%20%5B3%2C4%2C5%5D%0A%23eval%20prepend%202%20%5B3%2C4%2C5%5D%0A%0A%23eval%202%3A%3A%5B3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_61.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- list prepend analogous to nat increment</span>
<span class="kd">def</span> <span class="n">prepend&#39;</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.cons</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">three_list_nat&#39;</span> <span class="o">:=</span>
  <span class="n">prepend&#39;</span> <span class="n">nat</span>
    <span class="mi">1</span>
    <span class="o">(</span><span class="n">prepend&#39;</span> <span class="n">nat</span>
      <span class="mi">2</span>
      <span class="o">(</span><span class="n">prepend&#39;</span> <span class="n">nat</span>
        <span class="mi">3</span>
        <span class="n">list.nil</span>
      <span class="o">)</span>
    <span class="o">)</span>

<span class="k">#eval</span> <span class="n">three_list_nat&#39;</span>

<span class="c1">-- here with an implicit type parameter, making it equivalent to cons</span>
<span class="kd">def</span> <span class="n">prepend</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.cons</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">three_list_nat</span> <span class="o">:=</span>
  <span class="n">prepend</span>
    <span class="mi">1</span>
    <span class="o">(</span><span class="n">prepend</span>
      <span class="mi">2</span>
      <span class="o">(</span><span class="n">prepend</span>
        <span class="mi">3</span>
        <span class="n">list.nil</span>
      <span class="o">)</span>
    <span class="o">)</span>

<span class="c1">-- okay, that looks good</span>
<span class="c1">-- but know that to which it desugars</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="n">prepend&#39;</span> <span class="n">nat</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">prepend&#39;</span> <span class="n">nat</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="n">prepend</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">prepend</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>

<span class="k">#eval</span> <span class="mi">2</span><span class="o">::[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
<section id="partial-functions">
<h3><span class="section-number">4.3.4. </span>Partial Functions<a class="headerlink" href="#partial-functions" title="Permalink to this heading">&#61633;</a></h3>
<p>Now we face some interesting issues. Our aim is to define
functions that <em>analyze</em> lists and return parts of them.
The problem is that there are no parts when a given list
is empty.</p>
<p>When we defined pred, above, we defined pred of zero to be
zero (rather than to be undefined). Doing that makes the
function total and easily represented as a function (lambda
abstractraction) in Lean. However, in a different application
we really might want to define pred 0 to be undefined, not 0.</p>
<p>A similar set of issues arises when we consider head and
tail functions on lists. When given non-empty lists there
is no problem. But what to do with an empty list argument?
There is no head or tail element to return, yet some value
of the specified type <em>has to be</em> returned.</p>
<p>Let&#8217;s see some fo the solutions that are available.</p>
<section id="default-value">
<h4><span class="section-number">4.3.4.1. </span>Default Value<a class="headerlink" href="#default-value" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20a%20version%20of%20tail%20that%20%22loops%20at%20zero%22%0Adef%20tail'%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%2C%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20%3A%3D%20list.nil%0A%7C%20%CE%B1%20(h%3A%3At)%20%3A%3D%20t%0A%23eval%20tail'%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_131.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- a version of tail that &quot;loops at zero&quot;</span>
<span class="kd">def</span> <span class="n">tail&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">t</span>
<span class="k">#eval</span> <span class="n">tail&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div><p>One nice thing about this solution
is that the function type is still about as natural as
can be: list &#945; &#8594; list &#945;.</p>
</section>
<section id="option-values">
<h4><span class="section-number">4.3.4.2. </span>Option Values<a class="headerlink" href="#option-values" title="Permalink to this heading">&#61633;</a></h4>
<p>The next solution changes the type of the function,
so that return value is in the form of a <em>variant</em>
type, a value of which is either <em>none</em> or <em>some
valid return value</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20head''%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%2C%20list%20%CE%B1%20%E2%86%92%20option%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20%3A%3D%20none%0A%7C%20%CE%B1%20(h%3A%3At)%20%3A%3D%20some%20h%0A%0A%23eval%20head''%20%5B1%2C2%2C3%5D%0A%23eval%20%40head''%20nat%20%5B%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_151.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">head&#39;&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">h</span>

<span class="k">#eval</span> <span class="n">head&#39;&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">head&#39;&#39;</span> <span class="n">nat</span> <span class="o">[]</span>
</pre></div>
</div>
</div></section>
<section id="precondition">
<h4><span class="section-number">4.3.4.3. </span>Precondition<a class="headerlink" href="#precondition" title="Permalink to this heading">&#61633;</a></h4>
<p>Finally, we can define a version of head&#8217; that (1) typechecks
as being a total function, (2) can never actually be applied
fully to an empty list, in which case (3) no real result has
to be specified to &#8220;prove the return type&#8221; because such a case
can&#8217;t happen. It would be a contradiction if it did, and so it
can be dismissed as an impossibility. Magic: It <em>is</em> a total
function, but it can never be fully appied to an empty list
because a required proof argument, for <em>that</em> list, can never
be given; so one can dismiss this case by false elimination,
without having to give an actual proof of the conclusion.</p>
<p>Consider a head function. It returns the head element from
a non-empty list, but is undefined mathematically when it&#8217;s
applied to an empty list. The key idea in the next design
is that we can embed a <em>precondition</em> for application of
the function, namely that the given list not be empty. Let&#8217;s
see how e might first write the function using a tactic
script, to take advantage of your familiarity with using
it to build proofs.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20head'%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20%CE%B1%0A%7C%20%20%CE%B1%20l%20p%20%3A%3D%0Abegin%0Acases%20l%2C%0Acontradiction%2C%0Aexact%20l_hd%2C%0Aend%0A%0A--%20When%20applying%20it%20a%20proof%20about%20the%20first%20argument%20has%20to%20be%20given%0A%23eval%20head'%20%5B1%2C2%2C3%5D%20begin%20contradiction%20end%20%20%20--%20proof%20as%20a%20proof%20script%0A%23eval%20head'%20%5B1%2C2%2C3%5D%20(by%20contradiction)%20%20%20%20%20%20%20%20--%20alternative%20syntax%2C%20fyi%0A%23eval%20head'%20(%5B%5D%20%3A%20list%20nat)%20_%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20you'll%20need%20a%20proof%20of%20list.nil%20%E2%89%A0%20list.nil!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_184.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">head&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="o">(</span><span class="n">l</span> <span class="bp">&#8800;</span> <span class="n">list.nil</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span>
<span class="bp">|</span>  <span class="n">&#945;</span> <span class="n">l</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">cases</span> <span class="n">l</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">l_hd</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- When applying it a proof about the first argument has to be given</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="kd">begin</span> <span class="n">contradiction</span> <span class="kd">end</span>   <span class="c1">-- proof as a proof script</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>        <span class="c1">-- alternative syntax, fyi</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">([]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">)</span> <span class="n">_</span>                 <span class="c1">-- you&#39;ll need a proof of list.nil &#8800; list.nil!</span>
</pre></div>
</div>
</div></section>
</section>
<section id="exercises">
<h3><span class="section-number">4.3.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">&#61633;</a></h3>
<ul class="simple">
<li><p>Write a version of the pred function that can only be called for argument values greater than 0.</p></li>
<li><p>Write a version of the pred function that returns an option nat value &#8220;in the usual way&#8221;</p></li>
<li><p>Write a tail function that can only be called with a non-empty list, using our &#8220;by cases&#8221; notation for function definition. It should look like tail&#8217;. Note 1: Where a proof value is required, you can always use tactic mode to construct the required proof, in a begin..end block. If such a proof is a single tactic long, you can write by &lt;tactic&gt;. For example, try by contradiction as the <em>result</em> when your new tail function is applied to an empty list. Here&#8217;s how I wrote the function type. You should provide the cases (on l). Here&#8217;s the type: def tail {&#945; : Type} : &#8704; (l : list &#945;), (l &#8800; list.nil) &#8594; list &#945;.</p></li>
</ul>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20implement%20the%20function%2C%20no%20need%20to%20(do%20not%20try)%20to%20match%20on%20%CE%B1%0A--%20it's%20named%20before%20the%20colon%20and%20is%20global%20to%20this%20definition%0A--%20we%20do%20want%20to%20match%20(do%20case%20analysis)%20on%20l%2C%20so%20it's%20after%20%3A%0A--%20def%20tail%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20%E2%88%80%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20list%20%CE%B1%0A--%20%7C%0A--%20%7C" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_206.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- implement the function, no need to (do not try) to match on &#945;</span>
<span class="c1">-- it&#39;s named before the colon and is global to this definition</span>
<span class="c1">-- we do want to match (do case analysis) on l, so it&#39;s after :</span>
<span class="c1">-- def tail {&#945; : Type} : &#8704; (l : list &#945;), (l &#8800; list.nil) &#8594; list &#945;</span>
<span class="c1">-- |</span>
<span class="c1">-- |</span>
</pre></div>
</div>
</div></section>
<section id="solutions">
<h3><span class="section-number">4.3.6. </span>Solutions<a class="headerlink" href="#solutions" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20let's%20implement%20a%20%22safe%22%20pred%20function%20using%20tactics%0Adef%20pred'%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20(n%20%E2%89%A0%20nat.zero)%20%E2%86%92%20%E2%84%95%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%0Aassume%20h%2C%0Acontradiction%2C%0Aassume%20h%2C%0Aexact%20n'%2C%0Aend%0A%0A%23reduce%20pred'%205%20_%0A%23reduce%20pred'%202%20_%0A%23reduce%20pred'%200%20_%0A%0A--%20here's%20the%20same%20predecessor%20function%20presented%20differently%0Adef%20pred''%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20(n%20%E2%89%A0%20nat.zero)%20%E2%86%92%20%E2%84%95%0A%7C%20nat.zero%20h%20%3A%3D%20by%20contradiction%0A%7C%20(nat.succ%20n')%20h%20%3A%3D%20n'%0A%0A--%20a%20different%20safe%20predecessor%20function%20using%20an%20option%20return%0Adef%20pred'''%20%3A%20nat%20%E2%86%92%20option%20nat%0A%7C%20nat.zero%20%3A%3D%20option.none%0A%7C%20(nat.succ%20n')%20%3A%3D%20some%20n'%0A%0A--%20the%20same%20ideas%20work%20for%20safe%20head%20and%20tail%20functions%20on%20lists%0Auniverse%20u%0Adef%20tail%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%20u%7D%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20list%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20p%20%3A%3D%20by%20contradiction%0A%7C%20%CE%B1%20(h%3A%3At)%20p%20%3A%3D%20t%0A%0A--%20apply%20tail%20to%20%5B1%2C2%2C3%5D%20giving%20the%20proof%20as%20a%20tactic%20script%0A%23eval%20tail%20%5B1%2C2%2C3%5D%0Abegin%0Aassume%20p%2C%0Acontradiction%2C%0Aend%0A%0A--%20cleaner%20this%20way%0A%23eval%20tail%20%5B1%2C2%2C3%5D%20(by%20contradiction)%0A%23eval%20tail%20%5B2%2C3%5D%20(by%20contradiction)%0A%23eval%20tail%20%5B3%5D%20(by%20contradiction)%0A%23eval%20%40tail%20nat%20%5B%5D%20(by%20contradiction)%20%20%20%20%20%20--%20no%20can%20do!%0A%0A--%20let's%20try%20it%20with%20a%20tactic%20script%0A%23eval%20%40tail%20nat%20%5B%5D%0Abegin%0Aassume%20h%2C%20%20%20--%20we're%20stuck%2C%20and%20that's%20good!%0Aend%0A%0A%0A--%20append%3A%20the%20list%20analog%20of%20natural%20number%20addition%0A--%20please%20do%20compare%2Fcontrast%20list.append%20and%20nat.add%0Adef%20appnd%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20list.nil%20m%20%3A%3D%20m%0A%7C%20(h%3A%3At)%20m%20%3A%3D%20h%3A%3Aappnd%20t%20m%0A%0A%23eval%20appnd%20%5B1%2C2%2C3%5D%20%5B4%2C3%2C2%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_218.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- let&#39;s implement a &quot;safe&quot; pred function using tactics</span>
<span class="kd">def</span> <span class="n">pred&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&#8800;</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">5</span> <span class="n">_</span>
<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">2</span> <span class="n">_</span>
<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">0</span> <span class="n">_</span>

<span class="c1">-- here&#39;s the same predecessor function presented differently</span>
<span class="kd">def</span> <span class="n">pred&#39;&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&#8800;</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="n">h</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="c1">-- a different safe predecessor function using an option return</span>
<span class="kd">def</span> <span class="n">pred&#39;&#39;&#39;</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">option.none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">n&#39;</span>

<span class="c1">-- the same ideas work for safe head and tail functions on lists</span>
<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">def</span> <span class="n">tail</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="o">(</span><span class="n">l</span> <span class="bp">&#8800;</span> <span class="n">list.nil</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">t</span>

<span class="c1">-- apply tail to [1,2,3] giving the proof as a tactic script</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">p</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- cleaner this way</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">tail</span> <span class="n">nat</span> <span class="o">[]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>      <span class="c1">-- no can do!</span>

<span class="c1">-- let&#39;s try it with a tactic script</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">tail</span> <span class="n">nat</span> <span class="o">[]</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>   <span class="c1">-- we&#39;re stuck, and that&#39;s good!</span>
<span class="kd">end</span>


<span class="c1">-- append: the list analog of natural number addition</span>
<span class="c1">-- please do compare/contrast list.append and nat.add</span>
<span class="kd">def</span> <span class="n">appnd</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">h</span><span class="o">::</span><span class="n">appnd</span> <span class="n">t</span> <span class="n">m</span>

<span class="k">#eval</span> <span class="n">appnd</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
</section>
<section id="higher-order-functions">
<h2><span class="section-number">4.4. </span>Higher-Order Functions<a class="headerlink" href="#higher-order-functions" title="Permalink to this heading">&#61633;</a></h2>
<p>A higher-order function is simply a function that
takes functions as arguments and/or that returns a
function as a result.</p>
<section id="in-logic">
<h3><span class="section-number">4.4.1. </span>In Logic<a class="headerlink" href="#in-logic" title="Permalink to this heading">&#61633;</a></h3>
<p>We&#8217;ve already seen this idea in logical reasoning,
where function values are proofs of implications.
In this chapter, we&#8217;ll see that same idea in the
realm of computation.</p>
<p>Let&#8217;s start by reviewing a logical example to
refresh memories. We&#8217;ll review the proof that
<em>implication is transitive</em>: if the truth of some
proposition, P, implies the truth of Q, and if the
truth of Q implies the truth of R, then the truth
of P implies that of R. Thinking computationally,
if we have a function, pq, that converts any proof
of P into a proof of Q (a proof of P &#8594; Q), and a
function, qr, that converts any proof of Q into a
proof of R (a proof of Q &#8594; R), then we can build
a function, pr, that converts any proof, p, of P,
into a proof of R (the desired proof of P &#8594; R) by
applying the proof of P &#8594; Q to p to get a proof of
Q, and by then applying the proof of Q &#8594; R to that
value to get a proof of R. Here it is formally.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%7BP%20Q%20R%20%3A%20Prop%7D%20%3A%20(P%20%E2%86%92%20Q)%20%E2%86%92%20(Q%20%E2%86%92%20R)%20%E2%86%92%20(P%20%E2%86%92%20R)%20%3A%3D%0Abegin%0Aassume%20pq%20qr%2C%20%20%20--%20assume%20P%20%E2%86%92%20Q%20and%20Q%20%E2%86%92%20R%0Aassume%20p%2C%20%20%20%20%20%20%20--%20to%20show%20P%20%E2%86%92%20R%2C%20assume%20p%20a%20proof%20of%20P%0Aexact%20qr%20(pq%20p)%20--%20and%20derive%20the%20desired%20proof%20of%20R%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_33.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">Q</span> <span class="bp">&#8594;</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">pq</span> <span class="n">qr</span><span class="o">,</span>   <span class="c1">-- assume P &#8594; Q and Q &#8594; R</span>
<span class="k">assume</span> <span class="n">p</span><span class="o">,</span>       <span class="c1">-- to show P &#8594; R, assume p a proof of P</span>
<span class="n">exact</span> <span class="n">qr</span> <span class="o">(</span><span class="n">pq</span> <span class="n">p</span><span class="o">)</span> <span class="c1">-- and derive the desired proof of R</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This proof is a higher-order function, albeit in the
realm of logic not computation with ordinary data. It
takes two function arguments (one proving of P &#8594; Q and
the second proving Q &#8594; R) and returns a function that,
by converting any proof of P into a proof of R, proves
P &#8594; R. Therefore, (P &#8594; Q) &#8594; (Q &#8594; R) &#8594; (P &#8594; R). That is,
<em>implication is transitive</em>.</p>
</section>
<section id="composition">
<h3><span class="section-number">4.4.2. </span>Composition<a class="headerlink" href="#composition" title="Permalink to this heading">&#61633;</a></h3>
<p>What do we get when we construct the same argument not
for proofs of logical propositions but for functions on
ordinary data? What we get is a higher-order function
that performs <em>function composition</em>. Note the change
from Prop (logic) to Type (computation) in the following
definition.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%3A%20Type%7D%20%3A%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%E2%86%92%20(%CE%B2%20%E2%86%92%20%CE%B3)%20%E2%86%92%20(%CE%B1%20%E2%86%92%20%CE%B3)%20%3A%3D%0Abegin%0Aassume%20%CE%B1%CE%B2%20%CE%B2%CE%B3%2C%20%20%20--%20assume%20f%20g%0Aassume%20a%20%3A%20%CE%B1%2C%20%20%20--%20assume%20a%0Aexact%20%CE%B2%CE%B3%20(%CE%B1%CE%B2%20a)%20--%20return%20%CE%BB%20a%2C%20g%20(f%20a)%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_60.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">&#945;&#946;</span> <span class="n">&#946;&#947;</span><span class="o">,</span>   <span class="c1">-- assume f g</span>
<span class="k">assume</span> <span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">,</span>   <span class="c1">-- assume a</span>
<span class="n">exact</span> <span class="n">&#946;&#947;</span> <span class="o">(</span><span class="n">&#945;&#946;</span> <span class="n">a</span><span class="o">)</span> <span class="c1">-- return &#955; a, g (f a)</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Compare and contrast this definition with the statement
and proof of the transitivity of implication. See that
you&#8217;ve already been using higher-order functions albeit
to reason with functions that serve as proofs of logical
implications, rather than with with functions on ordinary
data.</p>
<p>Let&#8217;s write this definition a little more naturally,
and give it a name: <em>comp</em>, short for  <em>composition</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20comp%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%3A%20Type%7D%20(f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2)%20(g%20%3A%20%CE%B2%20%E2%86%92%20%CE%B3)%20%3A%20%CE%B1%20%E2%86%92%20%CE%B3%20%3A%3D%0Afun%20(a%20%3A%20%CE%B1)%2C%20g%20(f%20a)" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_79.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">)</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">),</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span>
</pre></div>
</div>
</div><section id="example">
<h4><span class="section-number">4.4.2.1. </span>Example<a class="headerlink" href="#example" title="Permalink to this heading">&#61633;</a></h4>
<p>Let&#8217;s see an example. Suppose we have two functions, <em>inc</em>
that increments a natural number and sqr that squares one.
We can form a function that first increments then squares
its argument by <em>composing</em> these two functions.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20inc%20(n%20%3A%20%E2%84%95)%20%3A%3D%20n%20%2B%201%0Adef%20sqr%20(n%20%3A%20%E2%84%95)%20%3A%3D%20n%20*%20n%0Adef%20inc_then_sqr%20%3A%3D%20comp%20inc%20sqr%0Aexample%20%3A%20inc_then_sqr%205%20%3D%2036%20%3A%3D%20rfl%20%20%20--%20seems%20to%20work!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_93.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">inc</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="kd">def</span> <span class="n">sqr</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span>
<span class="kd">def</span> <span class="n">inc_then_sqr</span> <span class="o">:=</span> <span class="n">comp</span> <span class="n">inc</span> <span class="n">sqr</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">inc_then_sqr</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">36</span> <span class="o">:=</span> <span class="n">rfl</span>   <span class="c1">-- seems to work!</span>
</pre></div>
</div>
</div></section>
<section id="notation">
<h4><span class="section-number">4.4.2.2. </span>Notation<a class="headerlink" href="#notation" title="Permalink to this heading">&#61633;</a></h4>
<p>Lean defines the infix operator &#8728; as notation for function
composition. Note that the order of the function arguments
is reversed. (g &#8728; f) is the function that applies g after
applying f to its argument. That is, (g &#8728; f) x = g (f x).
We pronounce the function, (g &#8728; f), as <em>g after f.</em></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20inc_then_sqr'%20%3A%3D%20sqr%20%E2%88%98%20inc%20%20%20%20%20%20%20%20--%20composition!%0Aexample%20%3A%20inc_then_sqr'%205%20%3D%2036%20%3A%3D%20rfl%20--%20seems%20to%20work!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_110.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">inc_then_sqr&#39;</span> <span class="o">:=</span> <span class="n">sqr</span> <span class="bp">&#8728;</span> <span class="n">inc</span>        <span class="c1">-- composition!</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">inc_then_sqr&#39;</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">36</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- seems to work!</span>
</pre></div>
</div>
</div></section>
<section id="example-with-two-types">
<h4><span class="section-number">4.4.2.3. </span>Example With Two Types<a class="headerlink" href="#example-with-two-types" title="Permalink to this heading">&#61633;</a></h4>
<p>In this example, given functions that compute the length
of a list and decrement a natural number, we construct a
function that takes a list of objects and returns one less
than its length. We first illustrate applications of Lean
functions for length and decrement and then use both our
notation and the Lean &#8728; notation to construct the desired
function, which we apply to the list [1,2,3] yielding the
value, 2.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23eval%20list.length%20%5B1%2C2%2C3%5D%20--%20apply%20length%20function%20to%20list%0A%23eval%20%5B1%2C2%2C3%5D.length%20%20%20%20%20%20--%20function%20application%20notation%0A%23eval%20nat.pred%203%20%20%20%20%20%20%20%20%20%20--%20apply%20decrement%20function%20to%203%0A%0A--%20Apply%20composition%20of%20length%20and%20pred%20to%20list%0A%23eval%20(comp%20list.length%20nat.pred)%20%5B1%2C2%2C3%5D%0A%23eval%20(nat.pred%20%E2%88%98%20list.length)%20%5B1%2C2%2C3%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_128.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">list.length</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="c1">-- apply length function to list</span>
<span class="k">#eval</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">length</span>      <span class="c1">-- function application notation</span>
<span class="k">#eval</span> <span class="n">nat.pred</span> <span class="mi">3</span>          <span class="c1">-- apply decrement function to 3</span>

<span class="c1">-- Apply composition of length and pred to list</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">comp</span> <span class="n">list.length</span> <span class="n">nat.pred</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">nat.pred</span> <span class="bp">&#8728;</span> <span class="n">list.length</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
</div><p>The infix notation is best. Think of the argument, here the
list [1,2,3], as moving left through list.length, yielding 3,
which then moves left through nat.pred, finally yielding 2.</p>
</section>
</section>
<section id="map">
<h3><span class="section-number">4.4.3. </span>Map<a class="headerlink" href="#map" title="Permalink to this heading">&#61633;</a></h3>
<p>In this section, we introduce the <em>map</em> function on lists.
It takes (1) a function that takes objects of some type
&#945; and converts them into objects of some type &#946;, and (2) a
list of objects of type &#945;, and returns a list of objects
of type &#946;, obtained by using the function to turn each each
&#945; object in the given list into a corresponding &#946; object
in the resulting list.</p>
<p>We build to a general definition of map starting with a
special case: of a function that takes a list of natural
numbers and returns a list in which each is increased by
one, by the application of <em>inc</em>, our increment function.</p>
<p>We define a function that &#8220;maps&#8221; the increment function
over a given list of natural numbers by case analysis on
any given list. If the given list is nil, we return nil;
otherwise, if the list is (h::t) we return the list with
the value of (inc h) at its head and the list obtained
by similarly incrementing each value in the tail of the
given list as its tail.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20inc_list_nat%20%3A%20list%20nat%20%E2%86%92%20list%20nat%0A%7C%20list.nil%20%3A%3D%20list.nil%0A%7C%20(h%3A%3At)%20%3A%3D%20(inc%20h)%3A%3Ainc_list_nat%20t%0A%0A--%20it%20works%0A%23eval%20inc_list_nat%5B%5D%20%20%20%20%20%20%20%20--%20expect%20%5B%5D%0A%23eval%20inc_list_nat%20%5B1%2C2%2C3%5D%20%20--%20expect%20%5B2%2C3%2C4%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_166.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">inc_list_nat</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">inc</span> <span class="n">h</span><span class="o">)::</span><span class="n">inc_list_nat</span> <span class="n">t</span>

<span class="c1">-- it works</span>
<span class="k">#eval</span> <span class="n">inc_list_nat</span><span class="o">[]</span>        <span class="c1">-- expect []</span>
<span class="k">#eval</span> <span class="n">inc_list_nat</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>  <span class="c1">-- expect [2,3,4]</span>
</pre></div>
</div>
</div><p>Suppose that instead of incrementing each element
of a given list to obtain a new list, we want to
square each element. One way to do it is to clone
the function above and replace inc with sqr.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20sqr_list_nat%20%3A%20list%20nat%20%E2%86%92%20list%20nat%0A%7C%20list.nil%20%3A%3D%20list.nil%0A%7C%20(h%3A%3At)%20%3A%3D%20(sqr%20h)%3A%3Asqr_list_nat%20t%0A%0A--%20It%20works%0A%23eval%20sqr_list_nat%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_182.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">sqr_list_nat</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">sqr</span> <span class="n">h</span><span class="o">)::</span><span class="n">sqr_list_nat</span> <span class="n">t</span>

<span class="c1">-- It works</span>
<span class="k">#eval</span> <span class="n">sqr_list_nat</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div><p>Clearly we can clone and edit the preceding code
to produce a version that applies <em>any</em> function of
type nat &#8594; nat, instead of inc or sqr, to the head
of the given list, with all of the remaining code
unchanged, to map given lists of natural numbers
to new lists by replacement of existing elements
with new elements computed by application of the
given function.</p>
<p>That all the code remains the same but for the
<em>element</em> converting function suggests that we
can instead <em>generalize</em> by making this function
a <em>parameter</em> of the otherwise unchanging code.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20any_list_nat%20%3A%20(nat%20%E2%86%92%20nat)%20%E2%86%92%20list%20nat%20%E2%86%92%20list%20nat%0A%7C%20f%20list.nil%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%3A%3D%20f%20h%3A%3Aany_list_nat%20f%20t%0A%0A--%20It%20seems%20to%20work!%0Aexample%20%3A%20any_list_nat%20sqr%20%5B1%2C2%2C3%2C4%2C5%5D%20%3D%20%5B1%2C4%2C9%2C16%2C25%5D%20%3A%3D%20rfl%0Aexample%20%3A%20any_list_nat%20inc%20%5B1%2C2%2C3%2C4%2C5%5D%20%3D%20%5B2%2C3%2C4%2C5%2C6%5D%20%3A%3D%20rfl%0Aexample%20%3A%20any_list_nat%20nat.pred%20%5B1%2C2%2C3%2C4%2C5%5D%20%3D%20%5B0%2C1%2C2%2C3%2C4%5D%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_205.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">any_list_nat</span> <span class="o">:</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">h</span><span class="o">::</span><span class="n">any_list_nat</span> <span class="n">f</span> <span class="n">t</span>

<span class="c1">-- It seems to work!</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">any_list_nat</span> <span class="n">sqr</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">25</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">any_list_nat</span> <span class="n">inc</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">any_list_nat</span> <span class="n">nat.pred</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>We&#8217;ve generalized the nat &#8594; nat function, but suppose we wanted
to convert a list of <em>strings</em> to a list of their natural number
lengths. We don&#8217;t have the machinery to do that yet, as we can
only map functions over lists of natural numbers. Otherwise we
get a type error.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23eval%20any_list_nat%20string.length%20%5B%22I%22%2C%20%22Love%22%2C%20%22Math%22%5D%20%20--%20nope!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_222.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">any_list_nat</span> <span class="n">string.length</span> <span class="o">[</span><span class="s2">&quot;I&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;Math&quot;</span><span class="o">]</span>  <span class="c1">-- nope!</span>
</pre></div>
</div>
</div><p>One solution is simply to write a new version of our mapping
function specialized to map lists of strings to lists of nat
values, using any given string &#8594; nat function to perform the
element-wise mapping.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20xyz_list_nat%20%3A%20(string%20%E2%86%92%20nat)%20%E2%86%92%20list%20string%20%E2%86%92%20list%20nat%0A%7C%20f%20list.nil%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%3A%3D%20f%20h%3A%3Axyz_list_nat%20f%20t%0A%0A--%20It%20seems%20to%20work%0A%23eval%20xyz_list_nat%20string.length%20%5B%22I%22%2C%20%22Love%22%2C%20%22Math%22%5D%0A%0A%2F-%0ABut%20we%20run%20into%20the%20same%20problem%20as%20before%20if%20we%20now%20want%0Ato%20map%20lists%20of%20strings%20to%20Boolean%20values%2C%20e.g.%2C%20reflecting%0Awhether%20the%20length%20of%20each%20string%20is%20even%20(tt)%20or%20not%20(ff).%0ACloning%20code%20and%20editing%20it%20to%20produce%20another%20special%20case%0Ais%20really%20not%20the%20best%20solution.%0A-%2F%0Adef%20map_string_bool%20%3A%20(string%20%E2%86%92%20bool)%20%E2%86%92%20list%20string%20%E2%86%92%20list%20bool%0A%7C%20f%20list.nil%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%3A%3D%20f%20h%3A%3Amap_string_bool%20f%20t%0A%0A--%20is_even%20takes%20a%20nat%20and%20return%20tt%20if%20it's%20even%20else%20ff%0A--%0Adef%20is_even%20(n%20%3A%20nat)%20%3A%20bool%20%3A%3D%20n%20%25%202%20%3D%200%0A%23eval%20is_even%202%0A%23eval%20is_even%203%0A%0A%2F-%0ANow%20we%20can%20map%20a%20function%20that%20tells%20whether%20a%20given%20string%0Ais%20of%20even%20length%20or%20not%20over%20any%20given%20list%20of%20strings%20to%0Aget%20a%20corresponding%20list%20of%20tt%2Fff%20values.%0A-%2F%0Adef%20is_even_length%20%3A%3D%20is_even%20%E2%88%98%20string.length%0A%23eval%20map_string_bool%20is_even_length%20%5B%22I%22%2C%20%22Love%22%2C%20%22Math%22%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_231.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">xyz_list_nat</span> <span class="o">:</span> <span class="o">(</span><span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">h</span><span class="o">::</span><span class="n">xyz_list_nat</span> <span class="n">f</span> <span class="n">t</span>

<span class="c1">-- It seems to work</span>
<span class="k">#eval</span> <span class="n">xyz_list_nat</span> <span class="n">string.length</span> <span class="o">[</span><span class="s2">&quot;I&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;Math&quot;</span><span class="o">]</span>

<span class="c">/-</span>
<span class="cm">But we run into the same problem as before if we now want</span>
<span class="cm">to map lists of strings to Boolean values, e.g., reflecting</span>
<span class="cm">whether the length of each string is even (tt) or not (ff).</span>
<span class="cm">Cloning code and editing it to produce another special case</span>
<span class="cm">is really not the best solution.</span>
<span class="cm">-/</span>
<span class="kd">def</span> <span class="n">map_string_bool</span> <span class="o">:</span> <span class="o">(</span><span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">h</span><span class="o">::</span><span class="n">map_string_bool</span> <span class="n">f</span> <span class="n">t</span>

<span class="c1">-- is_even takes a nat and return tt if it&#39;s even else ff</span>
<span class="c1">--</span>
<span class="kd">def</span> <span class="n">is_even</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="k">#eval</span> <span class="n">is_even</span> <span class="mi">2</span>
<span class="k">#eval</span> <span class="n">is_even</span> <span class="mi">3</span>

<span class="c">/-</span>
<span class="cm">Now we can map a function that tells whether a given string</span>
<span class="cm">is of even length or not over any given list of strings to</span>
<span class="cm">get a corresponding list of tt/ff values.</span>
<span class="cm">-/</span>
<span class="kd">def</span> <span class="n">is_even_length</span> <span class="o">:=</span> <span class="n">is_even</span> <span class="bp">&#8728;</span> <span class="n">string.length</span>
<span class="k">#eval</span> <span class="n">map_string_bool</span> <span class="n">is_even_length</span> <span class="o">[</span><span class="s2">&quot;I&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;Math&quot;</span><span class="o">]</span>
</pre></div>
</div>
</div><p>Of course well run into exactly the same sort of problem,
of having to engage in error-prone cloning and editing of
code, if we want to now map lists of Boolean values to lists
of strings (e.g., mapping each tt to &#8220;T&#8221; and each ff to &#8220;F&#8221;).</p>
<p>And you can imagine many other examples: mapping lists of
employees to list of their corresponding salaries, or mapping
lists of Boolean values to lists of their negations, etc. The
possibilities are endless.</p>
<p>The answer should now we pretty clear: we need to further
generalize: not only over the function to apply to map each
list element, but also over the the types of element in the
input and output lists! Here, then, is a greatly generalized
version.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20map_list%20%7B%CE%B1%20%CE%B2%20%3A%20Type%7D%20%3A%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B2%0A%7C%20f%20list.nil%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%3A%3D%20f%20h%20%3A%3A%20map_list%20f%20t%0A%0A--%20It%20seems%20to%20work!%0A%23eval%20map_list%20nat.succ%20%5B1%2C2%2C3%5D%0A%23eval%20map_list%20is_even_length%20%5B%22I%22%2C%20%22Love%22%2C%20%22Math%22%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_281.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">map_list</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#946;</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">h</span> <span class="o">::</span> <span class="n">map_list</span> <span class="n">f</span> <span class="n">t</span>

<span class="c1">-- It seems to work!</span>
<span class="k">#eval</span> <span class="n">map_list</span> <span class="n">nat.succ</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">map_list</span> <span class="n">is_even_length</span> <span class="o">[</span><span class="s2">&quot;I&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;Math&quot;</span><span class="o">]</span>
</pre></div>
</div>
</div><p>For now, we&#8217;ll be satisfied with this level of generality.
We will just observe that our mapping function still only
works for <em>lists</em> as element containers. What if you wanted
to map functions over other kinds of element &#8220;containers,&#8221;
e.g., to turn values of type <em>option &#945;</em> into <em>option &#946;s</em>?
Or trees of &#945; values into corresponding trees of &#946; values?</p>
<p>The key roadblock will be that there&#8217;s no way to do this
using exactly the same code for, say, lists and options.
So the kind of parametric polymorphism we&#8217;ve been using
will no longer be enough. The answer will be found in a
different kind of polymorphism, <em>ad hoc</em> polynorphism, of
which <em>operator overloading</em> (as in C++) is an example.
For instance, you can write complex number and string
classes and overload the + operator in each class to do
respective complex number addition and string append, but
the implementations of these operations will hardly share
the same code. Completely different implementations will
be needed, to be selected (by the compler in C++) based
on the types of the arguments to which the + operator is
applied.  More on this topic later.</p>
</section>
<section id="fold">
<h3><span class="section-number">4.4.4. </span>Fold<a class="headerlink" href="#fold" title="Permalink to this heading">&#61633;</a></h3>
<p>We now turn to a very different higher-order function
appliable to lists. It&#8217;s called <em>fold</em> (or event better,
<em>fold_right</em>) or <em>reduce</em>.</p>
<p>The fundamental purpose of this operation is to turn a
<em>binary</em> operation on the values of any given type (e.g.,
nat) into an operation that can be applied to <em>any</em> number
of arguments, where the arguments are packaged into a list
data structure.</p>
<p>The way the generalized version of the binary operation
works is that for the empty list it returns a base value,
and for a non-empty list, <em>h::t</em>, it applies the binary
operation to <em>h</em> and <em>to the result of applying the n-ary
version to the rest of the list, *t</em>.</p>
<p>As an example, fold will turn the addition function on
natural numbers (nat.add) into an operation that can be
applied to a list of any number of natural number values
to compute the sum of them all. Here, for example, is
such a program.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20reduce_sum%20%3A%20list%20nat%20%E2%86%92%20nat%0A%7C%20list.nil%20%3A%3D%200%0A%7C%20(h%3A%3At)%20%3A%3D%20nat.add%20h%20(reduce_sum%20t)%0A%0A%23eval%20reduce_sum%20%5B%5D%20%20%20%20%20%20%20%20%20%20%20--%20sum%20of%20zero%20arguments%0A%23eval%20reduce_sum%20%5B5%5D%20%20%20%20%20%20%20%20%20%20--%20sum%20of%20one%20argument%0A%23eval%20reduce_sum%20%5B5%2C4%5D%20%20%20%20%20%20%20%20--%20sum%20of%20two%20arguments%0A%23eval%20reduce_sum%20%5B5%2C4%2C3%2C2%2C1%5D%20%20--%20sum%20of%20five%20arguments" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_338.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">reduce_sum</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.add</span> <span class="n">h</span> <span class="o">(</span><span class="n">reduce_sum</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">reduce_sum</span> <span class="o">[]</span>           <span class="c1">-- sum of zero arguments</span>
<span class="k">#eval</span> <span class="n">reduce_sum</span> <span class="o">[</span><span class="mi">5</span><span class="o">]</span>          <span class="c1">-- sum of one argument</span>
<span class="k">#eval</span> <span class="n">reduce_sum</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>        <span class="c1">-- sum of two arguments</span>
<span class="k">#eval</span> <span class="n">reduce_sum</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>  <span class="c1">-- sum of five arguments</span>
</pre></div>
</div>
</div><p>It should be clear that we will want to generalize
the binary operator from nat.add to <em>any</em> binary
operation on natural numbers. For example, we might
want a function that implements n-ary multiplication,
reducing any list of natural numbers to the product
of all the numbers in the list.</p>
<p>This is a little bit tricker than one might guess.
To see the problem, let&#8217;s clone and edit the code
we&#8217;ve got, substituting multiplication for addition,
in an attempt to implement n-ary multiplication.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20reduce_prod'%20%3A%20list%20nat%20%E2%86%92%20nat%0A%7C%20list.nil%20%3A%3D%200%0A%7C%20(h%3A%3At)%20%3A%3D%20nat.mul%20h%20(reduce_prod'%20t)%0A%0A%23eval%20reduce_prod'%20%5B3%2C2%2C1%5D%20%20%20--%20expect%206%20got%200!%0A%0A%2F-%0ATo%20see%20what%20goes%20wrong%2C%20let's%20unroll%20the%20recursion%3A%0A-%20reduce_prod'%20%5B3%2C2%2C1%5D%20%3D%0A-%20mul%203%20(reduce_prod'%20%5B2%2C1%5D)%20%3D%0A-%20mul%203%20(mul%202%20(reduce_prod'%20%5B1%5D))%20%3D%0A-%20mul%203%20(mul%202%20(mul%201%20(reduce_prod'%20%5B%5D)))%20%3D%0A-%20mul%203%20(mul%202%20(mul%201%200))%20%3D%200!%0AThe%20problem%20is%20now%20clear%2C%20and%20so%20is%20the%20solution%3A%0Awe%20need%20to%20return%20a%20different%20value%20for%20the%20base%0Acase%20of%20an%20empty%20list%20when%20the%20binary%20operation%20is%0Amultiplication%20rather%20than%20addition.%20Specifically%2C%0Awe%20need%20to%20return%201%20rather%20than%20zero.%20You%20can%20now%0Aprobably%20guess%20that%20in%20general%20we%20want%20to%20return%0Athe%20*identity%2C%20or%20neutral%2C%20value*%20for%20whatever%0Athe%20binary%20operator%20is%20for%20the%20base%20case.%20Here%0Awe%20want%20to%20return%201.%0A-%2F%0A%0Adef%20reduce_prod%20%3A%20list%20nat%20%E2%86%92%20nat%0A%7C%20list.nil%20%3A%3D%201%0A%7C%20(h%3A%3At)%20%3A%3D%20nat.mul%20h%20(reduce_prod%20t)%0A%0A%23eval%20reduce_prod%20%5B%5D%20%20%20%20%20%20%20%20%20%20--%20expect%201%0A%23eval%20reduce_prod%20%5B5%2C4%2C3%2C2%2C1%5D%20--%20expect%20120" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_361.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">reduce_prod&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.mul</span> <span class="n">h</span> <span class="o">(</span><span class="n">reduce_prod&#39;</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">reduce_prod&#39;</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>   <span class="c1">-- expect 6 got 0!</span>

<span class="c">/-</span>
<span class="cm">To see what goes wrong, let&#39;s unroll the recursion:</span>
<span class="cm">- reduce_prod&#39; [3,2,1] =</span>
<span class="cm">- mul 3 (reduce_prod&#39; [2,1]) =</span>
<span class="cm">- mul 3 (mul 2 (reduce_prod&#39; [1])) =</span>
<span class="cm">- mul 3 (mul 2 (mul 1 (reduce_prod&#39; []))) =</span>
<span class="cm">- mul 3 (mul 2 (mul 1 0)) = 0!</span>
<span class="cm">The problem is now clear, and so is the solution:</span>
<span class="cm">we need to return a different value for the base</span>
<span class="cm">case of an empty list when the binary operation is</span>
<span class="cm">multiplication rather than addition. Specifically,</span>
<span class="cm">we need to return 1 rather than zero. You can now</span>
<span class="cm">probably guess that in general we want to return</span>
<span class="cm">the *identity, or neutral, value* for whatever</span>
<span class="cm">the binary operator is for the base case. Here</span>
<span class="cm">we want to return 1.</span>
<span class="cm">-/</span>

<span class="kd">def</span> <span class="n">reduce_prod</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.mul</span> <span class="n">h</span> <span class="o">(</span><span class="n">reduce_prod</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">reduce_prod</span> <span class="o">[]</span>          <span class="c1">-- expect 1</span>
<span class="k">#eval</span> <span class="n">reduce_prod</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="c1">-- expect 120</span>
</pre></div>
</div>
</div><p>So now we can correctly generalize fold_nat over
binary operators by making the operator a parameter
but by also adding as a second parameter the right
identity element for whatever operator we provide
as an actual parameter.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20fold_nat%20(op%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat)%3A%20%20nat%20%E2%86%92%20list%20nat%20%E2%86%92%20nat%0A%7C%20id%20list.nil%20%3A%3D%20id%0A%7C%20id%20(h%3A%3At)%20%3A%3D%20op%20h%20(fold_nat%20id%20t)%0A%0A%0A--%20It%20seems%20to%20work!%0A%23eval%20fold_nat%20nat.add%200%20%5B1%2C2%2C3%2C4%2C5%5D%20%20--%20expect%2015%0A%23eval%20fold_nat%20nat.mul%201%20%5B1%2C2%2C3%2C4%2C5%5D%20%20--%20expect%20120" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_400.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">fold_nat</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="o">):</span>  <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">id</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="n">id</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">op</span> <span class="n">h</span> <span class="o">(</span><span class="n">fold_nat</span> <span class="n">id</span> <span class="n">t</span><span class="o">)</span>


<span class="c1">-- It seems to work!</span>
<span class="k">#eval</span> <span class="n">fold_nat</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>  <span class="c1">-- expect 15</span>
<span class="k">#eval</span> <span class="n">fold_nat</span> <span class="n">nat.mul</span> <span class="mi">1</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>  <span class="c1">-- expect 120</span>
</pre></div>
</div>
</div><p>Yet a problem remains. There is nothing in our
solution that prevents us from passing the wrong
value for the identity element for the given binary
operator. The following function application runs
without any errors being reported but it gives the
wrong answer, because we pass the wrong identity
element for nat.mul.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23eval%20fold_nat%20nat.mul%200%20%5B1%2C2%2C3%5D%20%20--%20oops%2C%20wrong" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_419.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">fold_nat</span> <span class="n">nat.mul</span> <span class="mi">0</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>  <span class="c1">-- oops, wrong</span>
</pre></div>
</div>
</div><p>We will finish this chapter with a step toward our
ultimate solution: we will now construct a version
of fold_nat (fold_nat&#8217;) that <em>enforces consistency</em>
between the binary function and identity element
arguments by requiring, as an additional argument,
a proof that the putative identity element really
is one!</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20fold_nat'%0A%20%20(op%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat)%0A%20%20(id%20%3Anat)%0A%20%20(right_id%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20op%20n%20id%20%3D%20n)%20%3A%0A%20%20list%20nat%20%E2%86%92%20nat%0A%7C%20list.nil%20%3A%3D%20id%0A%7C%20(h%3A%3At)%20%3A%3D%20op%20h%20(fold_nat'%20t)" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_431.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">fold_nat&#39;</span>
  <span class="o">(</span><span class="n">op</span><span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="o">)</span>
  <span class="o">(</span><span class="n">id</span> <span class="o">:</span><span class="n">nat</span><span class="o">)</span>
  <span class="o">(</span><span class="n">right_id</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">op</span> <span class="n">n</span> <span class="n">id</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">op</span> <span class="n">h</span> <span class="o">(</span><span class="n">fold_nat&#39;</span> <span class="n">t</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Let&#8217;s construct named proofs that 0 is an identity
when it appears as the second argument to nat.add.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20zero_right_id_add%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20nat.add%20n%200%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Asimp%20%5Bnat.add%5D%0Aend%0A%0A--%20Now%20we%20can%20safely%20use%20fold_nat'%0A%23eval%20fold_nat'%20nat.add%200%20zero_right_id_add%20%5B1%2C2%2C3%5D%0A%0A--%20This%20application%20fails%20because%20the%20proof%20is%20wrong%0A%23eval%20fold_nat'%20nat.add%201%20zero_right_id_add%20%5B1%2C2%2C3%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_444.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">zero_right_id_add</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat.add</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">]</span>
<span class="kd">end</span>

<span class="c1">-- Now we can safely use fold_nat&#39;</span>
<span class="k">#eval</span> <span class="n">fold_nat&#39;</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="n">zero_right_id_add</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>

<span class="c1">-- This application fails because the proof is wrong</span>
<span class="k">#eval</span> <span class="n">fold_nat&#39;</span> <span class="n">nat.add</span> <span class="mi">1</span> <span class="n">zero_right_id_add</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
</div><p>As a closing point, we circle back to the notion that
fold generalizes any given binary operator to an n-ary
operator applicable to any number of arguments as long
as they&#8217;re arranged in a list. You can see this idea
in action by just partially applying fold_nat&#8217; to a
binary operator, it&#8217;s identity, and the required proof,
leaving the list argument TBD.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20n_ary_add%20%3A%3D%20fold_nat'%20nat.add%200%20zero_right_id_add%0A%0A--%20It%20seems%20to%20work!%0A%23eval%20n_ary_add%20%5B%5D%20%20%20%20%20%20%20%20%20%20%20%20--%20zero%20arguments%0A%23eval%20n_ary_add%20%5B5%5D%20%20%20%20%20%20%20%20%20%20%20--%20one%20argument%0A%23eval%20n_ary_add%20%5B4%2C5%5D%20%20%20%20%20%20%20%20%20--%20two%20arguments%0A%23eval%20n_ary_add%20%5B1%2C2%2C3%2C4%2C5%5D%20%20%20--%20five%20arguments%2C%20etc!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_466.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">n_ary_add</span> <span class="o">:=</span> <span class="n">fold_nat&#39;</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="n">zero_right_id_add</span>

<span class="c1">-- It seems to work!</span>
<span class="k">#eval</span> <span class="n">n_ary_add</span> <span class="o">[]</span>            <span class="c1">-- zero arguments</span>
<span class="k">#eval</span> <span class="n">n_ary_add</span> <span class="o">[</span><span class="mi">5</span><span class="o">]</span>           <span class="c1">-- one argument</span>
<span class="k">#eval</span> <span class="n">n_ary_add</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>         <span class="c1">-- two arguments</span>
<span class="k">#eval</span> <span class="n">n_ary_add</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>   <span class="c1">-- five arguments, etc!</span>
</pre></div>
</div>
</div><p>Soon we&#8217;ll be able similarly to turn binary multiplication
into n-ary multiplication, with a definitions like this:
<em>def n_ary_mul := fold_nat&#8217; nat.mul 1 one_right_id_mul</em>. The
problem is we don&#8217;t yet have the machinery (namely proof by
induction) to construct the proof that 1 is a right identity
for nat.mul. That&#8217;ll come soon enough. For now, we can stub
it out and get something that works but without a proof that
1 is a right identity for natural number multiplication.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20n_ary_mul%20%3A%3D%20fold_nat'%20nat.mul%201%20sorry%0A%23eval%20n_ary_mul%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_486.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">n_ary_mul</span> <span class="o">:=</span> <span class="n">fold_nat&#39;</span> <span class="n">nat.mul</span> <span class="mi">1</span> <span class="gr">sorry</span>
<span class="k">#eval</span> <span class="n">n_ary_mul</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
<section id="summary">
<h3><span class="section-number">4.4.5. </span>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">&#61633;</a></h3>
<p>Higher-order functions are functions that consume functions
as arguments and/or that return functions as results. In this
chapter we&#8217;ve produced highly general higher-order functions
for (1) composition of functions, (2) mapping functions over
lists to derive new lists, and (3) extending binary operators
to n-ary operators whose arguments are given as lists of any
length.</p>
</section>
<section id="id4">
<h3><span class="section-number">4.4.6. </span>Exercises<a class="headerlink" href="#id4" title="Permalink to this heading">&#61633;</a></h3>
<p>1. Write a function, n_ary_append (without using fold) that
takes a list of lists of objects of some type, &#945; (the type will
be <em>list (list &#945;)</em>) and that reduces it to a single list of &#945;
using <em>list.append</em> as a binary operation. For example, it&#8217;d
turn this list, [[1,2],[3,4],[5]] into the list [1,2,3,4,5].
You may use Lean&#8217;s list.append function as a binary operator
that combines two lists into one.</p>
<p>2. Write a function (without using fold) that takes a a list
of lists of &#945; and that returns the sum of the lengths of the
contained lists. For example applying your function to the
list, [[],[1,2,3],[1,2,3,4,5]], should return 8: the sum of
0 for the first list, 3 for the second, and 5 for the third.
Your function will work by adding the length of the head of
the list of lists to the result of recursively reducing the
<em>rest</em> (tail) of the list of lists. You may use list.length
to compute the length of any list.</p>
<p>3. Write a function without using fold that takes a list of
lists of &#945; and that returns true if the length of each of
the elements lists is even and false otherwise.</p>
</section>
</section>
<section id="recursive-proofs">
<h2><span class="section-number">4.5. </span>Recursive Proofs<a class="headerlink" href="#recursive-proofs" title="Permalink to this heading">&#61633;</a></h2>
<section id="proof-by-induction">
<h3><span class="section-number">4.5.1. </span>Proof by Induction<a class="headerlink" href="#proof-by-induction" title="Permalink to this heading">&#61633;</a></h3>
<p>There was something notably questionable in the last
chapter. We defined a <em>safe</em> version of <em>fold</em> by requiring
a proof that the value returned for an empty list be a
<em>right</em> (but not a <em>left</em>) identity element for the actual
binary operator parameter given to the fold function.</p>
<p>We then found it easy to prove that 0 is indeed a right
identity for nat.add. They key insight you need to have
is that it was easy to prove because it&#8217;s already given
to us as an <em>axiom</em>. In particular, the first rule in the
recursive definition of nat.add makes it so. Here&#8217;s the
definition of nat.add from Lean&#8217;s core library.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20add%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20a%20%20zero%20%20%20%20%20%3A%3D%20a%0A%7C%20a%20%20(succ%20b)%20%3A%3D%20succ%20(add%20a%20b)" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_22.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">a</span>  <span class="n">zero</span>     <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span>  <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Look at the first case/rule: any a added to zero
is equal to a. This rule establishes that zero is
a right identity for add.  Here again is our earlier
statement and proof.</p>
<p>Note that the <em>simp</em> tactict tries to fine, and if
found applies, rules/axioms from the definition of
any of the listed functions: here from just nat.add.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20(n%20%3A%20%E2%84%95)%2C%20nat.add%20n%200%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Asimp%20%5Bnat.add%5D%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_37.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span> <span class="n">nat.add</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>What&#8217;s <em>not</em> provided by the definition
of nat.add is an axiom that stipulates
zero is a <em>left</em> identity for nat.add.
If we try the same proof technique to
prove <em>&#8704; n, 0 + n = n</em>, with 0 now on
the left, we can&#8217;t! (When writing these
propositions and proofs, use nat.add in
a consistent manner instead of 0. It&#8217;s
a complication that&#8217;s annoying, but for
now just follow this simple instruction
and you&#8217;ll be fine.)</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20n%2C%20nat.add%20nat.zero%20n%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Asimp%20%5Bnat.add%5D%2C%0A--%20oops%2C%20that%20didn't%20help%3B%20we're%20stuck!%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_57.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.add</span> <span class="n">nat.zero</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="c1">-- oops, that didn&#39;t help; we&#39;re stuck!</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Looking at what remains to be proved, we
might consider proof by case analysis on
n. So let&#8217;s try that.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20n%2C%20nat.add%20nat.zero%20n%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%0A--%20first%20case%3A%20zero's%20also%20on%20the%20right%0Asimp%20%5Bnat.add%5D%2C%0A--%20second%20case%2C%20argument%20is%20succ%20of%20some%20n'%0A--%20how%20to%20show%200%20%2B%20(succ%20n')%20%3D%20(succ%20n')%0A--%20but%20again%20we're%20stuck%0Asimp%20%5Bnat.add%5D%2C%0A--%20basically%20back%20where%20we%20started%3B%20stuck.%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_70.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.add</span> <span class="n">nat.zero</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="c1">-- first case: zero&#39;s also on the right</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="c1">-- second case, argument is succ of some n&#39;</span>
<span class="c1">-- how to show 0 + (succ n&#39;) = (succ n&#39;)</span>
<span class="c1">-- but again we&#39;re stuck</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="c1">-- basically back where we started; stuck.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The problem is that all we know about n&#8217;
is that it&#8217;s some natural number, and that
isn&#8217;t enough to work with to prove the goal.</p>
<p>What if we knew a little more? What if we
knew that 0 is a left zero for n&#8217; as part
of the context in which are to prove that
it&#8217;s a zero for (succ n&#8217;)? Would that help?</p>
<p>It would. Suppose we know that <em>add 0 n&#8217; = n&#8217;</em>
and that we want to prive that <em>add 0 (succ n&#8217;)
= (succ n&#8217;)</em>. Key insight: We can apply the
<em>second</em> axiom of addition,given by the second
rule in its definition, to rewrite the term,
<em>add 0 (succ n&#8217;)</em> to the term <em>succ (add 0 n&#8217;);</em>
then we can use the fact that (by assumption)
0 is a left 0 for n&#8217; to rewrite the term
<em>succ (add 0 n&#8217;)</em> to <em>succ n&#8217;.</em> That&#8217;s it.
We&#8217;ve shown that 0 + succ n&#8217; = succ n&#8217;.</p>
<p>But what could possibly justify assuming
that 0 + n&#8217; = n&#8217; in the first place? Well,
let&#8217;s see if it can be justified informally
before getting into formalities.</p>
<p>Let&#8217;s start by noting that by the first rule
of addition, 0 is a left zero for 0. This
proof gives us a base on which we can now
construct a proof that 0 is a left zero for 1.</p>
<p>Details: we want to show that 0 + 1 = 1. That
is, we want to show that 0 + succ 0 = succ 0.
By the second rule/axiom of add, the left side
is succ (0 + 0). <em>BE SURE YOU UNDERSTAND THIS
STEP.</em>  Now yy the first rule, 0 + 0 = 0, so
we can rewrite succ (0 + 0) to just succ 0.
With this expression on the left side, all
thatremains to prove is that succ 0 = succ 0,
and this is true of course by the reflexivity
of the equality relation.</p>
<p>To recap, we proved a &#8220;base case&#8221; (that
zero is a left identity for zero) using the
first axiom of addition. Then we applied the
second axiom to show that 0 is a left identity
for 1. With this proof in hand we can apply
the second axiom <em>again</em> to construct a proof
that zero is left identity for 2. From this
we can derive that 0 is a left identity for
3. Indeed to prove that 0 is a left identity
for <em>any</em> n, we start with a proof that it&#8217;s
a left identity for zero using the first
axiom, then we iteratively apply the second
axiom n times to prove it&#8217;s a left identity
for <em>any</em> n.</p>
<p>Let&#8217;s just program it to make it all clear.
Out program will take any value n and return
a proof that 0 is a left identity for it. It
does this in the reverse order, constructing
a proof for the case where n is non-zero, i.e.,
where n = succ n&#8217; for some n&#8217;, and obtaining
a proof for n&#8217; <em>by recursion</em>. The recursive
calls implement iteration until the base case
of n = 0 is reached, at which point a proof
for that case is returned, the recursion
unwinds, and we&#8217;re left with a proof that 0
is a left identity for that arbitrary n. The
existence of this function shows that we can
construct a proof of the proposition that 0
is a left identity for any n, and so it is
true <em>for all</em> n. And that&#8217;s what we wanted.
QED.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20a%20proof-returning%20function%20defined%20by%20cases%0A--%20takes%20any%20n%20and%20returns%20a%20proof%20of%200%20%2B%20n%20%3D%20n%0Adef%20zero_left_ident_n%20%3A%20%E2%88%80%20n%2C%20(nat.add%200%20n%20%3D%20n)%0A%7C%20nat.zero%20%3A%3D%20by%20simp%20%5Bnat.add%5D%20--%20base%20case%0A%7C%20(nat.succ%20n')%20%3A%3D%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20recursive%20case%0A%20%20begin%0A%20%20simp%20%5Bnat.add%5D%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20applies%20second%20rule%20and%20...%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20removes%20succ%20on%20each%20side%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20by%20injectivity%20of%20constructors%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20inherent%20in%20inductive%20definitions%0A%20%20exact%20(zero_left_ident_n%20n')%2C%20--%20prove%20result%20recursively%0A%20%20end%0A%0A--%20eyeball%20check%20of%20the%20recursive%20structure%20of%20these%20proofs!%0A%23reduce%20zero_left_ident_n%200%20%20%20%20%20--%20the%20proof%20term%20is%20unpretty%20(just%20eyeball%20it)%0A%23reduce%20zero_left_ident_n%201%20%20%20%20%20--%20the%20proof%20for%201%20buids%20on%20the%20proof%20for%200%0A%23reduce%20zero_left_ident_n%202%20%20%20%20%20--%20the%20proof%20for%202%20buids%20on%20the%20proof%20for%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20and%20we%20see%20we%20can%20build%20such%20a%20proof%20for%20any%20n%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20therefore%200%20is%20a%20left%20identity%20for%20addition" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_159.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- a proof-returning function defined by cases</span>
<span class="c1">-- takes any n and returns a proof of 0 + n = n</span>
<span class="kd">def</span> <span class="n">zero_left_ident_n</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">nat.add</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">]</span> <span class="c1">-- base case</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span>              <span class="c1">-- recursive case</span>
  <span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>               <span class="c1">-- applies second rule and ...</span>
                                <span class="c1">-- removes succ on each side</span>
                                <span class="c1">-- by injectivity of constructors</span>
                                <span class="c1">-- inherent in inductive definitions</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">zero_left_ident_n</span> <span class="n">n&#39;</span><span class="o">),</span> <span class="c1">-- prove result recursively</span>
  <span class="kd">end</span>

<span class="c1">-- eyeball check of the recursive structure of these proofs!</span>
<span class="k">#reduce</span> <span class="n">zero_left_ident_n</span> <span class="mi">0</span>     <span class="c1">-- the proof term is unpretty (just eyeball it)</span>
<span class="k">#reduce</span> <span class="n">zero_left_ident_n</span> <span class="mi">1</span>     <span class="c1">-- the proof for 1 buids on the proof for 0</span>
<span class="k">#reduce</span> <span class="n">zero_left_ident_n</span> <span class="mi">2</span>     <span class="c1">-- the proof for 2 buids on the proof for 1</span>
                                <span class="c1">-- and we see we can build such a proof for any n</span>
                                <span class="c1">-- therefore 0 is a left identity for addition</span>
</pre></div>
</div>
</div><p>A bit more to come.</p>
</section>
<section id="inductive-families">
<h3><span class="section-number">4.5.2. </span>Inductive Families<a class="headerlink" href="#inductive-families" title="Permalink to this heading">&#61633;</a></h3>
<p>Coming soon.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20le%20(n%20%3A%20nat)%3A%20nat%20%E2%86%92%20Prop%0A--%20n%20is%20an%20implicit%20firt%20argument%20to%20each%20constructor%0A%7C%20refl%20%3A%20le%20%2F-n-%2F%20n%0A%7C%20step%20%3A%20%E2%88%80%20m%2C%20le%20%2F-n-%2F%20m%20%E2%86%92%20le%20%2F-n-%2F%20m.succ%0A%0A--%20you%20can%20see%20it%20in%20the%20types%20of%20the%20constructors%0A%23check%20%40le.refl%0A%23check%20%40le.step%0A%0A%0Aexample%20%3A%20le%200%200%20%3A%3D%0Abegin%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%203%203%20%3A%3D%0Abegin%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%200%201%20%3A%3D%0Abegin%0Aapply%20le.step%2C%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%200%203%20%3A%3D%0Abegin%0Aapply%20le.step%2C%0Aapply%20le.step%2C%0Aapply%20le.step%2C%0Aapply%20le.refl%2C%0Aend%0A%0A--%20here's%20the%20same%20example%20using%20Lean's%20version%20of%20%22le%22%0A--%20it's%20called%20nat.less_than_or_equal%0Aexample%20%3A%200%20%E2%89%A4%203%20%3A%3D%0Abegin%0Aapply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.step%2C%0A--%20apply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.refl%2C%0Aend%0A%0A--%20repeat%20tactical%20goes%20too%20far%3B%20use%20iterate%20instead%0Aexample%20%3A%201%20%E2%89%A4%204%20%3A%3D%0Abegin%0A--%20repeat%20%7Bapply%20nat.less_than_or_equal.step%7D%2C%0Aiterate%203%20%7Bapply%20nat.less_than_or_equal.step%7D%2C%0Aapply%20nat.less_than_or_equal.refl%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_188.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">le</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">):</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>
<span class="c1">-- n is an implicit firt argument to each constructor</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">le</span> <span class="c">/-</span><span class="cm">n-/</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">m</span><span class="o">,</span> <span class="n">le</span> <span class="c">/-</span><span class="cm">n-/</span> <span class="n">m</span> <span class="bp">&#8594;</span> <span class="n">le</span> <span class="c">/-</span><span class="cm">n-/</span> <span class="n">m.succ</span>

<span class="c1">-- you can see it in the types of the constructors</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">le.refl</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">le.step</span>


<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">3</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- here&#39;s the same example using Lean&#39;s version of &quot;le&quot;</span>
<span class="c1">-- it&#39;s called nat.less_than_or_equal</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&#8804;</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="c1">-- apply nat.less_than_or_equal.step,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- repeat tactical goes too far; use iterate instead</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&#8804;</span> <span class="mi">4</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">-- repeat {apply nat.less_than_or_equal.step},</span>
<span class="n">iterate</span> <span class="mi">3</span> <span class="o">{</span><span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">},</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.refl</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="A_02_Constructive_Logic.html" class="btn btn-neutral float-left" title="3. Constructive Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="A_04_Dependent_Types.html" class="btn btn-neutral float-right" title="5. Dependent Types" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kevin Sullivan.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>