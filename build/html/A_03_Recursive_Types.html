<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4. Recursive Types &mdash; CS6501 Spring 2023 1.2.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Dependent Types" href="A_04_Dependent_Types.html" />
    <link rel="prev" title="3. Constructive Logic" href="A_02_Constructive_Logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CS6501 Spring 2023
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="A_00_Introduction.html">1. CS6501 Spring 2023</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_01_Propositional_Logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_02_Constructive_Logic.html">3. Constructive Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Recursive Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">4.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#natural-numbers">4.2. Natural Numbers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-type">4.2.1. Data Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operations">4.2.2. Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#polymorphic-lists">4.3. Polymorphic Lists</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">4.3.1. Data Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notations">4.3.2. Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">4.3.3. Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-functions">4.3.4. Partial Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default-value">4.3.4.1. Default Value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#option-values">4.3.4.2. Option Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#precondition">4.3.4.3. Precondition</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">4.3.5. Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solutions">4.3.6. Solutions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#higher-order-functions">4.4. Higher-Order Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-peval">4.4.1. Example: <em>pEval</em></a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-composition">4.4.2. Function composition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#higher-order-functions-on-lists">4.4.3. Higher-Order Functions on Lists</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#map">4.4.3.1. map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filter">4.4.3.2. filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fold">4.4.3.3. fold</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">4.4.4. Exercises</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#recursive-proofs">4.5. Recursive Proofs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">4.5.1. Introduction</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="A_04_Dependent_Types.html">5. Dependent Types</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CS6501 Spring 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">4. </span>Recursive Types</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/A_03_Recursive_Types.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="recursive-types">
<span id="introduction"></span><h1><span class="section-number">4. </span>Recursive Types<a class="headerlink" href="#recursive-types" title="Permalink to this heading">&#61633;</a></h1>
<section id="id1">
<h2><span class="section-number">4.1. </span>Introduction<a class="headerlink" href="#id1" title="Permalink to this heading">&#61633;</a></h2>
<p>In this chapter we&#8217;ll look at inductive data types
definitions that specify objects that have recursive
structure. In particular, we&#8217;ll look at the <em>nat</em> and
polymorphic <em>list</em> types, with an eye to seeing some
interesting algebraic commonalities.</p>
</section>
<section id="natural-numbers">
<h2><span class="section-number">4.2. </span>Natural Numbers<a class="headerlink" href="#natural-numbers" title="Permalink to this heading">&#61633;</a></h2>
<section id="data-type">
<h3><span class="section-number">4.2.1. </span>Data Type<a class="headerlink" href="#data-type" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20nat" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_8.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">nat</span>
</pre></div>
</div>
</div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20notations%20for%20writing%20succ%20applications%0Adef%20three'%20%20%3A%3D%20(nat.succ%20(nat.succ%20(nat.succ%20(nat.zero))))%0Adef%20three%20%20%3A%3D%20nat.zero.succ.succ.succ" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_13.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- notations for writing succ applications</span>
<span class="kd">def</span> <span class="n">three&#39;</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.zero</span><span class="o">))))</span>
<span class="kd">def</span> <span class="n">three</span>  <span class="o">:=</span> <span class="n">nat.zero.succ.succ.succ</span>
</pre></div>
</div>
</div></section>
<section id="operations">
<h3><span class="section-number">4.2.2. </span>Operations<a class="headerlink" href="#operations" title="Permalink to this heading">&#61633;</a></h3>
<p>Having seen how the <em>nat</em> data type is defined, we now look
at how to define functions taking <em>nat</em> values as arguments.
As we&#8217;ve seen before, many such functions here will again be
defined by case analysis on an incoming nat argument value.
That means considering two cases separately: the incoming value
is either zero or non-zero: that is, either <em>nat.zero,</em> or
<em>nat.succ n&#8217;</em> for some &#8220;one-smaller&#8221; value, <em>n&#8217;</em>. For example,
if the incoming argument is <em>succ(succ(succ zero))</em>, i.e., 3,
then (a) it does not match <em>nat.zero</em>, but (b) it does match
<em>nat.succ n&#8217;</em>, with <em>n&#8217;</em> is bound to <em>succ(succ zero)</em>, i.e., 2.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20increment%20is%20just%20succ%20application%0Adef%20inc%20(n'%20%3A%20nat)%20%3A%20nat%20%3A%3D%20n'.succ%0Adef%20three''%20%3A%3D%20inc(inc(inc%20nat.zero))" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_33.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- increment is just succ application</span>
<span class="kd">def</span> <span class="n">inc</span> <span class="o">(</span><span class="n">n&#39;</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">n&#39;.succ</span>
<span class="kd">def</span> <span class="n">three&#39;&#39;</span> <span class="o">:=</span> <span class="n">inc</span><span class="o">(</span><span class="n">inc</span><span class="o">(</span><span class="n">inc</span> <span class="n">nat.zero</span><span class="o">))</span>
</pre></div>
</div>
</div><p>A predecessor (one less than) function can be defined by
case analysis on a nat argument. Here we&#8217;ll define <em>pred&#8217;</em>
to return 0 when applied to 0, and otherwise to return the
one smaller value, <em>n&#8217;</em>, when applied to any non-zero value,
<em>nat.succ n&#8217;</em>.</p>
<p>Rather than &#8220;implementing a function&#8221; think &#8220;proving a function
type.&#8221; A &#8220;proof&#8221; of function type, <em>nat &#8594; nat,</em> is any function
that converts any given nat into some resulting nat.</p>
<p>When proving a proposition (a type in Prop), any proof (value
of that type) will do. When proving function or other data type,
however, the particular value of the type that you construct is
usually important. Here, for example, we don&#8217;t want any function
that takes and returns a nat, but one that returns the right nat
for the given argument.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20pred'%20%3A%20nat%20%E2%86%92%20nat%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%0Aexact%200%2C%20%20--%20when%20n%20is%20zero%0Aexact%20n'%2C%20--%20when%20n%20is%20succ%20n'%0Aend%0A%0A--%20quick%20test%0A%23eval%20pred'%206%0Aexample%20%3A%20pred'%206%20%3D%205%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_56.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">pred&#39;</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="n">exact</span> <span class="mi">0</span><span class="o">,</span>  <span class="c1">-- when n is zero</span>
<span class="n">exact</span> <span class="n">n&#39;</span><span class="o">,</span> <span class="c1">-- when n is succ n&#39;</span>
<span class="kd">end</span>

<span class="c1">-- quick test</span>
<span class="k">#eval</span> <span class="n">pred&#39;</span> <span class="mi">6</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">pred&#39;</span> <span class="mi">6</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Here&#8217;s the same function just specified
using pattern matching notation (which,
as we&#8217;ve seen generalizes case analysis).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20pred%20%3A%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20%3A%3D%20nat.zero%20%20--%20loop%20at%20zero%0A%7C%20(nat.succ%20n')%20%3A%3D%20n'%0A%0A%23eval%20pred%205%0Aexample%20%3A%20pred%205%20%3D%204%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_74.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">nat.zero</span>  <span class="c1">-- loop at zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="k">#eval</span> <span class="n">pred</span> <span class="mi">5</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">pred</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Pattern matching generalizes case analysis
by giving you a means to return different
results based on deeper analysis of argument
structures using pattern matching/unification.
This example implements subtract-two, looping
at zero. Notice how the third pattern matches
to the sub-natural-number object nested two
succ-levels deep.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20this%20example%20illustrates%20pattern%20matching%0A--%20for%20more%20fine-grained%20case%20analysis%0Adef%20sub2%20%3A%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20%3A%3D%20nat.zero%0A%7C%20(nat.succ%20nat.zero)%20%3A%3D%20nat.zero%0A%7C%20(nat.succ%20(nat.succ%20n'))%20%3A%3D%20n'%0A%0A--%20addition%20increments%20the%20second%20argument%0A--%20the%20first%20argument%20number%20of%20times%0Adef%20plus%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20m%20%3A%3D%20m%0A%7C%20(nat.succ%20n')%20m%20%3A%3D%20nat.succ%20(plus%20n'%20m)%0A%0A%23eval%20plus%203%204%0A%0A--%20multiplication%20adds%20the%20second%20argument%0A--%20to%20itself%20the%20first%20argumen%20number%20of%20times%0Adef%20times%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%200%20m%20%3A%3D%200%0A%7C%20(n'%2B1)%20m%20%3A%3D%20plus%20m%20(times%20n'%20m)%0A%0A%23eval%20times%205%204%0A%23eval%20times%201%2020%0A%0A%0A--%20substraction%20illustrates%20case%20analysis%20on%0A--%20multiple%20(here%20two)%20arguments%20at%20once%0Adef%20subtract%20%3A%20%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%200%20_%20%3A%3D%200%0A%7C%20n%200%20%3A%3D%20n%0A%7C%20(n'%20%2B%201)%20(m'%20%2B%201)%20%3A%3D%20subtract%20n'%20m'%0A%0A%23eval%20subtract%207%205%0A%23eval%20subtract%207%200%0A%23eval%20subtract%205%207%0A%23eval%20subtract%200%207%0A%0A%0A--%20exponentiation%20is%20multiplication%20of%20the%20second%0A--%20argument%20by%20itself%20the%20first%20argument%20number%20of%20times%0Adef%20power%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20n%20nat.zero%20%3A%3D%201%0A%7C%20n%20(nat.succ%20m')%20%3A%3D%20times%20n%20(power%20n%20m')%0A%0A--%20a%20few%20test%20cases%0Aexample%20%3A%20power%202%200%20%3D%201%20%3A%3D%20rfl%0Aexample%20%3A%20power%202%208%20%3D%20256%20%3A%3D%20rfl%0Aexample%20%3A%20power%202%2010%20%3D%201024%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_92.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- this example illustrates pattern matching</span>
<span class="c1">-- for more fine-grained case analysis</span>
<span class="kd">def</span> <span class="n">sub2</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">nat.zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">))</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="c1">-- addition increments the second argument</span>
<span class="c1">-- the first argument number of times</span>
<span class="kd">def</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">nat.succ</span> <span class="o">(</span><span class="n">plus</span> <span class="n">n&#39;</span> <span class="n">m</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">plus</span> <span class="mi">3</span> <span class="mi">4</span>

<span class="c1">-- multiplication adds the second argument</span>
<span class="c1">-- to itself the first argumen number of times</span>
<span class="kd">def</span> <span class="n">times</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">m</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n&#39;</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">plus</span> <span class="n">m</span> <span class="o">(</span><span class="n">times</span> <span class="n">n&#39;</span> <span class="n">m</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">times</span> <span class="mi">5</span> <span class="mi">4</span>
<span class="k">#eval</span> <span class="n">times</span> <span class="mi">1</span> <span class="mi">20</span>


<span class="c1">-- substraction illustrates case analysis on</span>
<span class="c1">-- multiple (here two) arguments at once</span>
<span class="kd">def</span> <span class="n">subtract</span> <span class="o">:</span>  <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n&#39;</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m&#39;</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subtract</span> <span class="n">n&#39;</span> <span class="n">m&#39;</span>

<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">7</span> <span class="mi">5</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">7</span> <span class="mi">0</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">5</span> <span class="mi">7</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">0</span> <span class="mi">7</span>


<span class="c1">-- exponentiation is multiplication of the second</span>
<span class="c1">-- argument by itself the first argument number of times</span>
<span class="kd">def</span> <span class="n">power</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">m&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">times</span> <span class="n">n</span> <span class="o">(</span><span class="n">power</span> <span class="n">n</span> <span class="n">m&#39;</span><span class="o">)</span>

<span class="c1">-- a few test cases</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">8</span> <span class="bp">=</span> <span class="mi">256</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">10</span> <span class="bp">=</span> <span class="mi">1024</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div></section>
</section>
<section id="polymorphic-lists">
<h2><span class="section-number">4.3. </span>Polymorphic Lists<a class="headerlink" href="#polymorphic-lists" title="Permalink to this heading">&#61633;</a></h2>
<section id="id2">
<h3><span class="section-number">4.3.1. </span>Data Type<a class="headerlink" href="#id2" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20list" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_8.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">list</span>
</pre></div>
</div>
</div><p>The list data type is surprising similar to the nat
data type. Where as a larger nat is constructed from
only a smaller nat, a larger list is constructed from
a new first element (the <em>head</em> of the new list) and
a smaller list (the <em>tail</em> of the new list). This type
builder enables us to represent lists of values of any
type and of any finite length.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0Ainductive%20list%20(T%20%3A%20Type%20u)%0A%7C%20nil%20%3A%20list%0A%7C%20cons%20(hd%20%3A%20T)%20(tl%20%3A%20list)%20%3A%20list" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_20.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span>
</pre></div>
</div>
</div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20example%3A%20let's%20represent%20the%20list%20of%20nats%2C%20%5B1%2C2%2C3%5D%0Adef%20three_list_nat''%20%3A%3D%0A%20%20list.cons%20%20%20--%20takes%20two%20arguments%0A%20%20%20%201%20%20%20%20%20%20%20%20%20--%20head%20of%20new%20list%0A%20%20%20%20(%20%20%20%20%20%20%20%20%20--%20tail%20list%20of%20the%20new%20list%0A%20%20%20%20%20%20list.cons%20%20%20--%20etc.%0A%20%20%20%20%20%20%20%202%0A%20%20%20%20%20%20%20%20(%0A%20%20%20%20%20%20%20%20%20%20list.cons%0A%20%20%20%20%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A--%20it%20seems%20to%20have%20worked%0A%23reduce%20three_list_nat''" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_28.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- example: let&#39;s represent the list of nats, [1,2,3]</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;</span> <span class="o">:=</span>
  <span class="n">list.cons</span>   <span class="c1">-- takes two arguments</span>
    <span class="mi">1</span>         <span class="c1">-- head of new list</span>
    <span class="o">(</span>         <span class="c1">-- tail list of the new list</span>
      <span class="n">list.cons</span>   <span class="c1">-- etc.</span>
        <span class="mi">2</span>
        <span class="o">(</span>
          <span class="n">list.cons</span>
            <span class="mi">3</span>
            <span class="n">list.nil</span>
        <span class="o">)</span>
    <span class="o">)</span>

<span class="c1">-- it seems to have worked</span>
<span class="k">#reduce</span> <span class="n">three_list_nat&#39;&#39;</span>
</pre></div>
</div>
</div></section>
<section id="notations">
<h3><span class="section-number">4.3.2. </span>Notations<a class="headerlink" href="#notations" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20notation%2C%20%3A%3A%20is%20infix%20for%20cons%0A--%20%5B%5D%20notation%20adds%20nil%20at%20end%0Adef%20three_list_nat'''%20%3A%3D%201%3A%3A2%3A%3A3%3A%3Alist.nil%0Adef%20three_list_nat''''%20%3A%3D%20%5B1%2C2%2C3%5D%0Adef%20four_list_nat%20%3A%3D%200%3A%3A%5B1%2C2%2C3%5D%20%20%20%20%20%20%20--%20fun!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_50.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- notation, :: is infix for cons</span>
<span class="c1">-- [] notation adds nil at end</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;&#39;</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">::</span><span class="mi">2</span><span class="o">::</span><span class="mi">3</span><span class="o">::</span><span class="n">list.nil</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;&#39;&#39;</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">four_list_nat</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">::[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>       <span class="c1">-- fun!</span>
</pre></div>
</div>
</div></section>
<section id="id3">
<h3><span class="section-number">4.3.3. </span>Operations<a class="headerlink" href="#id3" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20list%20prepend%20analogous%20to%20nat%20increment%0Adef%20prepend'%20(%CE%B1%20%3A%20Type)%20(a%20%3A%20%CE%B1)%20(l%20%3A%20list%20%CE%B1)%20%3A%3D%0A%20%20list.cons%20a%20l%0A%0Adef%20three_list_nat'%20%3A%3D%0A%20%20prepend'%20nat%0A%20%20%20%201%0A%20%20%20%20(prepend'%20nat%0A%20%20%20%20%20%202%0A%20%20%20%20%20%20(prepend'%20nat%0A%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A%23eval%20three_list_nat'%0A%0A--%20here%20with%20an%20implicit%20type%20parameter%2C%20making%20it%20equivalent%20to%20cons%0Adef%20prepend%20%7B%CE%B1%20%3A%20Type%7D%20(a%20%3A%20%CE%B1)%20(l%20%3A%20list%20%CE%B1)%20%3A%3D%0A%20%20list.cons%20a%20l%0A%0Adef%20three_list_nat%20%3A%3D%0A%20%20prepend%0A%20%20%20%201%0A%20%20%20%20(prepend%0A%20%20%20%20%20%202%0A%20%20%20%20%20%20(prepend%0A%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A--%20okay%2C%20that%20looks%20good%0A--%20but%20know%20that%20to%20which%20it%20desugars%0A%0Aexample%20%3A%3D%20prepend'%20nat%202%20%5B3%2C4%2C5%5D%0A%23eval%20prepend'%20nat%202%20%5B3%2C4%2C5%5D%0A%0Aexample%20%3A%3D%20prepend%202%20%5B3%2C4%2C5%5D%0A%23eval%20prepend%202%20%5B3%2C4%2C5%5D%0A%0A%23eval%202%3A%3A%5B3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_61.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- list prepend analogous to nat increment</span>
<span class="kd">def</span> <span class="n">prepend&#39;</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.cons</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">three_list_nat&#39;</span> <span class="o">:=</span>
  <span class="n">prepend&#39;</span> <span class="n">nat</span>
    <span class="mi">1</span>
    <span class="o">(</span><span class="n">prepend&#39;</span> <span class="n">nat</span>
      <span class="mi">2</span>
      <span class="o">(</span><span class="n">prepend&#39;</span> <span class="n">nat</span>
        <span class="mi">3</span>
        <span class="n">list.nil</span>
      <span class="o">)</span>
    <span class="o">)</span>

<span class="k">#eval</span> <span class="n">three_list_nat&#39;</span>

<span class="c1">-- here with an implicit type parameter, making it equivalent to cons</span>
<span class="kd">def</span> <span class="n">prepend</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.cons</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">three_list_nat</span> <span class="o">:=</span>
  <span class="n">prepend</span>
    <span class="mi">1</span>
    <span class="o">(</span><span class="n">prepend</span>
      <span class="mi">2</span>
      <span class="o">(</span><span class="n">prepend</span>
        <span class="mi">3</span>
        <span class="n">list.nil</span>
      <span class="o">)</span>
    <span class="o">)</span>

<span class="c1">-- okay, that looks good</span>
<span class="c1">-- but know that to which it desugars</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="n">prepend&#39;</span> <span class="n">nat</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">prepend&#39;</span> <span class="n">nat</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="n">prepend</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">prepend</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>

<span class="k">#eval</span> <span class="mi">2</span><span class="o">::[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
<section id="partial-functions">
<h3><span class="section-number">4.3.4. </span>Partial Functions<a class="headerlink" href="#partial-functions" title="Permalink to this heading">&#61633;</a></h3>
<p>Now we face some interesting issues. Our aim is to define
functions that <em>analyze</em> lists and return parts of them.
The problem is that there are no parts when a given list
is empty.</p>
<p>When we defined pred, above, we defined pred of zero to be
zero (rather than to be undefined). Doing that makes the
function total and easily represented as a function (lambda
abstractraction) in Lean. However, in a different application
we really might want to define pred 0 to be undefined, not 0.</p>
<p>A similar set of issues arises when we consider head and
tail functions on lists. When given non-empty lists there
is no problem. But what to do with an empty list argument?
There is no head or tail element to return, yet some value
of the specified type <em>has to be</em> returned.</p>
<p>Let&#8217;s see some fo the solutions that are available.</p>
<section id="default-value">
<h4><span class="section-number">4.3.4.1. </span>Default Value<a class="headerlink" href="#default-value" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20a%20version%20of%20tail%20that%20%22loops%20at%20zero%22%0Adef%20tail'%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%2C%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20%3A%3D%20list.nil%0A%7C%20%CE%B1%20(h%3A%3At)%20%3A%3D%20t%0A%23eval%20tail'%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_131.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- a version of tail that &quot;loops at zero&quot;</span>
<span class="kd">def</span> <span class="n">tail&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">t</span>
<span class="k">#eval</span> <span class="n">tail&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div><p>One nice thing about this solution
is that the function type is still about as natural as
can be: list &#945; &#8594; list &#945;.</p>
</section>
<section id="option-values">
<h4><span class="section-number">4.3.4.2. </span>Option Values<a class="headerlink" href="#option-values" title="Permalink to this heading">&#61633;</a></h4>
<p>The next solution changes the type of the function,
so that return value is in the form of a <em>variant</em>
type, a value of which is either <em>none</em> or <em>some
valid return value</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20head''%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%2C%20list%20%CE%B1%20%E2%86%92%20option%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20%3A%3D%20none%0A%7C%20%CE%B1%20(h%3A%3At)%20%3A%3D%20some%20h%0A%0A%23eval%20head''%20%5B1%2C2%2C3%5D%0A%23eval%20%40head''%20nat%20%5B%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_151.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">head&#39;&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">h</span>

<span class="k">#eval</span> <span class="n">head&#39;&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">head&#39;&#39;</span> <span class="n">nat</span> <span class="o">[]</span>
</pre></div>
</div>
</div></section>
<section id="precondition">
<h4><span class="section-number">4.3.4.3. </span>Precondition<a class="headerlink" href="#precondition" title="Permalink to this heading">&#61633;</a></h4>
<p>Finally, we can define a version of head&#8217; that (1) typechecks
as being a total function, (2) can never actually be applied
fully to an empty list, in which case (3) no real result has
to be specified to &#8220;prove the return type&#8221; because such a case
can&#8217;t happen. It would be a contradiction if it did, and so it
can be dismissed as an impossibility. Magic: It <em>is</em> a total
function, but it can never be fully appied to an empty list
because a required proof argument, for <em>that</em> list, can never
be given; so one can dismiss this case by false elimination,
without having to give an actual proof of the conclusion.</p>
<p>Consider a head function. It returns the head element from
a non-empty list, but is undefined mathematically when it&#8217;s
applied to an empty list. The key idea in the next design
is that we can embed a <em>precondition</em> for application of
the function, namely that the given list not be empty. Let&#8217;s
see how e might first write the function using a tactic
script, to take advantage of your familiarity with using
it to build proofs.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20head'%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20%CE%B1%0A%7C%20%20%CE%B1%20l%20p%20%3A%3D%0Abegin%0Acases%20l%2C%0Acontradiction%2C%0Aexact%20l_hd%2C%0Aend%0A%0A--%20When%20applying%20it%20a%20proof%20about%20the%20first%20argument%20has%20to%20be%20given%0A%23eval%20head'%20%5B1%2C2%2C3%5D%20begin%20contradiction%20end%20%20%20--%20proof%20as%20a%20proof%20script%0A%23eval%20head'%20%5B1%2C2%2C3%5D%20(by%20contradiction)%20%20%20%20%20%20%20%20--%20alternative%20syntax%2C%20fyi%0A%23eval%20head'%20(%5B%5D%20%3A%20list%20nat)%20_%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20you'll%20need%20a%20proof%20of%20list.nil%20%E2%89%A0%20list.nil!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_184.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">head&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="o">(</span><span class="n">l</span> <span class="bp">&#8800;</span> <span class="n">list.nil</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span>
<span class="bp">|</span>  <span class="n">&#945;</span> <span class="n">l</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">cases</span> <span class="n">l</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">l_hd</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- When applying it a proof about the first argument has to be given</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="kd">begin</span> <span class="n">contradiction</span> <span class="kd">end</span>   <span class="c1">-- proof as a proof script</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>        <span class="c1">-- alternative syntax, fyi</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">([]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">)</span> <span class="n">_</span>                 <span class="c1">-- you&#39;ll need a proof of list.nil &#8800; list.nil!</span>
</pre></div>
</div>
</div></section>
</section>
<section id="exercises">
<h3><span class="section-number">4.3.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">&#61633;</a></h3>
<ul class="simple">
<li><p>Write a version of the pred function that can only be called for argument values greater than 0.</p></li>
<li><p>Write a version of the pred function that returns an option nat value &#8220;in the usual way&#8221;</p></li>
<li><p>Write a tail function that can only be called with a non-empty list, using our &#8220;by cases&#8221; notation for function definition. It should look like tail&#8217;. Note 1: Where a proof value is required, you can always use tactic mode to construct the required proof, in a begin..end block. If such a proof is a single tactic long, you can write by &lt;tactic&gt;. For example, try by contradiction as the <em>result</em> when your new tail function is applied to an empty list. Here&#8217;s how I wrote the function type. You should provide the cases (on l). Here&#8217;s the type: def tail {&#945; : Type} : &#8704; (l : list &#945;), (l &#8800; list.nil) &#8594; list &#945;.</p></li>
</ul>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20implement%20the%20function%2C%20no%20need%20to%20(do%20not%20try)%20to%20match%20on%20%CE%B1%0A--%20it's%20named%20before%20the%20colon%20and%20is%20global%20to%20this%20definition%0A--%20we%20do%20want%20to%20match%20(do%20case%20analysis)%20on%20l%2C%20so%20it's%20after%20%3A%0A--%20def%20tail%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20%E2%88%80%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20list%20%CE%B1%0A--%20%7C%0A--%20%7C" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_206.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- implement the function, no need to (do not try) to match on &#945;</span>
<span class="c1">-- it&#39;s named before the colon and is global to this definition</span>
<span class="c1">-- we do want to match (do case analysis) on l, so it&#39;s after :</span>
<span class="c1">-- def tail {&#945; : Type} : &#8704; (l : list &#945;), (l &#8800; list.nil) &#8594; list &#945;</span>
<span class="c1">-- |</span>
<span class="c1">-- |</span>
</pre></div>
</div>
</div></section>
<section id="solutions">
<h3><span class="section-number">4.3.6. </span>Solutions<a class="headerlink" href="#solutions" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20let's%20implement%20a%20%22safe%22%20pred%20function%20using%20tactics%0Adef%20pred'%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20(n%20%E2%89%A0%20nat.zero)%20%E2%86%92%20%E2%84%95%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%0Aassume%20h%2C%0Acontradiction%2C%0Aassume%20h%2C%0Aexact%20n'%2C%0Aend%0A%0A%23reduce%20pred'%205%20_%0A%23reduce%20pred'%202%20_%0A%23reduce%20pred'%200%20_%0A%0A--%20here's%20the%20same%20predecessor%20function%20presented%20differently%0Adef%20pred''%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20(n%20%E2%89%A0%20nat.zero)%20%E2%86%92%20%E2%84%95%0A%7C%20nat.zero%20h%20%3A%3D%20by%20contradiction%0A%7C%20(nat.succ%20n')%20h%20%3A%3D%20n'%0A%0A--%20a%20different%20safe%20predecessor%20function%20using%20an%20option%20return%0Adef%20pred'''%20%3A%20nat%20%E2%86%92%20option%20nat%0A%7C%20nat.zero%20%3A%3D%20option.none%0A%7C%20(nat.succ%20n')%20%3A%3D%20some%20n'%0A%0A--%20the%20same%20ideas%20work%20for%20safe%20head%20and%20tail%20functions%20on%20lists%0Auniverse%20u%0Adef%20tail%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%20u%7D%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20list%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20p%20%3A%3D%20by%20contradiction%0A%7C%20%CE%B1%20(h%3A%3At)%20p%20%3A%3D%20t%0A%0A--%20apply%20tail%20to%20%5B1%2C2%2C3%5D%20giving%20the%20proof%20as%20a%20tactic%20script%0A%23eval%20tail%20%5B1%2C2%2C3%5D%0Abegin%0Aassume%20p%2C%0Acontradiction%2C%0Aend%0A%0A--%20cleaner%20this%20way%0A%23eval%20tail%20%5B1%2C2%2C3%5D%20(by%20contradiction)%0A%23eval%20tail%20%5B2%2C3%5D%20(by%20contradiction)%0A%23eval%20tail%20%5B3%5D%20(by%20contradiction)%0A%23eval%20%40tail%20nat%20%5B%5D%20(by%20contradiction)%20%20%20%20%20%20--%20no%20can%20do!%0A%0A--%20let's%20try%20it%20with%20a%20tactic%20script%0A%23eval%20%40tail%20nat%20%5B%5D%0Abegin%0Aassume%20h%2C%20%20%20--%20we're%20stuck%2C%20and%20that's%20good!%0Aend%0A%0A%0A--%20append%3A%20the%20list%20analog%20of%20natural%20number%20addition%0A--%20please%20do%20compare%2Fcontrast%20list.append%20and%20nat.add%0Adef%20appnd%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20list.nil%20m%20%3A%3D%20m%0A%7C%20(h%3A%3At)%20m%20%3A%3D%20h%3A%3Aappnd%20t%20m%0A%0A%23eval%20appnd%20%5B1%2C2%2C3%5D%20%5B4%2C3%2C2%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_218.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- let&#39;s implement a &quot;safe&quot; pred function using tactics</span>
<span class="kd">def</span> <span class="n">pred&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&#8800;</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">5</span> <span class="n">_</span>
<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">2</span> <span class="n">_</span>
<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">0</span> <span class="n">_</span>

<span class="c1">-- here&#39;s the same predecessor function presented differently</span>
<span class="kd">def</span> <span class="n">pred&#39;&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&#8800;</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="n">h</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="c1">-- a different safe predecessor function using an option return</span>
<span class="kd">def</span> <span class="n">pred&#39;&#39;&#39;</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">option.none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">n&#39;</span>

<span class="c1">-- the same ideas work for safe head and tail functions on lists</span>
<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">def</span> <span class="n">tail</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="o">(</span><span class="n">l</span> <span class="bp">&#8800;</span> <span class="n">list.nil</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">t</span>

<span class="c1">-- apply tail to [1,2,3] giving the proof as a tactic script</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">p</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- cleaner this way</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">tail</span> <span class="n">nat</span> <span class="o">[]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>      <span class="c1">-- no can do!</span>

<span class="c1">-- let&#39;s try it with a tactic script</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">tail</span> <span class="n">nat</span> <span class="o">[]</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>   <span class="c1">-- we&#39;re stuck, and that&#39;s good!</span>
<span class="kd">end</span>


<span class="c1">-- append: the list analog of natural number addition</span>
<span class="c1">-- please do compare/contrast list.append and nat.add</span>
<span class="kd">def</span> <span class="n">appnd</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">h</span><span class="o">::</span><span class="n">appnd</span> <span class="n">t</span> <span class="n">m</span>

<span class="k">#eval</span> <span class="n">appnd</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
</section>
<section id="higher-order-functions">
<h2><span class="section-number">4.4. </span>Higher-Order Functions<a class="headerlink" href="#higher-order-functions" title="Permalink to this heading">&#61633;</a></h2>
<p>Higher-order functions are simply functions that consume
function definitions as arguments and/or return function
definitions as results. You&#8217;ve been seeing higher-order
functions from early in this class.</p>
<section id="example-peval">
<h3><span class="section-number">4.4.1. </span>Example: <em>pEval</em><a class="headerlink" href="#example-peval" title="Permalink to this heading">&#61633;</a></h3>
<p>Consider our semantic evaluation function, <em>pEval,</em> for
propositional logic. It takes two arguments: an expression, <em>e</em>,
and an <em>interpretation</em> <em>i,</em> in the form of a function from
propositional variables to logical truth (Boolean) values.</p>
<p>The type of <em>pEval</em> is thus <em>prop_expr &#8594; (prop_var &#8594; bool)
&#8594; bool</em>. The second argument is a <em>function value</em>, which
<em>pEval</em> uses to get the Boolean values of the <em>variables</em>
in the expression to be evaluated. The fact that <em>pEval</em>
takes another function as an argument makes <em>pEval</em> a
higher-order function.</p>
<p>More generally, whenever a function, <em>g</em>, takes a function,
<em>f</em> as an argument, then <em>g</em> is a higher-order function.
You can think of <em>f</em> as a <em>little</em> machine (of a specific
type) that you hand to <em>g</em> and that <em>g</em> can then use to do
its job.</p>
<p>Exercise: Write a function, <em>apply_once,</em> polymorphic in
types &#945; and &#946;, taking two arguments, a function value,
f : &#945; &#8594; &#946;, and (2) an argument value, (a : &#945;), that
returns the value of type &#946; obtained by applying f to a.</p>
<p>Exercise: Write a function, <em>apply_twice</em>, polymorphic
in a type, &#945;, taking a function value, <em>f : &#945; &#8594; &#945;</em>, and
an argument value, <em>a : &#945;</em>, and that returns the result
of applying f to the result of applying f to a. In other
words, return the result of applying f twice to a.</p>
<p>Exercise: Write a function, <em>apply_n</em>, polymorphic in a
type, &#945;, taking a function value, <em>f : &#945; &#8594; &#945;</em>, and an
argument value, <em>a : &#945;</em>, that returns the result gotten
by applying f to a n times. Observe that the type of this
higher-order function really gives you no choice as to
what to return when n is zero.</p>
<p>Exercise: Write a function, <em>apply_comp</em>, polymorphic
in types, &#945;, &#946;, and &#947;, taking two functions, <em>f : &#945; &#8594; &#946;</em>,
and <em>g : &#946; &#8594; &#947;</em>, and an argument value, <em>a : &#945;</em>, and that
returns the result obtained by applying g to the result
obtained by applying f to a.</p>
</section>
<section id="function-composition">
<h3><span class="section-number">4.4.2. </span>Function composition<a class="headerlink" href="#function-composition" title="Permalink to this heading">&#61633;</a></h3>
<p>Now just as a higher-order function can <em>use</em> other
functions given as arguments, a higher-order function can
also <em>return</em> function values. Suppose, for example, that
you apply <em>apply_comp</em> to just two function values, without
giving the third argument. The result is a new function,
which we can write as (g &#8728; f), pronouned as <em>g after f</em>,
that takes an argument, <em>a</em>, and returns <em>g(f(a)).</em></p>
<p>As an exercise, let&#8217;s write a version, <em>comp</em>, of
<em>apply_comp</em> that leaves out the final argument. It will
just take two functions of compatible types and return
their composition.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0Adef%20comp%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%3A%20Type%20u%7D%20%3A%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%E2%86%92%20(%CE%B2%20%E2%86%92%20%CE%B3)%20%E2%86%92%20(%CE%B1%20%E2%86%92%20%CE%B3)%0A%7C%20f%20g%20%3A%3D%20%CE%BB%20a%2C%20g%20(%20f%20a)%0A%0A--%20Standard%20notation%20reversing%20argument%20order%3A%20g%20after%20f%0A%0Anotation%20%3A%20g%20%60%20%E2%88%98%20%60%20f%20%3A%3D%20comp%20f%20g" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_71.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">g</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">a</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span>

<span class="c1">-- Standard notation reversing argument order: g after f</span>

<span class="kd">notation</span> <span class="o">:</span> <span class="n">g</span> <span class="bp">`</span> <span class="bp">&#8728;</span> <span class="bp">`</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">comp</span> <span class="n">f</span> <span class="n">g</span>
</pre></div>
</div>
</div><p>Exercise: Use comp to construct a new function, ev_len,
that takes a string, s, and returns true (tt) if the length
of s is even and false otherwise.</p>
<p>You may use string.length to compute the length of a string
and (&#955; n, n % 2 = 0) to compute whether a given natural number
is even or not.</p>
<p>You should explicitly declare the type of ev_len to be
string &#8594; bool.  Lean will then insert a coercion to convert
the result of this check from a proposition (n % 2 = 0) to
a bool value for you.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20apply%20comp%20explicitly%20in%20your%20answer%0Adef%20ev_len%20%3A%20string%20%E2%86%92%20bool%20%3A%3D%20_%0A%0A--%20do%20it%20again%20but%20using%20%E2%88%98%20notation%0Adef%20ev_len'%20%3A%3D%20_%0A%0A--%20test%20cases%0Aexample%20%3A%20ev_len%20%22Hello%22%20%3D%20ff%20%3A%3D%20rfl%0Aexample%20%3A%20ev_len'%20%22Hello%22%20%3D%20ff%20%3A%3D%20rfl%0Aexample%20%3A%20ev_len%20%22Hello!%22%20%3D%20tt%20%3A%3D%20rfl%0Aexample%20%3A%20ev_len'%20%22Hello!%22%20%3D%20tt%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_95.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- apply comp explicitly in your answer</span>
<span class="kd">def</span> <span class="n">ev_len</span> <span class="o">:</span> <span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">_</span>

<span class="c1">-- do it again but using &#8728; notation</span>
<span class="kd">def</span> <span class="n">ev_len&#39;</span> <span class="o">:=</span> <span class="n">_</span>

<span class="c1">-- test cases</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ev_len</span> <span class="s2">&quot;Hello&quot;</span> <span class="bp">=</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ev_len&#39;</span> <span class="s2">&quot;Hello&quot;</span> <span class="bp">=</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ev_len</span> <span class="s2">&quot;Hello!&quot;</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">ev_len&#39;</span> <span class="s2">&quot;Hello!&quot;</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Exercise: Write a function, comp_n, polymorphic in alpha that
takes a function, f : &#945; &#8594; &#945;, and a natural number, n, and that
returns the function, f after f after f n times, i.e., the
function obtained by composing f with itself n times. You&#8217;ll
see again that your hand is forced when deciding what to return
when n is zero.</p>
</section>
<section id="higher-order-functions-on-lists">
<h3><span class="section-number">4.4.3. </span>Higher-Order Functions on Lists<a class="headerlink" href="#higher-order-functions-on-lists" title="Permalink to this heading">&#61633;</a></h3>
<section id="map">
<h4><span class="section-number">4.4.3.1. </span>map<a class="headerlink" href="#map" title="Permalink to this heading">&#61633;</a></h4>
<p>The <em>map</em> function takes a list of values and transforms
it, element by element, into a new list of corresponding
values, obtained by applying the given function to each
element in the given list. Note that the <em>map</em> function
never changes the <em>shape</em> of the list, only the <em>values</em>
that it holds.</p>
<p>As specified below, we define <em>map</em> to be polymorphic in
the types of the elements in the given and returned lists,
respectively. It then takes a function that it will use to
convert values in the given list into corresponding values
for the new list.</p>
<p>Exercise: Given an English-language explanation of the
second pattern-matching rule below.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20v%20%20%20%20--%20u%20is%20already%20a%20universe%20level%0A%0Adef%20map%20%7B%CE%B1%20%3A%20Type%20u%7D%20%7B%CE%B2%20%3A%20Type%20v%7D%20%3A%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B2%0A%7C%20f%20list.nil%20%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%20%20%20%3A%3D%20(f%20h)%3A%3A(map%20f%20t)%0A%0A--%20nat%20%E2%86%92%20nat%0A%23eval%20map%20nat.succ%20%5B0%2C1%2C2%2C3%2C4%5D%0A%23eval%20map%20(%CE%BB%20n%2C%20n%20*%20n)%20%5B0%2C1%2C2%2C3%2C4%5D%0A%0A--%20string%20%E2%86%92%20nat%0A%23eval%20map%20string.length%20%5B%22Hello%22%2C%20%22Lean%22%2C%20%22We%22%2C%20%22Love%22%2C%20%22You!%22%5D%0A%0A%23check%20%40list.map" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_139.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span> <span class="n">v</span>    <span class="c1">-- u is already a universe level</span>

<span class="kd">def</span> <span class="n">map</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#946;</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span>  <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span>    <span class="o">:=</span> <span class="o">(</span><span class="n">f</span> <span class="n">h</span><span class="o">)::(</span><span class="n">map</span> <span class="n">f</span> <span class="n">t</span><span class="o">)</span>

<span class="c1">-- nat &#8594; nat</span>
<span class="k">#eval</span> <span class="n">map</span> <span class="n">nat.succ</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">map</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span><span class="o">)</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>

<span class="c1">-- string &#8594; nat</span>
<span class="k">#eval</span> <span class="n">map</span> <span class="n">string.length</span> <span class="o">[</span><span class="s2">&quot;Hello&quot;</span><span class="o">,</span> <span class="s2">&quot;Lean&quot;</span><span class="o">,</span> <span class="s2">&quot;We&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;You!&quot;</span><span class="o">]</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">list.map</span>
</pre></div>
</div>
</div></section>
<section id="filter">
<h4><span class="section-number">4.4.3.2. </span>filter<a class="headerlink" href="#filter" title="Permalink to this heading">&#61633;</a></h4>
<p>The filter function, polymorphic in a type, &#945;, takes a list,
l, of &#945; values and a <em>predicate function</em>, p, from &#945; to bool,
and returns the sublist of elements in l that <em>satisfy</em> p.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20In%20this%20example%20we%20also%20introduce%20%22match%22%20for%20doing%20case%20analysis%20on%20a%20term%0Adef%20filter'%20%7B%CE%B1%20%3A%20Type%20u%7D%20%3A%20(%CE%B1%20%E2%86%92%20bool)%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20p%20list.nil%20%3A%3D%20list.nil%0A%7C%20p%20(h%3A%3At)%20%3A%3D%0A%20%20%20%20match%20(p%20h)%20with%0A%20%20%20%20%20%20%7C%20tt%20%3A%3D%20h%3A%3Afilter'%20p%20t%0A%20%20%20%20%20%20%7C%20ff%20%3A%3D%20filter'%20p%20t%0A%20%20%20%20end%0A%0A%23eval%20filter'%20((%CE%BB%20n%2C%20n%20%25%202%20%3D%200)%20%E2%88%98%20(string.length))%20%5B%22Hello%22%2C%20%22Lean%22%2C%20%22We%22%2C%20%22Love%22%2C%20%22You!%22%5D%0A%0A--%20same%20function%20using%20if%2Fthen%2Felse%3B%20there's%20still%20a%20coercion%20happening%20from%20(p%20h)%20to%20bool%0Adef%20filter%20%7B%CE%B1%20%3A%20Type%20u%7D%20%3A%20(%CE%B1%20%E2%86%92%20bool)%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20p%20list.nil%20%3A%3D%20list.nil%0A%7C%20p%20(h%3A%3At)%20%3A%3D%20if%20(p%20h)%20then%20(h%3A%3Afilter%20p%20t)%20else%20(filter%20p%20t)" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_165.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- In this example we also introduce &quot;match&quot; for doing case analysis on a term</span>
<span class="kd">def</span> <span class="n">filter&#39;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">p</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">p</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span>
    <span class="k">match</span> <span class="o">(</span><span class="n">p</span> <span class="n">h</span><span class="o">)</span> <span class="k">with</span>
      <span class="bp">|</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">h</span><span class="o">::</span><span class="n">filter&#39;</span> <span class="n">p</span> <span class="n">t</span>
      <span class="bp">|</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">filter&#39;</span> <span class="n">p</span> <span class="n">t</span>
    <span class="kd">end</span>

<span class="k">#eval</span> <span class="n">filter&#39;</span> <span class="o">((</span><span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="bp">&#8728;</span> <span class="o">(</span><span class="n">string.length</span><span class="o">))</span> <span class="o">[</span><span class="s2">&quot;Hello&quot;</span><span class="o">,</span> <span class="s2">&quot;Lean&quot;</span><span class="o">,</span> <span class="s2">&quot;We&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;You!&quot;</span><span class="o">]</span>

<span class="c1">-- same function using if/then/else; there&#39;s still a coercion happening from (p h) to bool</span>
<span class="kd">def</span> <span class="n">filter</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">p</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">p</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="n">h</span><span class="o">)</span> <span class="k">then</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">filter</span> <span class="n">p</span> <span class="n">t</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">filter</span> <span class="n">p</span> <span class="n">t</span><span class="o">)</span>
</pre></div>
</div>
</div></section>
<section id="fold">
<h4><span class="section-number">4.4.3.3. </span>fold<a class="headerlink" href="#fold" title="Permalink to this heading">&#61633;</a></h4>
<p>The <em>fold</em> function, also often called <em>reduce</em>, takes a list,
<em>l</em>, of values of some type, &#945;, and reduces it to a single value
of some type &#946;. It is defined by case analysis on <em>l</em>. If <em>l</em> is
nil, fold needs to return an approriate result. For now, we will
pass this &#8220;value for the base case&#8221; as an additional argument to
fold. In the second, cases, where <em>l</em> is non-empty and thus of
the form, <em>h::t,</em> fold returns the result obtained by applying
a given binary <em>reduction</em> function (also an argument) to (a)
the head of the list, and (b) the <em>reduced</em> (folded) value of
the rest of the list.</p>
<p>As an example, consider fold applied to the list [1,2,3] using
the binary operation, nat.add : nat &#8594; nat &#8594; nat as a reduction
operation. Here &#945; = &#946; = nat. The list is not nil, so we return
the result obtained by applying <em>nat.add</em> to 1 and the result
of reducing [2, 3] in the same way: fold nat.add [1,2,3] thus
reduces to <em>1 + fold nat.add [2, 3]</em>, which reduces to <em>1 + 2
+ fold nat.add [3]</em>, which reduces to <em>1 + 2 + 3 + fold nat.add
[]</em>. Clearly for this operation to return the right value, we
must define the last value to be zero.</p>
<p>So how do we define this fold function precisely? It&#8217;s by case
analysis on l. If l is nil, fold has to return the right value
for the given binary operation (zero in the preceding example).
If l is not nil, then it&#8217;s of the form (h::t), in which case the
fold function returns the result of applying the given reduction
operation to h and the result of recursively reducing the <em>rest</em>
of the list.</p>
<ul class="simple">
<li><p>Give an English language explanation of how fold can be used to convert a list of strings into a bool, where the result is true (tt) iff the length of each string in the list is even. Pay close attention to the type of the reduction binary operation you will need to produce a working result.</p></li>
<li><p>Exercise: Formalize the general type and give an implementation of the polymorphic fold function on lists.</p></li>
<li><p>Exercise: Give a few examples of applications to bolster the case for the claim that it works correctly.</p></li>
<li><p>Exercise: Use fold to implement a function that takes a list of strings and returns tt if all strings in the list are even length and false otherwise. Call it all_even. The trick will be to define the right reduction (binary) operation. Define it as a separate function, all_even_reducer.</p></li>
</ul>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20Your%20answer%20here%3A" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_223.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Your answer here:</span>
</pre></div>
</div>
</div></section>
</section>
<section id="id4">
<h3><span class="section-number">4.4.4. </span>Exercises<a class="headerlink" href="#id4" title="Permalink to this heading">&#61633;</a></h3>
<ul class="simple">
<li><p>Write an analog of the map function not for lists but for option values. Call is map_option.</p></li>
<li><p>Define a type, tree &#945;, whose values are either empty or an &#945; value and two smaller trees; then define a variant of the map function operating on such trees, calling it map_tree.</p></li>
<li><p>There an interesting commonality here. How might one generalize our list-based map function to <em>any</em> type of data structure containing values of some type &#945;, where what you want back is the same structure but with all the &#945; values replaced by &#946; values?</p></li>
<li><p>Can you use parametric polymorphism to solve the preceding problem. Explain why or why not.</p></li>
</ul>
</section>
</section>
<section id="recursive-proofs">
<h2><span class="section-number">4.5. </span>Recursive Proofs<a class="headerlink" href="#recursive-proofs" title="Permalink to this heading">&#61633;</a></h2>
<section id="id5">
<h3><span class="section-number">4.5.1. </span>Introduction<a class="headerlink" href="#id5" title="Permalink to this heading">&#61633;</a></h3>
<p>Coming soon.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20le%20(n%20%3A%20nat)%3A%20nat%20%E2%86%92%20Prop%0A--%20n%20is%20an%20implicit%20firt%20argument%20to%20each%20constructor%0A%7C%20refl%20%3A%20le%20%2F-n-%2F%20n%0A%7C%20step%20%3A%20%E2%88%80%20m%2C%20le%20%2F-n-%2F%20m%20%E2%86%92%20le%20%2F-n-%2F%20m.succ%0A%0A--%20you%20can%20see%20it%20in%20the%20types%20of%20the%20constructors%0A%23check%20%40le.refl%0A%23check%20%40le.step%0A%0A%0Aexample%20%3A%20le%200%200%20%3A%3D%0Abegin%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%203%203%20%3A%3D%0Abegin%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%200%201%20%3A%3D%0Abegin%0Aapply%20le.step%2C%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%200%203%20%3A%3D%0Abegin%0Aapply%20le.step%2C%0Aapply%20le.step%2C%0Aapply%20le.step%2C%0Aapply%20le.refl%2C%0Aend%0A%0A%0A--%20here's%20the%20same%20example%20using%20Lean's%20version%20of%20%22le%22%0A--%20it's%20called%20nat.less_than_or_equal%0Aexample%20%3A%200%20%E2%89%A4%203%20%3A%3D%0Abegin%0Aapply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.step%2C%0A--%20apply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.refl%2C%0Aend%0A%0A--%20repeat%20tactical%20goes%20too%20far%3B%20use%20iterate%20instead%0Aexample%20%3A%201%20%E2%89%A4%204%20%3A%3D%0Abegin%0A--%20repeat%20%7Bapply%20nat.less_than_or_equal.step%7D%2C%0Aiterate%203%20%7Bapply%20nat.less_than_or_equal.step%7D%2C%0Aapply%20nat.less_than_or_equal.refl%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_10.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">le</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">):</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>
<span class="c1">-- n is an implicit firt argument to each constructor</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">le</span> <span class="c">/-</span><span class="cm">n-/</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">m</span><span class="o">,</span> <span class="n">le</span> <span class="c">/-</span><span class="cm">n-/</span> <span class="n">m</span> <span class="bp">&#8594;</span> <span class="n">le</span> <span class="c">/-</span><span class="cm">n-/</span> <span class="n">m.succ</span>

<span class="c1">-- you can see it in the types of the constructors</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">le.refl</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">le.step</span>


<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">3</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>


<span class="c1">-- here&#39;s the same example using Lean&#39;s version of &quot;le&quot;</span>
<span class="c1">-- it&#39;s called nat.less_than_or_equal</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&#8804;</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="c1">-- apply nat.less_than_or_equal.step,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- repeat tactical goes too far; use iterate instead</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&#8804;</span> <span class="mi">4</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">-- repeat {apply nat.less_than_or_equal.step},</span>
<span class="n">iterate</span> <span class="mi">3</span> <span class="o">{</span><span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">},</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.refl</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="A_02_Constructive_Logic.html" class="btn btn-neutral float-left" title="3. Constructive Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="A_04_Dependent_Types.html" class="btn btn-neutral float-right" title="5. Dependent Types" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kevin Sullivan.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>