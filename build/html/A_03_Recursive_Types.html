<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4. Recursive Types &mdash; CS6501 Spring 2023 1.2.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Typeclasses" href="A_04_Typeclasses.html" />
    <link rel="prev" title="3. Constructive Logic" href="A_02_Constructive_Logic.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CS6501 Spring 2023
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="A_00_Introduction.html">1. CS6501 Spring 2023</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_01_Propositional_Logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_02_Constructive_Logic.html">3. Constructive Logic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Recursive Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">4.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#natural-numbers">4.2. Natural Numbers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-type">4.2.1. Data Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operations">4.2.2. Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#polymorphic-lists">4.3. Polymorphic Lists</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">4.3.1. Data Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notations">4.3.2. Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">4.3.3. Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-functions">4.3.4. Partial Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default-value">4.3.4.1. Default Value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#option-values">4.3.4.2. Option Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#precondition">4.3.4.3. Precondition</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">4.3.5. Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solutions">4.3.6. Solutions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#higher-order-functions">4.4. Higher-Order Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#in-logic">4.4.1. In Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition">4.4.2. Composition</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example">4.4.2.1. Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#notation">4.4.2.2. Notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-with-two-types">4.4.2.3. Example With Two Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#map">4.4.3. Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fold-list">4.4.4. Fold list: &#945; &#8594; &#945; &#8594; &#945;</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">4.4.4.1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generalizing-the-binary-operation">4.4.4.2. Generalizing the binary operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operator-identity-inconsistency">4.4.4.3. Operator-identity inconsistency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enforcing-op-id-consistency">4.4.4.4. Enforcing op-id consistency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#from-binary-to-n-ary-operations">4.4.4.5. From binary to n-ary operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">4.4.5. Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">4.4.6. Fold list: &#945; &#8594; &#946; &#8594; &#946;</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mixed-type-binary-operations">4.4.6.1. Mixed-type binary operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extending-such-operations">4.4.6.2. Extending such operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#summary">4.4.7. Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">4.4.8. Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="#looking-forward">4.4.9. Looking forward</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#recursive-proofs">4.5. Recursive Proofs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-idea-by-example">4.5.1. The Idea by Example</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-problem">4.5.1.1. The Problem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-solution">4.5.1.2. A Solution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary-proof-by-induction">4.5.1.3. Summary: Proof by Induction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#theorem-0-is-identity-for">4.5.1.4. Theorem: 0 is identity for &#10216;&#8469;, +&#10217;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#induction-axiom-for">4.5.1.5. Induction Axiom for &#8469;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#theorem-1-is-identity-for">4.5.1.6. Theorem: 1 is identity for &#10216;&#8469;, *&#10217;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#theorems-and-associative">4.5.1.7. Theorems: &#8469; + and * associative</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monoids-and-foldr">4.5.1.8. Monoids and Foldr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#induction-axioms">4.5.2. Induction Axioms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#theorem-list-append-identity">4.5.2.1. Theorem: [] list append identity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#induction-axiom-for-lists">4.5.2.2. Induction Axiom for Lists</a></li>
<li class="toctree-l4"><a class="reference internal" href="#theorem-monoid-list">4.5.2.3. Theorem: monoid (list &#945;)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-families">4.5.3. Inductive Families</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="A_04_Typeclasses.html">5. Typeclasses</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_05_Algebraic_Structures.html">6. Algebraic Structures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CS6501 Spring 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">4. </span>Recursive Types</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/A_03_Recursive_Types.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="recursive-types">
<span id="introduction"></span><h1><span class="section-number">4. </span>Recursive Types<a class="headerlink" href="#recursive-types" title="Permalink to this heading">&#61633;</a></h1>
<section id="id1">
<h2><span class="section-number">4.1. </span>Introduction<a class="headerlink" href="#id1" title="Permalink to this heading">&#61633;</a></h2>
<p>In this chapter we&#8217;ll look at inductive data types
definitions that specify objects that have recursive
structure. In particular, we&#8217;ll look at the <em>nat</em> and
polymorphic <em>list</em> types, with an eye to seeing some
interesting algebraic commonalities.</p>
</section>
<section id="natural-numbers">
<h2><span class="section-number">4.2. </span>Natural Numbers<a class="headerlink" href="#natural-numbers" title="Permalink to this heading">&#61633;</a></h2>
<section id="data-type">
<h3><span class="section-number">4.2.1. </span>Data Type<a class="headerlink" href="#data-type" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20nat" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_8.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">nat</span>
</pre></div>
</div>
</div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20notations%20for%20writing%20succ%20applications%0Adef%20three'%20%20%3A%3D%20(nat.succ%20(nat.succ%20(nat.succ%20(nat.zero))))%0Adef%20three%20%20%3A%3D%20nat.zero.succ.succ.succ" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_13.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- notations for writing succ applications</span>
<span class="kd">def</span> <span class="n">three&#39;</span>  <span class="o">:=</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.zero</span><span class="o">))))</span>
<span class="kd">def</span> <span class="n">three</span>  <span class="o">:=</span> <span class="n">nat.zero.succ.succ.succ</span>
</pre></div>
</div>
</div></section>
<section id="operations">
<h3><span class="section-number">4.2.2. </span>Operations<a class="headerlink" href="#operations" title="Permalink to this heading">&#61633;</a></h3>
<p>Having seen how the <em>nat</em> data type is defined, we now look
at how to define functions taking <em>nat</em> values as arguments.
As we&#8217;ve seen before, many such functions here will again be
defined by case analysis on an incoming nat argument value.
That means considering two cases separately: the incoming value
is either zero or non-zero: that is, either <em>nat.zero,</em> or
<em>nat.succ n&#8217;</em> for some &#8220;one-smaller&#8221; value, <em>n&#8217;</em>. For example,
if the incoming argument is <em>succ(succ(succ zero))</em>, i.e., 3,
then (a) it does not match <em>nat.zero</em>, but (b) it does match
<em>nat.succ n&#8217;</em>, with <em>n&#8217;</em> is bound to <em>succ(succ zero)</em>, i.e., 2.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20increment%20is%20just%20succ%20application%0Adef%20inc%20(n'%20%3A%20nat)%20%3A%20nat%20%3A%3D%20n'.succ%0Adef%20three''%20%3A%3D%20inc(inc(inc%20nat.zero))" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_33.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- increment is just succ application</span>
<span class="kd">def</span> <span class="n">inc</span> <span class="o">(</span><span class="n">n&#39;</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">n&#39;.succ</span>
<span class="kd">def</span> <span class="n">three&#39;&#39;</span> <span class="o">:=</span> <span class="n">inc</span><span class="o">(</span><span class="n">inc</span><span class="o">(</span><span class="n">inc</span> <span class="n">nat.zero</span><span class="o">))</span>
</pre></div>
</div>
</div><p>A predecessor (one less than) function can be defined by
case analysis on a nat argument. Here we&#8217;ll define <em>pred&#8217;</em>
to return 0 when applied to 0, and otherwise to return the
one smaller value, <em>n&#8217;</em>, when applied to any non-zero value,
<em>nat.succ n&#8217;</em>.</p>
<p>Rather than &#8220;implementing a function&#8221; think &#8220;proving a function
type.&#8221; A &#8220;proof&#8221; of function type, <em>nat &#8594; nat,</em> is any function
that converts any given nat into some resulting nat.</p>
<p>When proving a proposition (a type in Prop), any proof (value
of that type) will do. When proving function or other data type,
however, the particular value of the type that you construct is
usually important. Here, for example, we don&#8217;t want any function
that takes and returns a nat, but one that returns the right nat
for the given argument.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20pred'%20%3A%20nat%20%E2%86%92%20nat%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%0Aexact%200%2C%20%20--%20when%20n%20is%20zero%0Aexact%20n'%2C%20--%20when%20n%20is%20succ%20n'%0Aend%0A%0A--%20quick%20test%0A%23eval%20pred'%206%0Aexample%20%3A%20pred'%206%20%3D%205%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_56.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">pred&#39;</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="n">exact</span> <span class="mi">0</span><span class="o">,</span>  <span class="c1">-- when n is zero</span>
<span class="n">exact</span> <span class="n">n&#39;</span><span class="o">,</span> <span class="c1">-- when n is succ n&#39;</span>
<span class="kd">end</span>

<span class="c1">-- quick test</span>
<span class="k">#eval</span> <span class="n">pred&#39;</span> <span class="mi">6</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">pred&#39;</span> <span class="mi">6</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Here&#8217;s the same function just specified
using pattern matching notation (which,
as we&#8217;ve seen generalizes case analysis).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20pred%20%3A%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20%3A%3D%20nat.zero%20%20--%20loop%20at%20zero%0A%7C%20(nat.succ%20n')%20%3A%3D%20n'%0A%0A%23eval%20pred%205%0Aexample%20%3A%20pred%205%20%3D%204%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_74.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">pred</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">nat.zero</span>  <span class="c1">-- loop at zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="k">#eval</span> <span class="n">pred</span> <span class="mi">5</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">pred</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Pattern matching generalizes case analysis
by giving you a means to return different
results based on deeper analysis of argument
structures using pattern matching/unification.
This example implements subtract-two, looping
at zero. Notice how the third pattern matches
to the sub-natural-number object nested two
succ-levels deep.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20this%20example%20illustrates%20pattern%20matching%0A--%20for%20more%20fine-grained%20case%20analysis%0Adef%20sub2%20%3A%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20%3A%3D%20nat.zero%0A%7C%20(nat.succ%20nat.zero)%20%3A%3D%20nat.zero%0A%7C%20(nat.succ%20(nat.succ%20n'))%20%3A%3D%20n'%0A%0A--%20addition%20increments%20the%20second%20argument%0A--%20the%20first%20argument%20number%20of%20times%0Adef%20plus%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20nat.zero%20m%20%3A%3D%20m%0A%7C%20(nat.succ%20n')%20m%20%3A%3D%20nat.succ%20(plus%20n'%20m)%0A%0A%23eval%20plus%203%204%0A%0A--%20multiplication%20adds%20the%20second%20argument%0A--%20to%20itself%20the%20first%20argumen%20number%20of%20times%0Adef%20times%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%200%20m%20%3A%3D%200%0A%7C%20(n'%2B1)%20m%20%3A%3D%20plus%20m%20(times%20n'%20m)%0A%0A%23eval%20times%205%204%0A%23eval%20times%201%2020%0A%0A%0A--%20substraction%20illustrates%20case%20analysis%20on%0A--%20multiple%20(here%20two)%20arguments%20at%20once%0Adef%20subtract%20%3A%20%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%200%20_%20%3A%3D%200%0A%7C%20n%200%20%3A%3D%20n%0A%7C%20(n'%20%2B%201)%20(m'%20%2B%201)%20%3A%3D%20subtract%20n'%20m'%0A%0A%23eval%20subtract%207%205%0A%23eval%20subtract%207%200%0A%23eval%20subtract%205%207%0A%23eval%20subtract%200%207%0A%0A%0A--%20exponentiation%20is%20multiplication%20of%20the%20second%0A--%20argument%20by%20itself%20the%20first%20argument%20number%20of%20times%0Adef%20power%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20n%20nat.zero%20%3A%3D%201%0A%7C%20n%20(nat.succ%20m')%20%3A%3D%20times%20n%20(power%20n%20m')%0A%0A--%20a%20few%20test%20cases%0Aexample%20%3A%20power%202%200%20%3D%201%20%3A%3D%20rfl%0Aexample%20%3A%20power%202%208%20%3D%20256%20%3A%3D%20rfl%0Aexample%20%3A%20power%202%2010%20%3D%201024%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_92.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- this example illustrates pattern matching</span>
<span class="c1">-- for more fine-grained case analysis</span>
<span class="kd">def</span> <span class="n">sub2</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">nat.zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.zero</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">))</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="c1">-- addition increments the second argument</span>
<span class="c1">-- the first argument number of times</span>
<span class="kd">def</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">nat.succ</span> <span class="o">(</span><span class="n">plus</span> <span class="n">n&#39;</span> <span class="n">m</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">plus</span> <span class="mi">3</span> <span class="mi">4</span>

<span class="c1">-- multiplication adds the second argument</span>
<span class="c1">-- to itself the first argumen number of times</span>
<span class="kd">def</span> <span class="n">times</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">m</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n&#39;</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">plus</span> <span class="n">m</span> <span class="o">(</span><span class="n">times</span> <span class="n">n&#39;</span> <span class="n">m</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">times</span> <span class="mi">5</span> <span class="mi">4</span>
<span class="k">#eval</span> <span class="n">times</span> <span class="mi">1</span> <span class="mi">20</span>


<span class="c1">-- substraction illustrates case analysis on</span>
<span class="c1">-- multiple (here two) arguments at once</span>
<span class="kd">def</span> <span class="n">subtract</span> <span class="o">:</span>  <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">_</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">n</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n&#39;</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">m&#39;</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">subtract</span> <span class="n">n&#39;</span> <span class="n">m&#39;</span>

<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">7</span> <span class="mi">5</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">7</span> <span class="mi">0</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">5</span> <span class="mi">7</span>
<span class="k">#eval</span> <span class="n">subtract</span> <span class="mi">0</span> <span class="mi">7</span>


<span class="c1">-- exponentiation is multiplication of the second</span>
<span class="c1">-- argument by itself the first argument number of times</span>
<span class="kd">def</span> <span class="n">power</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">m&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">times</span> <span class="n">n</span> <span class="o">(</span><span class="n">power</span> <span class="n">n</span> <span class="n">m&#39;</span><span class="o">)</span>

<span class="c1">-- a few test cases</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">8</span> <span class="bp">=</span> <span class="mi">256</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">power</span> <span class="mi">2</span> <span class="mi">10</span> <span class="bp">=</span> <span class="mi">1024</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div></section>
</section>
<section id="polymorphic-lists">
<h2><span class="section-number">4.3. </span>Polymorphic Lists<a class="headerlink" href="#polymorphic-lists" title="Permalink to this heading">&#61633;</a></h2>
<section id="id2">
<h3><span class="section-number">4.3.1. </span>Data Type<a class="headerlink" href="#id2" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20list" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_8.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">list</span>
</pre></div>
</div>
</div><p>The list data type is surprising similar to the nat
data type. Where as a larger nat is constructed from
only a smaller nat, a larger list is constructed from
a new first element (the <em>head</em> of the new list) and
a smaller list (the <em>tail</em> of the new list). This type
builder enables us to represent lists of values of any
type and of any finite length.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0Ainductive%20list%20(T%20%3A%20Type%20u)%0A%7C%20nil%20%3A%20list%0A%7C%20cons%20(hd%20%3A%20T)%20(tl%20%3A%20list)%20%3A%20list" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_20.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span> <span class="n">u</span>
<span class="kd">inductive</span> <span class="n">list</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">nil</span> <span class="o">:</span> <span class="n">list</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">T</span><span class="o">)</span> <span class="o">(</span><span class="n">tl</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span>
</pre></div>
</div>
</div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20example%3A%20let's%20represent%20the%20list%20of%20nats%2C%20%5B1%2C2%2C3%5D%0Adef%20three_list_nat''%20%3A%3D%0A%20%20list.cons%20%20%20--%20takes%20two%20arguments%0A%20%20%20%201%20%20%20%20%20%20%20%20%20--%20head%20of%20new%20list%0A%20%20%20%20(%20%20%20%20%20%20%20%20%20--%20tail%20list%20of%20the%20new%20list%0A%20%20%20%20%20%20list.cons%20%20%20--%20etc.%0A%20%20%20%20%20%20%20%202%0A%20%20%20%20%20%20%20%20(%0A%20%20%20%20%20%20%20%20%20%20list.cons%0A%20%20%20%20%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A--%20it%20seems%20to%20have%20worked%0A%23reduce%20three_list_nat''" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_28.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- example: let&#39;s represent the list of nats, [1,2,3]</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;</span> <span class="o">:=</span>
  <span class="n">list.cons</span>   <span class="c1">-- takes two arguments</span>
    <span class="mi">1</span>         <span class="c1">-- head of new list</span>
    <span class="o">(</span>         <span class="c1">-- tail list of the new list</span>
      <span class="n">list.cons</span>   <span class="c1">-- etc.</span>
        <span class="mi">2</span>
        <span class="o">(</span>
          <span class="n">list.cons</span>
            <span class="mi">3</span>
            <span class="n">list.nil</span>
        <span class="o">)</span>
    <span class="o">)</span>

<span class="c1">-- it seems to have worked</span>
<span class="k">#reduce</span> <span class="n">three_list_nat&#39;&#39;</span>
</pre></div>
</div>
</div></section>
<section id="notations">
<h3><span class="section-number">4.3.2. </span>Notations<a class="headerlink" href="#notations" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20notation%2C%20%3A%3A%20is%20infix%20for%20cons%0A--%20%5B%5D%20notation%20adds%20nil%20at%20end%0Adef%20three_list_nat'''%20%3A%3D%201%3A%3A2%3A%3A3%3A%3Alist.nil%0Adef%20three_list_nat''''%20%3A%3D%20%5B1%2C2%2C3%5D%0Adef%20four_list_nat%20%3A%3D%200%3A%3A%5B1%2C2%2C3%5D%20%20%20%20%20%20%20--%20fun!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_50.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- notation, :: is infix for cons</span>
<span class="c1">-- [] notation adds nil at end</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;&#39;</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">::</span><span class="mi">2</span><span class="o">::</span><span class="mi">3</span><span class="o">::</span><span class="n">list.nil</span>
<span class="kd">def</span> <span class="n">three_list_nat&#39;&#39;&#39;&#39;</span> <span class="o">:=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="kd">def</span> <span class="n">four_list_nat</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">::[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>       <span class="c1">-- fun!</span>
</pre></div>
</div>
</div></section>
<section id="id3">
<h3><span class="section-number">4.3.3. </span>Operations<a class="headerlink" href="#id3" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20list%20prepend%20analogous%20to%20nat%20increment%0Adef%20prepend'%20(%CE%B1%20%3A%20Type)%20(a%20%3A%20%CE%B1)%20(l%20%3A%20list%20%CE%B1)%20%3A%3D%0A%20%20list.cons%20a%20l%0A%0Adef%20three_list_nat'%20%3A%3D%0A%20%20prepend'%20nat%0A%20%20%20%201%0A%20%20%20%20(prepend'%20nat%0A%20%20%20%20%20%202%0A%20%20%20%20%20%20(prepend'%20nat%0A%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A%23eval%20three_list_nat'%0A%0A--%20here%20with%20an%20implicit%20type%20parameter%2C%20making%20it%20equivalent%20to%20cons%0Adef%20prepend%20%7B%CE%B1%20%3A%20Type%7D%20(a%20%3A%20%CE%B1)%20(l%20%3A%20list%20%CE%B1)%20%3A%3D%0A%20%20list.cons%20a%20l%0A%0Adef%20three_list_nat%20%3A%3D%0A%20%20prepend%0A%20%20%20%201%0A%20%20%20%20(prepend%0A%20%20%20%20%20%202%0A%20%20%20%20%20%20(prepend%0A%20%20%20%20%20%20%20%203%0A%20%20%20%20%20%20%20%20list.nil%0A%20%20%20%20%20%20)%0A%20%20%20%20)%0A%0A--%20okay%2C%20that%20looks%20good%0A--%20but%20know%20that%20to%20which%20it%20desugars%0A%0Aexample%20%3A%3D%20prepend'%20nat%202%20%5B3%2C4%2C5%5D%0A%23eval%20prepend'%20nat%202%20%5B3%2C4%2C5%5D%0A%0Aexample%20%3A%3D%20prepend%202%20%5B3%2C4%2C5%5D%0A%23eval%20prepend%202%20%5B3%2C4%2C5%5D%0A%0A%23eval%202%3A%3A%5B3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_61.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- list prepend analogous to nat increment</span>
<span class="kd">def</span> <span class="n">prepend&#39;</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.cons</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">three_list_nat&#39;</span> <span class="o">:=</span>
  <span class="n">prepend&#39;</span> <span class="n">nat</span>
    <span class="mi">1</span>
    <span class="o">(</span><span class="n">prepend&#39;</span> <span class="n">nat</span>
      <span class="mi">2</span>
      <span class="o">(</span><span class="n">prepend&#39;</span> <span class="n">nat</span>
        <span class="mi">3</span>
        <span class="n">list.nil</span>
      <span class="o">)</span>
    <span class="o">)</span>

<span class="k">#eval</span> <span class="n">three_list_nat&#39;</span>

<span class="c1">-- here with an implicit type parameter, making it equivalent to cons</span>
<span class="kd">def</span> <span class="n">prepend</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.cons</span> <span class="n">a</span> <span class="n">l</span>

<span class="kd">def</span> <span class="n">three_list_nat</span> <span class="o">:=</span>
  <span class="n">prepend</span>
    <span class="mi">1</span>
    <span class="o">(</span><span class="n">prepend</span>
      <span class="mi">2</span>
      <span class="o">(</span><span class="n">prepend</span>
        <span class="mi">3</span>
        <span class="n">list.nil</span>
      <span class="o">)</span>
    <span class="o">)</span>

<span class="c1">-- okay, that looks good</span>
<span class="c1">-- but know that to which it desugars</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="n">prepend&#39;</span> <span class="n">nat</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">prepend&#39;</span> <span class="n">nat</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>

<span class="kd">example</span> <span class="o">:=</span> <span class="n">prepend</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">prepend</span> <span class="mi">2</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>

<span class="k">#eval</span> <span class="mi">2</span><span class="o">::[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
<section id="partial-functions">
<h3><span class="section-number">4.3.4. </span>Partial Functions<a class="headerlink" href="#partial-functions" title="Permalink to this heading">&#61633;</a></h3>
<p>Now we face some interesting issues. Our aim is to define
functions that <em>analyze</em> lists and return parts of them.
The problem is that there are no parts when a given list
is empty.</p>
<p>When we defined pred, above, we defined pred of zero to be
zero (rather than to be undefined). Doing that makes the
function total and easily represented as a function (lambda
abstractraction) in Lean. However, in a different application
we really might want to define pred 0 to be undefined, not 0.</p>
<p>A similar set of issues arises when we consider head and
tail functions on lists. When given non-empty lists there
is no problem. But what to do with an empty list argument?
There is no head or tail element to return, yet some value
of the specified type <em>has to be</em> returned.</p>
<p>Let&#8217;s see some fo the solutions that are available.</p>
<section id="default-value">
<h4><span class="section-number">4.3.4.1. </span>Default Value<a class="headerlink" href="#default-value" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20a%20version%20of%20tail%20that%20%22loops%20at%20zero%22%0Adef%20tail'%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%2C%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20%3A%3D%20list.nil%0A%7C%20%CE%B1%20(h%3A%3At)%20%3A%3D%20t%0A%23eval%20tail'%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_131.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- a version of tail that &quot;loops at zero&quot;</span>
<span class="kd">def</span> <span class="n">tail&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">t</span>
<span class="k">#eval</span> <span class="n">tail&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div><p>One nice thing about this solution
is that the function type is still about as natural as
can be: list &#945; &#8594; list &#945;.</p>
</section>
<section id="option-values">
<h4><span class="section-number">4.3.4.2. </span>Option Values<a class="headerlink" href="#option-values" title="Permalink to this heading">&#61633;</a></h4>
<p>The next solution changes the type of the function,
so that return value is in the form of a <em>variant</em>
type, a value of which is either <em>none</em> or <em>some
valid return value</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20head''%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%2C%20list%20%CE%B1%20%E2%86%92%20option%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20%3A%3D%20none%0A%7C%20%CE%B1%20(h%3A%3At)%20%3A%3D%20some%20h%0A%0A%23eval%20head''%20%5B1%2C2%2C3%5D%0A%23eval%20%40head''%20nat%20%5B%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_151.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">head&#39;&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">},</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">none</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">h</span>

<span class="k">#eval</span> <span class="n">head&#39;&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">head&#39;&#39;</span> <span class="n">nat</span> <span class="o">[]</span>
</pre></div>
</div>
</div></section>
<section id="precondition">
<h4><span class="section-number">4.3.4.3. </span>Precondition<a class="headerlink" href="#precondition" title="Permalink to this heading">&#61633;</a></h4>
<p>Finally, we can define a version of head&#8217; that (1) typechecks
as being a total function, (2) can never actually be applied
fully to an empty list, in which case (3) no real result has
to be specified to &#8220;prove the return type&#8221; because such a case
can&#8217;t happen. It would be a contradiction if it did, and so it
can be dismissed as an impossibility. Magic: It <em>is</em> a total
function, but it can never be fully appied to an empty list
because a required proof argument, for <em>that</em> list, can never
be given; so one can dismiss this case by false elimination,
without having to give an actual proof of the conclusion.</p>
<p>Consider a head function. It returns the head element from
a non-empty list, but is undefined mathematically when it&#8217;s
applied to an empty list. The key idea in the next design
is that we can embed a <em>precondition</em> for application of
the function, namely that the given list not be empty. Let&#8217;s
see how e might first write the function using a tactic
script, to take advantage of your familiarity with using
it to build proofs.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20head'%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%7D%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20%CE%B1%0A%7C%20%20%CE%B1%20l%20p%20%3A%3D%0Abegin%0Acases%20l%2C%0Acontradiction%2C%0Aexact%20l_hd%2C%0Aend%0A%0A--%20When%20applying%20it%20a%20proof%20about%20the%20first%20argument%20has%20to%20be%20given%0A%23eval%20head'%20%5B1%2C2%2C3%5D%20begin%20contradiction%20end%20%20%20--%20proof%20as%20a%20proof%20script%0A%23eval%20head'%20%5B1%2C2%2C3%5D%20(by%20contradiction)%20%20%20%20%20%20%20%20--%20alternative%20syntax%2C%20fyi%0A%23eval%20head'%20(%5B%5D%20%3A%20list%20nat)%20_%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20you'll%20need%20a%20proof%20of%20list.nil%20%E2%89%A0%20list.nil!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_184.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">head&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="o">(</span><span class="n">l</span> <span class="bp">&#8800;</span> <span class="n">list.nil</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span>
<span class="bp">|</span>  <span class="n">&#945;</span> <span class="n">l</span> <span class="n">p</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">cases</span> <span class="n">l</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">l_hd</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- When applying it a proof about the first argument has to be given</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="kd">begin</span> <span class="n">contradiction</span> <span class="kd">end</span>   <span class="c1">-- proof as a proof script</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>        <span class="c1">-- alternative syntax, fyi</span>
<span class="k">#eval</span> <span class="n">head&#39;</span> <span class="o">([]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span><span class="o">)</span> <span class="n">_</span>                 <span class="c1">-- you&#39;ll need a proof of list.nil &#8800; list.nil!</span>
</pre></div>
</div>
</div></section>
</section>
<section id="exercises">
<h3><span class="section-number">4.3.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">&#61633;</a></h3>
<ul class="simple">
<li><p>Write a version of the pred function that can only be called for argument values greater than 0.</p></li>
<li><p>Write a version of the pred function that returns an option nat value &#8220;in the usual way&#8221;</p></li>
<li><p>Write a tail function that can only be called with a non-empty list, using our &#8220;by cases&#8221; notation for function definition. It should look like tail&#8217;. Note 1: Where a proof value is required, you can always use tactic mode to construct the required proof, in a begin..end block. If such a proof is a single tactic long, you can write by &lt;tactic&gt;. For example, try by contradiction as the <em>result</em> when your new tail function is applied to an empty list. Here&#8217;s how I wrote the function type. You should provide the cases (on l). Here&#8217;s the type: def tail {&#945; : Type} : &#8704; (l : list &#945;), (l &#8800; list.nil) &#8594; list &#945;.</p></li>
</ul>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20implement%20the%20function%2C%20no%20need%20to%20(do%20not%20try)%20to%20match%20on%20%CE%B1%0A--%20it's%20named%20before%20the%20colon%20and%20is%20global%20to%20this%20definition%0A--%20we%20do%20want%20to%20match%20(do%20case%20analysis)%20on%20l%2C%20so%20it's%20after%20%3A%0A--%20def%20tail%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20%E2%88%80%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20list%20%CE%B1%0A--%20%7C%0A--%20%7C" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_206.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- implement the function, no need to (do not try) to match on &#945;</span>
<span class="c1">-- it&#39;s named before the colon and is global to this definition</span>
<span class="c1">-- we do want to match (do case analysis) on l, so it&#39;s after :</span>
<span class="c1">-- def tail {&#945; : Type} : &#8704; (l : list &#945;), (l &#8800; list.nil) &#8594; list &#945;</span>
<span class="c1">-- |</span>
<span class="c1">-- |</span>
</pre></div>
</div>
</div></section>
<section id="solutions">
<h3><span class="section-number">4.3.6. </span>Solutions<a class="headerlink" href="#solutions" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20let's%20implement%20a%20%22safe%22%20pred%20function%20using%20tactics%0Adef%20pred'%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20(n%20%E2%89%A0%20nat.zero)%20%E2%86%92%20%E2%84%95%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%0Aassume%20h%2C%0Acontradiction%2C%0Aassume%20h%2C%0Aexact%20n'%2C%0Aend%0A%0A%23reduce%20pred'%205%20_%0A%23reduce%20pred'%202%20_%0A%23reduce%20pred'%200%20_%0A%0A--%20here's%20the%20same%20predecessor%20function%20presented%20differently%0Adef%20pred''%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20(n%20%E2%89%A0%20nat.zero)%20%E2%86%92%20%E2%84%95%0A%7C%20nat.zero%20h%20%3A%3D%20by%20contradiction%0A%7C%20(nat.succ%20n')%20h%20%3A%3D%20n'%0A%0A--%20a%20different%20safe%20predecessor%20function%20using%20an%20option%20return%0Adef%20pred'''%20%3A%20nat%20%E2%86%92%20option%20nat%0A%7C%20nat.zero%20%3A%3D%20option.none%0A%7C%20(nat.succ%20n')%20%3A%3D%20some%20n'%0A%0A--%20the%20same%20ideas%20work%20for%20safe%20head%20and%20tail%20functions%20on%20lists%0Auniverse%20u%0Adef%20tail%20%3A%20%E2%88%80%20%7B%CE%B1%20%3A%20Type%20u%7D%20(l%20%3A%20list%20%CE%B1)%2C%20(l%20%E2%89%A0%20list.nil)%20%E2%86%92%20list%20%CE%B1%0A%7C%20%CE%B1%20list.nil%20p%20%3A%3D%20by%20contradiction%0A%7C%20%CE%B1%20(h%3A%3At)%20p%20%3A%3D%20t%0A%0A--%20apply%20tail%20to%20%5B1%2C2%2C3%5D%20giving%20the%20proof%20as%20a%20tactic%20script%0A%23eval%20tail%20%5B1%2C2%2C3%5D%0Abegin%0Aassume%20p%2C%0Acontradiction%2C%0Aend%0A%0A--%20cleaner%20this%20way%0A%23eval%20tail%20%5B1%2C2%2C3%5D%20(by%20contradiction)%0A%23eval%20tail%20%5B2%2C3%5D%20(by%20contradiction)%0A%23eval%20tail%20%5B3%5D%20(by%20contradiction)%0A%23eval%20%40tail%20nat%20%5B%5D%20(by%20contradiction)%20%20%20%20%20%20--%20no%20can%20do!%0A%0A--%20let's%20try%20it%20with%20a%20tactic%20script%0A%23eval%20%40tail%20nat%20%5B%5D%0Abegin%0Aassume%20h%2C%20%20%20--%20we're%20stuck%2C%20and%20that's%20good!%0Aend%0A%0A%0A--%20append%3A%20the%20list%20analog%20of%20natural%20number%20addition%0A--%20please%20do%20compare%2Fcontrast%20list.append%20and%20nat.add%0Adef%20appnd%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20list.nil%20m%20%3A%3D%20m%0A%7C%20(h%3A%3At)%20m%20%3A%3D%20h%3A%3Aappnd%20t%20m%0A%0A%23eval%20appnd%20%5B1%2C2%2C3%5D%20%5B4%2C3%2C2%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_218.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- let&#39;s implement a &quot;safe&quot; pred function using tactics</span>
<span class="kd">def</span> <span class="n">pred&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&#8800;</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">5</span> <span class="n">_</span>
<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">2</span> <span class="n">_</span>
<span class="k">#reduce</span> <span class="n">pred&#39;</span> <span class="mi">0</span> <span class="n">_</span>

<span class="c1">-- here&#39;s the same predecessor function presented differently</span>
<span class="kd">def</span> <span class="n">pred&#39;&#39;</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&#8800;</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="n">h</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">n&#39;</span>

<span class="c1">-- a different safe predecessor function using an option return</span>
<span class="kd">def</span> <span class="n">pred&#39;&#39;&#39;</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">option</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">nat.zero</span> <span class="o">:=</span> <span class="n">option.none</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">some</span> <span class="n">n&#39;</span>

<span class="c1">-- the same ideas work for safe head and tail functions on lists</span>
<span class="kd">universe</span> <span class="n">u</span>
<span class="kd">def</span> <span class="n">tail</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="o">(</span><span class="n">l</span> <span class="bp">&#8800;</span> <span class="n">list.nil</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="n">list.nil</span> <span class="n">p</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="n">&#945;</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">t</span>

<span class="c1">-- apply tail to [1,2,3] giving the proof as a tactic script</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">p</span><span class="o">,</span>
<span class="n">contradiction</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- cleaner this way</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="n">tail</span> <span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">tail</span> <span class="n">nat</span> <span class="o">[]</span> <span class="o">(</span><span class="kd">by</span> <span class="n">contradiction</span><span class="o">)</span>      <span class="c1">-- no can do!</span>

<span class="c1">-- let&#39;s try it with a tactic script</span>
<span class="k">#eval</span> <span class="bp">@</span><span class="n">tail</span> <span class="n">nat</span> <span class="o">[]</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>   <span class="c1">-- we&#39;re stuck, and that&#39;s good!</span>
<span class="kd">end</span>


<span class="c1">-- append: the list analog of natural number addition</span>
<span class="c1">-- please do compare/contrast list.append and nat.add</span>
<span class="kd">def</span> <span class="n">appnd</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">m</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="n">m</span> <span class="o">:=</span> <span class="n">h</span><span class="o">::</span><span class="n">appnd</span> <span class="n">t</span> <span class="n">m</span>

<span class="k">#eval</span> <span class="n">appnd</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
</section>
<section id="higher-order-functions">
<h2><span class="section-number">4.4. </span>Higher-Order Functions<a class="headerlink" href="#higher-order-functions" title="Permalink to this heading">&#61633;</a></h2>
<p>A higher-order function is simply a function that
takes functions as arguments and/or that returns a
function as a result.</p>
<section id="in-logic">
<h3><span class="section-number">4.4.1. </span>In Logic<a class="headerlink" href="#in-logic" title="Permalink to this heading">&#61633;</a></h3>
<p>We&#8217;ve already seen this idea in logical reasoning,
where function values are proofs of implications.
In this chapter, we&#8217;ll see that same idea in the
realm of computation.</p>
<p>Let&#8217;s start by reviewing a logical example to
refresh memories. We&#8217;ll review the proof that
<em>implication is transitive</em>: if the truth of some
proposition, P, implies the truth of Q, and if the
truth of Q implies the truth of R, then the truth
of P implies that of R. Thinking computationally,
if we have a function, pq, that converts any proof
of P into a proof of Q (a proof of P &#8594; Q), and a
function, qr, that converts any proof of Q into a
proof of R (a proof of Q &#8594; R), then we can build
a function, pr, that converts any proof, p, of P,
into a proof of R (the desired proof of P &#8594; R) by
applying the proof of P &#8594; Q to p to get a proof of
Q, and by then applying the proof of Q &#8594; R to that
value to get a proof of R. Here it is formally.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%7BP%20Q%20R%20%3A%20Prop%7D%20%3A%20(P%20%E2%86%92%20Q)%20%E2%86%92%20(Q%20%E2%86%92%20R)%20%E2%86%92%20(P%20%E2%86%92%20R)%20%3A%3D%0Abegin%0Aassume%20pq%20qr%2C%20%20%20--%20assume%20P%20%E2%86%92%20Q%20and%20Q%20%E2%86%92%20R%0Aassume%20p%2C%20%20%20%20%20%20%20--%20to%20show%20P%20%E2%86%92%20R%2C%20assume%20p%20a%20proof%20of%20P%0Aexact%20qr%20(pq%20p)%20--%20and%20derive%20the%20desired%20proof%20of%20R%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_33.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">Q</span> <span class="bp">&#8594;</span> <span class="n">R</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">R</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">pq</span> <span class="n">qr</span><span class="o">,</span>   <span class="c1">-- assume P &#8594; Q and Q &#8594; R</span>
<span class="k">assume</span> <span class="n">p</span><span class="o">,</span>       <span class="c1">-- to show P &#8594; R, assume p a proof of P</span>
<span class="n">exact</span> <span class="n">qr</span> <span class="o">(</span><span class="n">pq</span> <span class="n">p</span><span class="o">)</span> <span class="c1">-- and derive the desired proof of R</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This proof is a higher-order function, albeit in the
realm of logic not computation with ordinary data. It
takes two function arguments (one proving of P &#8594; Q and
the second proving Q &#8594; R) and returns a function that,
by converting any proof of P into a proof of R, proves
P &#8594; R. Therefore, (P &#8594; Q) &#8594; (Q &#8594; R) &#8594; (P &#8594; R). That is,
<em>implication is transitive</em>.</p>
</section>
<section id="composition">
<h3><span class="section-number">4.4.2. </span>Composition<a class="headerlink" href="#composition" title="Permalink to this heading">&#61633;</a></h3>
<p>What do we get when we construct the same argument not
for proofs of logical propositions but for functions on
ordinary data? What we get is a higher-order function
that performs <em>function composition</em>. Note the change
from Prop (logic) to Type (computation) in the following
definition.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%3A%20Type%7D%20%3A%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%E2%86%92%20(%CE%B2%20%E2%86%92%20%CE%B3)%20%E2%86%92%20(%CE%B1%20%E2%86%92%20%CE%B3)%20%3A%3D%0Abegin%0Aassume%20%CE%B1%CE%B2%20%CE%B2%CE%B3%2C%20%20%20--%20assume%20f%20g%0Aassume%20a%20%3A%20%CE%B1%2C%20%20%20--%20assume%20a%0Aexact%20%CE%B2%CE%B3%20(%CE%B1%CE%B2%20a)%20--%20return%20%CE%BB%20a%2C%20g%20(f%20a)%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_60.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">&#945;&#946;</span> <span class="n">&#946;&#947;</span><span class="o">,</span>   <span class="c1">-- assume f g</span>
<span class="k">assume</span> <span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">,</span>   <span class="c1">-- assume a</span>
<span class="n">exact</span> <span class="n">&#946;&#947;</span> <span class="o">(</span><span class="n">&#945;&#946;</span> <span class="n">a</span><span class="o">)</span> <span class="c1">-- return &#955; a, g (f a)</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Compare and contrast this definition with the statement
and proof of the transitivity of implication. See that
you&#8217;ve already been using higher-order functions albeit
to reason with functions that serve as proofs of logical
implications, rather than with with functions on ordinary
data.</p>
<p>Let&#8217;s write this definition a little more naturally,
and give it a name: <em>comp</em>, short for  <em>composition</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20comp%20%7B%CE%B1%20%CE%B2%20%CE%B3%20%3A%20Type%7D%20(f%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2)%20(g%20%3A%20%CE%B2%20%E2%86%92%20%CE%B3)%20%3A%20%CE%B1%20%E2%86%92%20%CE%B3%20%3A%3D%0Afun%20(a%20%3A%20%CE%B1)%2C%20g%20(f%20a)" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_79.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">)</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span> <span class="o">:=</span>
<span class="k">fun</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">),</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span>
</pre></div>
</div>
</div><section id="example">
<h4><span class="section-number">4.4.2.1. </span>Example<a class="headerlink" href="#example" title="Permalink to this heading">&#61633;</a></h4>
<p>Let&#8217;s see an example. Suppose we have two functions, <em>inc</em>
that increments a natural number and sqr that squares one.
We can form a function that first increments then squares
its argument by <em>composing</em> these two functions.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20inc%20(n%20%3A%20%E2%84%95)%20%3A%3D%20n%20%2B%201%0Adef%20sqr%20(n%20%3A%20%E2%84%95)%20%3A%3D%20n%20*%20n%0Adef%20inc_then_sqr%20%3A%3D%20comp%20inc%20sqr%0Aexample%20%3A%20inc_then_sqr%205%20%3D%2036%20%3A%3D%20rfl%20%20%20--%20seems%20to%20work!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_93.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">inc</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>
<span class="kd">def</span> <span class="n">sqr</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">n</span>
<span class="kd">def</span> <span class="n">inc_then_sqr</span> <span class="o">:=</span> <span class="n">comp</span> <span class="n">inc</span> <span class="n">sqr</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">inc_then_sqr</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">36</span> <span class="o">:=</span> <span class="n">rfl</span>   <span class="c1">-- seems to work!</span>
</pre></div>
</div>
</div></section>
<section id="notation">
<h4><span class="section-number">4.4.2.2. </span>Notation<a class="headerlink" href="#notation" title="Permalink to this heading">&#61633;</a></h4>
<p>Lean defines the infix operator &#8728; as notation for function
composition. Note that the order of the function arguments
is reversed. (g &#8728; f) is the function that applies g after
applying f to its argument. That is, (g &#8728; f) x = g (f x).
We pronounce the function, (g &#8728; f), as <em>g after f.</em></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20inc_then_sqr'%20%3A%3D%20sqr%20%E2%88%98%20inc%20%20%20%20%20%20%20%20--%20composition!%0Aexample%20%3A%20inc_then_sqr'%205%20%3D%2036%20%3A%3D%20rfl%20--%20seems%20to%20work!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_110.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">inc_then_sqr&#39;</span> <span class="o">:=</span> <span class="n">sqr</span> <span class="bp">&#8728;</span> <span class="n">inc</span>        <span class="c1">-- composition!</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">inc_then_sqr&#39;</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">36</span> <span class="o">:=</span> <span class="n">rfl</span> <span class="c1">-- seems to work!</span>
</pre></div>
</div>
</div></section>
<section id="example-with-two-types">
<h4><span class="section-number">4.4.2.3. </span>Example With Two Types<a class="headerlink" href="#example-with-two-types" title="Permalink to this heading">&#61633;</a></h4>
<p>In this example, given functions that compute the length
of a list and decrement a natural number, we construct a
function that takes a list of objects and returns one less
than its length. We first illustrate applications of Lean
functions for length and decrement and then use both our
notation and the Lean &#8728; notation to construct the desired
function, which we apply to the list [1,2,3] yielding the
value, 2.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23eval%20list.length%20%5B1%2C2%2C3%5D%20--%20apply%20length%20function%20to%20list%0A%23eval%20%5B1%2C2%2C3%5D.length%20%20%20%20%20%20--%20function%20application%20notation%0A%23eval%20nat.pred%203%20%20%20%20%20%20%20%20%20%20--%20apply%20decrement%20function%20to%203%0A%0A--%20Apply%20composition%20of%20length%20and%20pred%20to%20list%0A%23eval%20(comp%20list.length%20nat.pred)%20%5B1%2C2%2C3%5D%0A%23eval%20(nat.pred%20%E2%88%98%20list.length)%20%5B1%2C2%2C3%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_128.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">list.length</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="c1">-- apply length function to list</span>
<span class="k">#eval</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">length</span>      <span class="c1">-- function application notation</span>
<span class="k">#eval</span> <span class="n">nat.pred</span> <span class="mi">3</span>          <span class="c1">-- apply decrement function to 3</span>

<span class="c1">-- Apply composition of length and pred to list</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">comp</span> <span class="n">list.length</span> <span class="n">nat.pred</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="k">#eval</span> <span class="o">(</span><span class="n">nat.pred</span> <span class="bp">&#8728;</span> <span class="n">list.length</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
</pre></div>
</div>
</div><p>The infix notation is best. Think of the argument, here the
list [1,2,3], as moving left through list.length, yielding 3,
which then moves left through nat.pred, finally yielding 2.</p>
</section>
</section>
<section id="map">
<h3><span class="section-number">4.4.3. </span>Map<a class="headerlink" href="#map" title="Permalink to this heading">&#61633;</a></h3>
<p>In this section, we introduce the <em>map</em> function on lists.
It takes (1) a function that takes objects of some type
&#945; and converts them into objects of some type &#946;, and (2) a
list of objects of type &#945;, and returns a list of objects
of type &#946;, obtained by using the function to turn each each
&#945; object in the given list into a corresponding &#946; object
in the resulting list.</p>
<p>We build to a general definition of map starting with a
special case: of a function that takes a list of natural
numbers and returns a list in which each is increased by
one, by the application of <em>inc</em>, our increment function.</p>
<p>We define a function that &#8220;maps&#8221; the increment function
over a given list of natural numbers by case analysis on
any given list. If the given list is nil, we return nil;
otherwise, if the list is (h::t) we return the list with
the value of (inc h) at its head and the list obtained
by similarly incrementing each value in the tail of the
given list as its tail.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20inc_list_nat%20%3A%20list%20nat%20%E2%86%92%20list%20nat%0A%7C%20list.nil%20%3A%3D%20list.nil%0A%7C%20(h%3A%3At)%20%3A%3D%20(inc%20h)%3A%3Ainc_list_nat%20t%0A%0A--%20it%20works%0A%23eval%20inc_list_nat%5B%5D%20%20%20%20%20%20%20%20--%20expect%20%5B%5D%0A%23eval%20inc_list_nat%20%5B1%2C2%2C3%5D%20%20--%20expect%20%5B2%2C3%2C4%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_166.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">inc_list_nat</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">inc</span> <span class="n">h</span><span class="o">)::</span><span class="n">inc_list_nat</span> <span class="n">t</span>

<span class="c1">-- it works</span>
<span class="k">#eval</span> <span class="n">inc_list_nat</span><span class="o">[]</span>        <span class="c1">-- expect []</span>
<span class="k">#eval</span> <span class="n">inc_list_nat</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>  <span class="c1">-- expect [2,3,4]</span>
</pre></div>
</div>
</div><p>Suppose that instead of incrementing each element
of a given list to obtain a new list, we want to
square each element. One way to do it is to clone
the function above and replace inc with sqr.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20sqr_list_nat%20%3A%20list%20nat%20%E2%86%92%20list%20nat%0A%7C%20list.nil%20%3A%3D%20list.nil%0A%7C%20(h%3A%3At)%20%3A%3D%20(sqr%20h)%3A%3Asqr_list_nat%20t%0A%0A--%20It%20works%0A%23eval%20sqr_list_nat%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_182.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">sqr_list_nat</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">sqr</span> <span class="n">h</span><span class="o">)::</span><span class="n">sqr_list_nat</span> <span class="n">t</span>

<span class="c1">-- It works</span>
<span class="k">#eval</span> <span class="n">sqr_list_nat</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div><p>Clearly we can clone and edit the preceding code
to produce a version that applies <em>any</em> function of
type nat &#8594; nat, instead of inc or sqr, to the head
of the given list, with all of the remaining code
unchanged, to map given lists of natural numbers
to new lists by replacement of existing elements
with new elements computed by application of the
given function.</p>
<p>That all the code remains the same but for the
<em>element</em> converting function suggests that we
can instead <em>generalize</em> by making this function
a <em>parameter</em> of the otherwise unchanging code.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20any_list_nat%20%3A%20(nat%20%E2%86%92%20nat)%20%E2%86%92%20list%20nat%20%E2%86%92%20list%20nat%0A%7C%20f%20list.nil%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%3A%3D%20f%20h%3A%3Aany_list_nat%20f%20t%0A%0A--%20It%20seems%20to%20work!%0Aexample%20%3A%20any_list_nat%20sqr%20%5B1%2C2%2C3%2C4%2C5%5D%20%3D%20%5B1%2C4%2C9%2C16%2C25%5D%20%3A%3D%20rfl%0Aexample%20%3A%20any_list_nat%20inc%20%5B1%2C2%2C3%2C4%2C5%5D%20%3D%20%5B2%2C3%2C4%2C5%2C6%5D%20%3A%3D%20rfl%0Aexample%20%3A%20any_list_nat%20nat.pred%20%5B1%2C2%2C3%2C4%2C5%5D%20%3D%20%5B0%2C1%2C2%2C3%2C4%5D%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_205.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">any_list_nat</span> <span class="o">:</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">h</span><span class="o">::</span><span class="n">any_list_nat</span> <span class="n">f</span> <span class="n">t</span>

<span class="c1">-- It seems to work!</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">any_list_nat</span> <span class="n">sqr</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">25</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">any_list_nat</span> <span class="n">inc</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">any_list_nat</span> <span class="n">nat.pred</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>We&#8217;ve generalized the nat &#8594; nat function, but suppose we wanted
to convert a list of <em>strings</em> to a list of their natural number
lengths. We don&#8217;t have the machinery to do that yet, as we can
only map functions over lists of natural numbers. Otherwise we
get a type error.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23eval%20any_list_nat%20string.length%20%5B%22I%22%2C%20%22Love%22%2C%20%22Math%22%5D%20%20--%20nope!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_222.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">any_list_nat</span> <span class="n">string.length</span> <span class="o">[</span><span class="s2">&quot;I&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;Math&quot;</span><span class="o">]</span>  <span class="c1">-- nope!</span>
</pre></div>
</div>
</div><p>One solution is simply to write a new version of our mapping
function specialized to map lists of strings to lists of nat
values, using any given string &#8594; nat function to perform the
element-wise mapping.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20xyz_list_nat%20%3A%20(string%20%E2%86%92%20nat)%20%E2%86%92%20list%20string%20%E2%86%92%20list%20nat%0A%7C%20f%20list.nil%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%3A%3D%20f%20h%3A%3Axyz_list_nat%20f%20t%0A%0A--%20It%20seems%20to%20work%0A%23eval%20xyz_list_nat%20string.length%20%5B%22I%22%2C%20%22Love%22%2C%20%22Math%22%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_231.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">xyz_list_nat</span> <span class="o">:</span> <span class="o">(</span><span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">h</span><span class="o">::</span><span class="n">xyz_list_nat</span> <span class="n">f</span> <span class="n">t</span>

<span class="c1">-- It seems to work</span>
<span class="k">#eval</span> <span class="n">xyz_list_nat</span> <span class="n">string.length</span> <span class="o">[</span><span class="s2">&quot;I&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;Math&quot;</span><span class="o">]</span>
</pre></div>
</div>
</div><p>But we run into the same problem as before if we now want
to map lists of strings to Boolean values, e.g., reflecting
whether the length of each string is even (tt) or not (ff).
Cloning code and editing it to produce another special case
is really not the best solution.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20map_string_bool%20%3A%20(string%20%E2%86%92%20bool)%20%E2%86%92%20list%20string%20%E2%86%92%20list%20bool%0A%7C%20f%20list.nil%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%3A%3D%20f%20h%3A%3Amap_string_bool%20f%20t%0A%0A--%20is_even%20takes%20a%20nat%20and%20return%20tt%20if%20it's%20even%20else%20ff%0Adef%20is_even%20(n%20%3A%20nat)%20%3A%20bool%20%3A%3D%20n%20%25%202%20%3D%200%0A%23eval%20is_even%202%0A%23eval%20is_even%203" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_246.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">map_string_bool</span> <span class="o">:</span> <span class="o">(</span><span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">bool</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">string</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">h</span><span class="o">::</span><span class="n">map_string_bool</span> <span class="n">f</span> <span class="n">t</span>

<span class="c1">-- is_even takes a nat and return tt if it&#39;s even else ff</span>
<span class="kd">def</span> <span class="n">is_even</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="k">#eval</span> <span class="n">is_even</span> <span class="mi">2</span>
<span class="k">#eval</span> <span class="n">is_even</span> <span class="mi">3</span>
</pre></div>
</div>
</div><p>Now we can map a function that tells whether a given string
is of even length or not over any given list of strings to
get a corresponding list of tt/ff values.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20is_even_length%20%3A%3D%20is_even%20%E2%88%98%20string.length%0A%23eval%20map_string_bool%20is_even_length%20%5B%22I%22%2C%20%22Love%22%2C%20%22Math%22%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_261.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">is_even_length</span> <span class="o">:=</span> <span class="n">is_even</span> <span class="bp">&#8728;</span> <span class="n">string.length</span>
<span class="k">#eval</span> <span class="n">map_string_bool</span> <span class="n">is_even_length</span> <span class="o">[</span><span class="s2">&quot;I&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;Math&quot;</span><span class="o">]</span>
</pre></div>
</div>
</div><p>Of course well run into exactly the same sort of problem,
of having to engage in error-prone cloning and editing of
code, if we want to now map lists of Boolean values to lists
of strings (e.g., mapping each tt to &#8220;T&#8221; and each ff to &#8220;F&#8221;).</p>
<p>And you can imagine many other examples: mapping lists of
employees to list of their corresponding salaries, or mapping
lists of Boolean values to lists of their negations, etc. The
possibilities are endless.</p>
<p>The answer should now we pretty clear: we need to further
generalize: not only over the function to apply to map each
list element, but also over the the types of element in the
input and output lists! Here, then, is a greatly generalized
version.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20map_list%20%7B%CE%B1%20%CE%B2%20%3A%20Type%7D%20%3A%20(%CE%B1%20%E2%86%92%20%CE%B2)%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B2%0A%7C%20f%20list.nil%20%3A%3D%20list.nil%0A%7C%20f%20(h%3A%3At)%20%3A%3D%20f%20h%20%3A%3A%20map_list%20f%20t%0A%0A--%20It%20seems%20to%20work!%0A%23eval%20map_list%20nat.succ%20%5B1%2C2%2C3%5D%0A%23eval%20map_list%20is_even_length%20%5B%22I%22%2C%20%22Love%22%2C%20%22Math%22%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_282.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">map_list</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#946;</span>
<span class="bp">|</span> <span class="n">f</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">list.nil</span>
<span class="bp">|</span> <span class="n">f</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">f</span> <span class="n">h</span> <span class="o">::</span> <span class="n">map_list</span> <span class="n">f</span> <span class="n">t</span>

<span class="c1">-- It seems to work!</span>
<span class="k">#eval</span> <span class="n">map_list</span> <span class="n">nat.succ</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">map_list</span> <span class="n">is_even_length</span> <span class="o">[</span><span class="s2">&quot;I&quot;</span><span class="o">,</span> <span class="s2">&quot;Love&quot;</span><span class="o">,</span> <span class="s2">&quot;Math&quot;</span><span class="o">]</span>
</pre></div>
</div>
</div><p>For now, we&#8217;ll be satisfied with this level of generality.
We will just observe that our mapping function still only
works for <em>lists</em> as element containers. What if you wanted
to map functions over other kinds of element &#8220;containers,&#8221;
e.g., to turn values of type <em>option &#945;</em> into <em>option &#946;s</em>?
Or trees of &#945; values into corresponding trees of &#946; values?</p>
<p>The key roadblock will be that there&#8217;s no way to do this
using exactly the same code for, say, lists and options.
So the kind of parametric polymorphism we&#8217;ve been using
will no longer be enough. The answer will be found in a
different kind of polymorphism, <em>ad hoc</em> polynorphism, of
which <em>operator overloading</em> (as in C++) is an example.
For instance, you can write complex number and string
classes and overload the + operator in each class to do
respective complex number addition and string append, but
the implementations of these operations will hardly share
the same code. Completely different implementations will
be needed, to be selected (by the compler in C++) based
on the types of the arguments to which the + operator is
applied.  More on this topic later.</p>
</section>
<section id="fold-list">
<h3><span class="section-number">4.4.4. </span>Fold list: &#945; &#8594; &#945; &#8594; &#945;<a class="headerlink" href="#fold-list" title="Permalink to this heading">&#61633;</a></h3>
<p>We now turn to a very different higher-order function
appliable to lists. It&#8217;s called <em>fold</em> (or event better,
<em>fold_right</em>) or <em>reduce</em>.</p>
<section id="overview">
<h4><span class="section-number">4.4.4.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">&#61633;</a></h4>
<p>The fundamental purpose of this operation is to turn a
<em>binary</em> operation on the values of any given type (e.g.,
nat) into an operation that can be applied to <em>any</em> number
of arguments, where the arguments are packaged into a list
data structure.</p>
<p>The way the generalized version of the binary operation
works is that for the empty list it returns a base value,
and for a non-empty list, <em>h::t</em>, it applies the binary
operation to <em>h</em> and <em>to the result of applying the n-ary
version to the rest of the list, *t</em>.</p>
<p>As an example, fold will turn the addition function on
natural numbers (nat.add) into an operation that can be
applied to a list of any number of natural number values
to compute the sum of them all. Here, for example, is
such a program.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20reduce_sum%20%3A%20list%20nat%20%E2%86%92%20nat%0A%7C%20list.nil%20%3A%3D%200%0A%7C%20(h%3A%3At)%20%3A%3D%20nat.add%20h%20(reduce_sum%20t)%0A%0A%23eval%20reduce_sum%20%5B%5D%20%20%20%20%20%20%20%20%20%20%20--%20sum%20of%20zero%20arguments%0A%23eval%20reduce_sum%20%5B5%5D%20%20%20%20%20%20%20%20%20%20--%20sum%20of%20one%20argument%0A%23eval%20reduce_sum%20%5B5%2C4%5D%20%20%20%20%20%20%20%20--%20sum%20of%20two%20arguments%0A%23eval%20reduce_sum%20%5B5%2C4%2C3%2C2%2C1%5D%20%20--%20sum%20of%20five%20arguments" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_342.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">reduce_sum</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.add</span> <span class="n">h</span> <span class="o">(</span><span class="n">reduce_sum</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">reduce_sum</span> <span class="o">[]</span>           <span class="c1">-- sum of zero arguments</span>
<span class="k">#eval</span> <span class="n">reduce_sum</span> <span class="o">[</span><span class="mi">5</span><span class="o">]</span>          <span class="c1">-- sum of one argument</span>
<span class="k">#eval</span> <span class="n">reduce_sum</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>        <span class="c1">-- sum of two arguments</span>
<span class="k">#eval</span> <span class="n">reduce_sum</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>  <span class="c1">-- sum of five arguments</span>
</pre></div>
</div>
</div></section>
<section id="generalizing-the-binary-operation">
<h4><span class="section-number">4.4.4.2. </span>Generalizing the binary operation<a class="headerlink" href="#generalizing-the-binary-operation" title="Permalink to this heading">&#61633;</a></h4>
<p>It should be clear that we will want to generalize
the binary operator from nat.add to <em>any</em> binary
operation on natural numbers. For example, we might
want a function that implements n-ary multiplication,
reducing any list of natural numbers to the product
of all the numbers in the list.</p>
<p>This is a little bit tricker than one might guess.
To see the problem, let&#8217;s clone and edit the code
we&#8217;ve got, substituting multiplication for addition,
in an attempt to implement n-ary multiplication.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20reduce_prod'%20%3A%20list%20nat%20%E2%86%92%20nat%0A%7C%20list.nil%20%3A%3D%200%0A%7C%20(h%3A%3At)%20%3A%3D%20nat.mul%20h%20(reduce_prod'%20t)%0A%0A%23eval%20reduce_prod'%20%5B3%2C2%2C1%5D%20%20%20--%20expect%206%20got%200!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_369.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">reduce_prod&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.mul</span> <span class="n">h</span> <span class="o">(</span><span class="n">reduce_prod&#39;</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">reduce_prod&#39;</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>   <span class="c1">-- expect 6 got 0!</span>
</pre></div>
</div>
</div></section>
<section id="operator-identity-inconsistency">
<h4><span class="section-number">4.4.4.3. </span>Operator-identity inconsistency<a class="headerlink" href="#operator-identity-inconsistency" title="Permalink to this heading">&#61633;</a></h4>
<p>To see what goes wrong, let&#8217;s unroll the recursion:</p>
<ul class="simple">
<li><p>reduce_prod&#8217; [3,2,1] =</p></li>
<li><p>mul 3 (reduce_prod&#8217; [2,1]) =</p></li>
<li><p>mul 3 (mul 2 (reduce_prod&#8217; [1])) =</p></li>
<li><p>mul 3 (mul 2 (mul 1 (reduce_prod&#8217; []))) =</p></li>
<li><p>mul 3 (mul 2 (mul 1 0)) = 0!</p></li>
</ul>
<p>The problem is now clear, and so is the solution:
we need to return a different value for the base
case of an empty list when the binary operation is
multiplication rather than addition. Specifically,
we need to return 1 rather than zero. You can now
probably guess that in general we want to return
the <em>identity, or neutral, value</em> for whatever
the binary operator is for the base case. Here
we want to return 1.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20reduce_prod%20%3A%20list%20nat%20%E2%86%92%20nat%0A%7C%20list.nil%20%3A%3D%201%0A%7C%20(h%3A%3At)%20%3A%3D%20nat.mul%20h%20(reduce_prod%20t)%0A%0A%23eval%20reduce_prod%20%5B%5D%20%20%20%20%20%20%20%20%20%20--%20expect%201%0A%23eval%20reduce_prod%20%5B5%2C4%2C3%2C2%2C1%5D%20--%20expect%20120" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_399.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">reduce_prod</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">nat.mul</span> <span class="n">h</span> <span class="o">(</span><span class="n">reduce_prod</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#eval</span> <span class="n">reduce_prod</span> <span class="o">[]</span>          <span class="c1">-- expect 1</span>
<span class="k">#eval</span> <span class="n">reduce_prod</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="c1">-- expect 120</span>
</pre></div>
</div>
</div><p>So now we can correctly generalize fold_nat over
binary operators by making the operator a parameter
but by also adding as a second parameter the right
identity element for whatever operator we provide
as an actual parameter.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20fold_nat%20(op%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat)%3A%20%20nat%20%E2%86%92%20list%20nat%20%E2%86%92%20nat%0A%7C%20id%20list.nil%20%3A%3D%20id%0A%7C%20id%20(h%3A%3At)%20%3A%3D%20op%20h%20(fold_nat%20id%20t)%0A%0A%0A--%20It%20seems%20to%20work!%0A%23eval%20fold_nat%20nat.add%200%20%5B1%2C2%2C3%2C4%2C5%5D%20%20--%20expect%2015%0A%23eval%20fold_nat%20nat.mul%201%20%5B1%2C2%2C3%2C4%2C5%5D%20%20--%20expect%20120" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_414.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">fold_nat</span> <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="o">):</span>  <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">id</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="n">id</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">op</span> <span class="n">h</span> <span class="o">(</span><span class="n">fold_nat</span> <span class="n">id</span> <span class="n">t</span><span class="o">)</span>


<span class="c1">-- It seems to work!</span>
<span class="k">#eval</span> <span class="n">fold_nat</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>  <span class="c1">-- expect 15</span>
<span class="k">#eval</span> <span class="n">fold_nat</span> <span class="n">nat.mul</span> <span class="mi">1</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>  <span class="c1">-- expect 120</span>
</pre></div>
</div>
</div></section>
<section id="enforcing-op-id-consistency">
<h4><span class="section-number">4.4.4.4. </span>Enforcing op-id consistency<a class="headerlink" href="#enforcing-op-id-consistency" title="Permalink to this heading">&#61633;</a></h4>
<p>Yet a problem remains. There is nothing in our
solution that prevents us from passing the wrong
value for the identity element for the given binary
operator. The following function application runs
without any errors being reported but it gives the
wrong answer, because we pass the wrong identity
element for nat.mul.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23eval%20fold_nat%20nat.mul%200%20%5B1%2C2%2C3%5D%20%20--%20oops%2C%20wrong" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_437.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#eval</span> <span class="n">fold_nat</span> <span class="n">nat.mul</span> <span class="mi">0</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>  <span class="c1">-- oops, wrong</span>
</pre></div>
</div>
</div><p>We finish this section with a step toward our
ultimate solution: we will now construct a version
of fold_nat (fold_nat&#8217;) that <em>enforces consistency</em>
between the binary function and identity element
arguments by requiring, as an additional argument,
a proof that the putative identity element really
is one!</p>
<p>In particular, we&#8217;ll be satisfied for now to prove
that the given &#8220;identity&#8221; element really is a <em>right</em>
identity.  That is, we want to prove that for any n,
op n id (with id on the right) is equal to n. That is,
we&#8217;ll require a proof of <em>&#8704; (n : nat), op n id = n</em> as
an argument to our function.</p>
<p>This is not our complete solution to the problem of
enforcing operator-identity consistency, but we&#8217;ll
have to wait until after the next chapter to get to
that point.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20fold_nat'%0A%20%20(op%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat)%0A%20%20(id%20%3Anat)%0A%20%20(right_id%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20op%20n%20id%20%3D%20n)%20%3A%0A%20%20list%20nat%20%E2%86%92%20nat%0A%7C%20list.nil%20%3A%3D%20id%0A%7C%20(h%3A%3At)%20%3A%3D%20op%20h%20(fold_nat'%20t)" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_461.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">fold_nat&#39;</span>
  <span class="o">(</span><span class="n">op</span><span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span><span class="o">)</span>
  <span class="o">(</span><span class="n">id</span> <span class="o">:</span><span class="n">nat</span><span class="o">)</span>
  <span class="o">(</span><span class="n">right_id</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">op</span> <span class="n">n</span> <span class="n">id</span> <span class="bp">=</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">op</span> <span class="n">h</span> <span class="o">(</span><span class="n">fold_nat&#39;</span> <span class="n">t</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Let&#8217;s construct named proofs that 0 is an identity
when it appears as the second argument to nat.add.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20zero_right_id_add%20%3A%20%E2%88%80%20(n%20%3A%20nat)%2C%20nat.add%20n%200%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Asimp%20%5Bnat.add%5D%0Aend%0A%0A--%20Now%20we%20can%20safely%20use%20fold_nat'%0A%23eval%20fold_nat'%20nat.add%200%20zero_right_id_add%20%5B1%2C2%2C3%5D%20--%20good%0A%23eval%20fold_nat'%20nat.add%201%20zero_right_id_add%20%5B1%2C2%2C3%5D%20--%20not%20good" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_474.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">zero_right_id_add</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">),</span> <span class="n">nat.add</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">]</span>
<span class="kd">end</span>

<span class="c1">-- Now we can safely use fold_nat&#39;</span>
<span class="k">#eval</span> <span class="n">fold_nat&#39;</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="n">zero_right_id_add</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="c1">-- good</span>
<span class="k">#eval</span> <span class="n">fold_nat&#39;</span> <span class="n">nat.add</span> <span class="mi">1</span> <span class="n">zero_right_id_add</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="c1">-- not good</span>
</pre></div>
</div>
</div></section>
<section id="from-binary-to-n-ary-operations">
<h4><span class="section-number">4.4.4.5. </span>From binary to n-ary operations<a class="headerlink" href="#from-binary-to-n-ary-operations" title="Permalink to this heading">&#61633;</a></h4>
<p>We now circle back to the notion that
fold generalizes any given binary operator to an n-ary
operator applicable to any number of arguments as long
as they&#8217;re arranged in a list. You can see this idea
in action by just partially applying fold_nat&#8217; to a
binary operator, it&#8217;s identity, and the required proof,
leaving the list argument TBD.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20n_ary_add%20%3A%3D%20fold_nat'%20nat.add%200%20zero_right_id_add%0A%0A--%20It%20seems%20to%20work!%0A%23eval%20n_ary_add%20%5B%5D%20%20%20%20%20%20%20%20%20%20%20%20--%20zero%20arguments%0A%23eval%20n_ary_add%20%5B5%5D%20%20%20%20%20%20%20%20%20%20%20--%20one%20argument%0A%23eval%20n_ary_add%20%5B4%2C5%5D%20%20%20%20%20%20%20%20%20--%20two%20arguments%0A%23eval%20n_ary_add%20%5B1%2C2%2C3%2C4%2C5%5D%20%20%20--%20five%20arguments%2C%20etc!" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_498.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">n_ary_add</span> <span class="o">:=</span> <span class="n">fold_nat&#39;</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="n">zero_right_id_add</span>

<span class="c1">-- It seems to work!</span>
<span class="k">#eval</span> <span class="n">n_ary_add</span> <span class="o">[]</span>            <span class="c1">-- zero arguments</span>
<span class="k">#eval</span> <span class="n">n_ary_add</span> <span class="o">[</span><span class="mi">5</span><span class="o">]</span>           <span class="c1">-- one argument</span>
<span class="k">#eval</span> <span class="n">n_ary_add</span> <span class="o">[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>         <span class="c1">-- two arguments</span>
<span class="k">#eval</span> <span class="n">n_ary_add</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>   <span class="c1">-- five arguments, etc!</span>
</pre></div>
</div>
</div><p>Soon we&#8217;ll be able similarly to turn binary multiplication
into n-ary multiplication, with a definitions like this:
<em>def n_ary_mul := fold_nat&#8217; nat.mul 1 one_right_id_mul</em>. The
problem is we don&#8217;t yet have the machinery (namely proof by
induction) to construct the proof that 1 is a right identity
for nat.mul. That&#8217;ll come soon enough. For now, we can stub
it out and get something that works but without a proof that
1 is a right identity for natural number multiplication.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20n_ary_mul%20%3A%3D%20fold_nat'%20nat.mul%201%20sorry%0A%23eval%20n_ary_mul%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_518.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">n_ary_mul</span> <span class="o">:=</span> <span class="n">fold_nat&#39;</span> <span class="n">nat.mul</span> <span class="mi">1</span> <span class="gr">sorry</span>
<span class="k">#eval</span> <span class="n">n_ary_mul</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div><p>It&#8217;s a good time for a few exercises to prepare for the rest
of what&#8217;s to come.</p>
</section>
</section>
<section id="id4">
<h3><span class="section-number">4.4.5. </span>Exercises<a class="headerlink" href="#id4" title="Permalink to this heading">&#61633;</a></h3>
<p>1. Write a function, n_ary_append (without using fold) that
takes a list of lists of objects of some type, &#945; (the type will
be <em>list (list &#945;)</em>) and that reduces it to a single list of &#945;
using <em>list.append</em> as a binary operation. For example, it&#8217;d
turn this list, [[1,2],[3,4],[5]] into the list [1,2,3,4,5].
You may use Lean&#8217;s list.append function as a binary operator
that combines two lists into one.</p>
<p>2. Write a function (without using fold) that takes a a list
of lists of &#945; and that returns the sum of the lengths of the
contained lists. For example applying your function to the
list, [[],[1,2,3],[1,2,3,4,5]], should return 8: the sum of
0 for the first list, 3 for the second, and 5 for the third.
Your function will work by adding the length of the head of
the list of lists to the result of recursively reducing the
<em>rest</em> (tail) of the list of lists. You may use list.length
to compute the length of any list.</p>
<p>3. Write a function without using fold that takes a list of
lists of &#945; and that returns true if the length of each of
the elements lists is even and false otherwise.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20Problem%20%231%0A%2F-%0ALet's%20do%20some%20test-driven%20development%20here.%0A(1)%20Define%20function%20type%0A(2)%20Write%20(initially%20failing)%20test%20cases%0A(3)%20Complete%20implementation%20and%20expect%20test%20cases%20to%20pass%0A-%2F%0Adef%20n_ary_append%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20list%20(list%20%CE%B1)%20%E2%86%92%20list%20%CE%B1%0A%7C%20%5B%5D%20%3A%3D%20%5B%5D%0A%7C%20(h%3A%3At)%20%3A%3D%20h%20%2B%2B%20n_ary_append%20t%0A%0A%0A--%20test%20cases%20for%200%2C%201%2C%202%2C%20and%20more%20arguments%0Aexample%20%3A%20%40n_ary_append%20nat%20%5B%5D%20%3D%20%5B%5D%20%3A%3D%20rfl%0Aexample%20%3A%20n_ary_append%20%5B%5B1%2C2%2C3%5D%5D%20%3D%20%5B1%2C2%2C3%5D%20%3A%3D%20rfl%0Aexample%20%3A%20n_ary_append%20%5B%5B1%2C2%2C3%5D%2C%5B4%2C5%2C6%5D%5D%20%3D%20%5B1%2C2%2C3%2C4%2C5%2C6%5D%20%3A%3D%20rfl%0Aexample%20%3A%20n_ary_append%20%5B%5B1%2C2%2C3%5D%2C%5B4%2C5%2C6%5D%2C%5B7%2C8%2C9%5D%5D%20%3D%20%5B1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%5D%20%3A%3D%20rfl%0A%0A--%20Problem%20%232%0Adef%20sum_lengths%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20list%20(list%20%CE%B1)%20%E2%86%92%20nat%0A%7C%20%5B%5D%20%3A%3D%200%0A%7C%20(h%3A%3At)%20%3A%3D%20(list.length%20h)%20%2B%20(sum_lengths%20t)%0A%0Aexample%20%3A%20%40sum_lengths%20nat%20%5B%5D%20%3D%200%20%3A%3D%20rfl%0Aexample%20%3A%20sum_lengths%20%5B%5B1%2C2%2C3%5D%5D%20%3D%203%20%3A%3D%20rfl%0Aexample%20%3A%20sum_lengths%20%5B%5B1%2C2%2C3%5D%2C%5B4%2C5%2C6%5D%5D%20%3D%206%20%3A%3D%20rfl%0Aexample%20%3A%20sum_lengths%20%5B%5B1%2C2%2C3%5D%2C%5B4%2C5%2C6%5D%2C%5B7%2C8%2C9%5D%5D%20%3D%209%20%3A%3D%20rfl%0A%0A--%20Problem%20%233%0Adef%20even_lengths%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20list%20(list%20%CE%B1)%20%E2%86%92%20bool%0A%7C%20%5B%5D%20%3A%3D%20tt%0A%7C%20(h%3A%3At)%20%3A%3D%20(is_even%20(list.length%20h))%20%26%26%20(even_lengths%20t)%0A%0Aexample%20%3A%20%40even_lengths%20nat%20%5B%5D%20%3D%20tt%20%3A%3D%20rfl%0Aexample%20%3A%20even_lengths%20%5B%5B1%2C2%2C3%5D%2C%5B4%2C5%2C6%5D%2C%5B7%2C8%2C9%5D%5D%20%3D%20ff%20%3A%3D%20rfl%0Aexample%20%3A%20even_lengths%20%5B%5B1%2C2%2C3%2C4%5D%2C%5B4%2C5%2C6%5D%2C%5B7%2C8%2C9%5D%5D%20%3D%20ff%20%3A%3D%20rfl%0Aexample%20%3A%20even_lengths%20%5B%5B1%2C2%2C3%2C4%5D%2C%5B4%2C5%2C6%2C7%5D%2C%5B7%2C8%2C9%2C0%5D%5D%20%3D%20tt%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_551.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Problem #1</span>
<span class="c">/-</span>
<span class="cm">Let&#39;s do some test-driven development here.</span>
<span class="cm">(1) Define function type</span>
<span class="cm">(2) Write (initially failing) test cases</span>
<span class="cm">(3) Complete implementation and expect test cases to pass</span>
<span class="cm">-/</span>
<span class="kd">def</span> <span class="n">n_ary_append</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span> <span class="bp">++</span> <span class="n">n_ary_append</span> <span class="n">t</span>


<span class="c1">-- test cases for 0, 1, 2, and more arguments</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">n_ary_append</span> <span class="n">nat</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">n_ary_append</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">n_ary_append</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">n_ary_append</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span> <span class="bp">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- Problem #2</span>
<span class="kd">def</span> <span class="n">sum_lengths</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">h</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">sum_lengths</span> <span class="n">t</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">sum_lengths</span> <span class="n">nat</span> <span class="o">[]</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">sum_lengths</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]]</span> <span class="bp">=</span> <span class="mi">3</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">sum_lengths</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">]]</span> <span class="bp">=</span> <span class="mi">6</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">sum_lengths</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span> <span class="bp">=</span> <span class="mi">9</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="c1">-- Problem #3</span>
<span class="kd">def</span> <span class="n">even_lengths</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="n">list</span> <span class="o">(</span><span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">is_even</span> <span class="o">(</span><span class="n">list.length</span> <span class="n">h</span><span class="o">))</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">even_lengths</span> <span class="n">t</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">@</span><span class="n">even_lengths</span> <span class="n">nat</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">even_lengths</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span> <span class="bp">=</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">even_lengths</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span> <span class="bp">=</span> <span class="n">ff</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">even_lengths</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">0</span><span class="o">]]</span> <span class="bp">=</span> <span class="n">tt</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div></section>
<section id="id5">
<h3><span class="section-number">4.4.6. </span>Fold list: &#945; &#8594; &#946; &#8594; &#946;<a class="headerlink" href="#id5" title="Permalink to this heading">&#61633;</a></h3>
<p>The preceding few exercises all reduce a list of objects of
one type (&#945;) to a result of another (possibly the same) type
(&#946;). For example, even_lengths reduces a list of objects of
one type, list &#945; (not the same alpha, sorry), and returns a
value of a different type, bool.</p>
<p>Can we devise a generalized version of fold that can handle
all such reductions <em>in one fell swoop</em>? The answer is yes,
but we need to think a bit harder about the nature of the
binary operation to be extended to an n-ary operation by
the application of the fold function.</p>
<p>Returning to our example, the way that the function works
when the input list isn&#8217;t empty is that it applies a binary
operation to (a) the <em>head</em> of the given list, of type &#945; ,
and (b) the <em>result</em> of folding/reducing the rest of the
list, which is of type, &#946;, yielding an overall value of the
final result type, &#946;.</p>
<section id="mixed-type-binary-operations">
<h4><span class="section-number">4.4.6.1. </span>Mixed-type binary operations<a class="headerlink" href="#mixed-type-binary-operations" title="Permalink to this heading">&#61633;</a></h4>
<p>If we think of all this work as one operation, what is its
type? Well, it&#8217;s &#945; &#8594; &#946; &#8594; &#946;. Again, for example, it would
compute a result from the head of the list (h : &#945;) and the
result of reducing the rest of the list (of type &#946;) to yield
a final result of type &#946;.</p>
<p>We can think of this as the type of binary operation that
fold is extending to an n-ary version, in general. Let&#8217;s
see this idea in action with a slightly simpler example
of a folding function: one that takes a list of nat and
that returns true if and only if all the numbers in the
list are even.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20all_even'%20%3A%20list%20%E2%84%95%20%E2%86%92%20bool%0A%7C%20list.nil%20%3A%3D%20tt%0A%7C%20(h%3A%3At)%20%3A%3D%20band%20(is_even%20h)%20(all_even'%20t)%20%20%20--%20band%20is%20%26%26%0A%0A--%20Seems%20to%20work%0A%23eval%20all_even'%20%5B2%2C4%2C6%2C8%5D%0A%23eval%20all_even'%20%5B1%2C4%2C6%2C8%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_631.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">all_even&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">band</span> <span class="o">(</span><span class="n">is_even</span> <span class="n">h</span><span class="o">)</span> <span class="o">(</span><span class="n">all_even&#39;</span> <span class="n">t</span><span class="o">)</span>   <span class="c1">-- band is &amp;&amp;</span>

<span class="c1">-- Seems to work</span>
<span class="k">#eval</span> <span class="n">all_even&#39;</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">all_even&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">8</span><span class="o">]</span>
</pre></div>
</div>
</div><p>Now we&#8217;ll apply the preceding reasoning to formulate
what&#8217;s going on in the second rule as a binary operation.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20all_even_op%20%3A%20nat%20%E2%86%92%20bool%20%E2%86%92%20bool%0A%7C%20n%20b%20%3A%3D%20(is_even%20n)%20%26%26%20b%0A%0Adef%20all_even%20%3A%20list%20nat%20%E2%86%92%20bool%0A%7C%20list.nil%20%3A%3D%20tt%0A%7C%20(h%3A%3At)%20%3A%3D%20all_even_op%20h%20(all_even%20t)%0A%0A--%20seems%20to%20be%20working%0A%23eval%20all_even%20%5B%5D%20%20%20%20%20%20%20--%20expect%20tt%0A%23eval%20all_even%20%5B1%5D%20%20%20%20%20%20--%20expect%20ff%0A%23eval%20all_even%20%5B0%2C2%2C4%5D%20%20--%20expect%20tt%0A%23eval%20all_even%20%5B0%2C2%2C5%5D%20%20--%20expect%20ff" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_644.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">all_even_op</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">bool</span> <span class="bp">&#8594;</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">n</span> <span class="n">b</span> <span class="o">:=</span> <span class="o">(</span><span class="n">is_even</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&amp;&amp;</span> <span class="n">b</span>

<span class="kd">def</span> <span class="n">all_even</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="n">list.nil</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">all_even_op</span> <span class="n">h</span> <span class="o">(</span><span class="n">all_even</span> <span class="n">t</span><span class="o">)</span>

<span class="c1">-- seems to be working</span>
<span class="k">#eval</span> <span class="n">all_even</span> <span class="o">[]</span>       <span class="c1">-- expect tt</span>
<span class="k">#eval</span> <span class="n">all_even</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span>      <span class="c1">-- expect ff</span>
<span class="k">#eval</span> <span class="n">all_even</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>  <span class="c1">-- expect tt</span>
<span class="k">#eval</span> <span class="n">all_even</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>  <span class="c1">-- expect ff</span>
</pre></div>
</div>
</div></section>
<section id="extending-such-operations">
<h4><span class="section-number">4.4.6.2. </span>Extending such operations<a class="headerlink" href="#extending-such-operations" title="Permalink to this heading">&#61633;</a></h4>
<p>Ok, so we&#8217;re finally in a position to formally specify the
type of any fold operation on lists. We&#8217;ll call it foldr,
short for &#8220;fold right,&#8221; given that we combine the head of
the list, on the left of h::t, with the result of folding
its whole <em>right</em>-hand tail, t.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20foldr%20%7B%CE%B1%20%CE%B2%20%3A%20Type%7D%20%3A%20(%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20%CE%B2)%20%E2%86%92%20%CE%B2%20%E2%86%92%20(list%20%CE%B1)%20%E2%86%92%20%CE%B2%0A%7C%20op%20id%20%5B%5D%20%3A%3D%20id%0A%7C%20op%20id%20(h%3A%3At)%20%3A%3D%20op%20h%20(foldr%20op%20id%20t)%0A%0A%23check%20%40foldr%0A%0Adef%20all_even_yay%20%3A%20list%20nat%20%E2%86%92%20bool%20%3A%3D%20foldr%20all_even_op%20tt%0A%0A%23check%20all_even_yay%0A%0A%0A%23eval%20all_even_yay%20%5B%5D%20%20%20%20%20%20%20--%20expect%20tt%0A%23eval%20all_even_yay%20%5B1%5D%20%20%20%20%20%20--%20expect%20ff%0A%23eval%20all_even_yay%20%5B0%2C2%2C4%5D%20%20--%20expect%20tt%0A%23eval%20all_even_yay%20%5B0%2C2%2C5%5D%20%20--%20expect%20ff%0A%0A%0A%23eval%20foldr%20nat.add%200%20%5B1%2C2%2C3%2C4%2C5%5D%0A%23eval%20foldr%20nat.mul%201%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_668.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">foldr</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="o">(</span><span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span>
<span class="bp">|</span> <span class="n">op</span> <span class="n">id</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">id</span>
<span class="bp">|</span> <span class="n">op</span> <span class="n">id</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">op</span> <span class="n">h</span> <span class="o">(</span><span class="n">foldr</span> <span class="n">op</span> <span class="n">id</span> <span class="n">t</span><span class="o">)</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">foldr</span>

<span class="kd">def</span> <span class="n">all_even_yay</span> <span class="o">:</span> <span class="n">list</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">bool</span> <span class="o">:=</span> <span class="n">foldr</span> <span class="n">all_even_op</span> <span class="n">tt</span>

<span class="k">#check</span> <span class="n">all_even_yay</span>


<span class="k">#eval</span> <span class="n">all_even_yay</span> <span class="o">[]</span>       <span class="c1">-- expect tt</span>
<span class="k">#eval</span> <span class="n">all_even_yay</span> <span class="o">[</span><span class="mi">1</span><span class="o">]</span>      <span class="c1">-- expect ff</span>
<span class="k">#eval</span> <span class="n">all_even_yay</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span>  <span class="c1">-- expect tt</span>
<span class="k">#eval</span> <span class="n">all_even_yay</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>  <span class="c1">-- expect ff</span>


<span class="k">#eval</span> <span class="n">foldr</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#eval</span> <span class="n">foldr</span> <span class="n">nat.mul</span> <span class="mi">1</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
</section>
<section id="summary">
<h3><span class="section-number">4.4.7. </span>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">&#61633;</a></h3>
<p>In summary, so far in this chapter, we&#8217;ve seen that higher-order
functions are functions that consume functions as arguments and/or
that return functions as results. We&#8217;ve produced highly general
higher-order functions for (1) composition of functions, (2) mapping
functions over lists to derive new lists, and (3) extending binary
operators to n-ary operators whose arguments are given as lists of any
length.</p>
</section>
<section id="id6">
<h3><span class="section-number">4.4.8. </span>Exercises<a class="headerlink" href="#id6" title="Permalink to this heading">&#61633;</a></h3>
<ul class="simple">
<li><p>Define an n-ary Boolean &#8220;and&#8221; function using foldr.</p></li>
<li><p>Define an n-ary Boolean &#8220;or&#8221; function using foldr.</p></li>
<li><p>Define an n-ary &#8469; addition operator using foldr.</p></li>
<li><p>Define an n-ary &#8469; multiplication operator using foldr.</p></li>
<li><p>Define a function called map-reduce. It should accept list of objects of any type &#945;, a function that converts &#945; objects to &#946; objects, and a binary operation suitable for use by our generalized fold function. As an example, you could use this function to reduce a list of strings to a Boolean value that&#8217;s true if every string in a list of strings is of even length. First map the list of strings to a list of their lengths, then reduce this list to a Boolean, tt iff all lengths are even.</p></li>
</ul>
</section>
<section id="looking-forward">
<h3><span class="section-number">4.4.9. </span>Looking forward<a class="headerlink" href="#looking-forward" title="Permalink to this heading">&#61633;</a></h3>
<p>This chapter introduced the idea that for fold to work
correctly, it must be provided both a binary operator, op
(for now let&#8217;s assume of type &#945; &#8594; &#945; &#8594; &#945;), and an identity
element <em>for that operator</em> to be returned as a result for
an empty list. We saw that unless additional measures are
taken, we can&#8217;t prevent inconsistencies between operator
and identity element values. Then we showed that we can
enforce consistency by requiring an additional argument,
namely a proof that <em>id</em> really <em>is</em> an identity element
for <em>op</em>.</p>
<p>For id to be an identity element it has to be that for
any <em>(a : &#945;), op id a = a</em> (<em>id</em> is a <em>left</em> identity)
and <em>op a id = a</em> (<em>id</em> is a <em>right</em> identity). We were
able to prove easily that <em>0</em> is a right identity for
<em>nat.add</em>. The reason this is an easy proof is that it&#8217;s
an <em>axiom</em> given by the definition of addition.:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20add%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%20%20%7C%20a%20%20zero%20%20%20%20%20%3A%3D%20a%0A%20%20%7C%20a%20%20(succ%20b)%20%3A%3D%20succ%20(add%20a%20b)" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_732.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
  <span class="bp">|</span> <span class="n">a</span>  <span class="n">zero</span>     <span class="o">:=</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">a</span>  <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div><p>The first &#8220;rule&#8221; of addition states that for any <em>a</em>,
<em>add a 0</em> reduces to just <em>a</em>.  Here&#8217;s a formal proof
that zero is a right identity for addition.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20zero_right_ident_add_nat%20%3A%20%E2%88%80%20n%20%3A%20nat%2C%20nat.add%20n%200%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Aby%20simp%20%5Bnat.add%5D%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_740.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">zero_right_ident_add_nat</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">nat.add</span> <span class="n">n</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="kd">by</span> <span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The problem is that there&#8217;s no similar axiom proving
that zero if a <em>left</em> identity for nat addition, so
we can&#8217;t use a similar proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20n%20%3A%20nat%2C%20nat.add%200%20n%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Asimp%20%5Bnat.add%5D%2C%20%20%20--%20nope%2C%20no%20rule%20matches%20the%20goal%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_752.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>   <span class="c1">-- nope, no rule matches the goal</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The clever mathematician might suggest that we try a
proof by case analysis on <em>n</em>, but that doesn&#8217;t work
either.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20n%20%3A%20nat%2C%20nat.add%200%20n%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%20%20--%20nope%2C%20no%20rule%20matches%20the%20goal%0Asimp%20%5Bnat.add%5D%2C%20%20%20--%20base%20case%20is%20easy%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20but%20now%20we're%20stuck%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_764.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">,</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>  <span class="c1">-- nope, no rule matches the goal</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>   <span class="c1">-- base case is easy</span>
                  <span class="c1">-- but now we&#39;re stuck</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>In the next chapter, we&#8217;ll see how to prove this
proposition using a method new for us: <em>proof by induction</em>.</p>
</section>
</section>
<section id="recursive-proofs">
<h2><span class="section-number">4.5. </span>Recursive Proofs<a class="headerlink" href="#recursive-proofs" title="Permalink to this heading">&#61633;</a></h2>
<p>This chapter you will teach you about proof by induction.</p>
<p>Proof by induction is a method for constructing proofs of
universal generalizations, of the form, <em>&#8704; (a : &#945;), P a,</em>
where &#945; is an arbitrary type and <em>P</em> is a predicate on (and
thus represents a property of) objects of type &#945;.</p>
<p>The key idea is that such proofs are in general constructed
recursively, (1) with proofs of <em>P a</em> for <em>larger</em> values of
<em>a</em> being constructible in some cases from proofs of <em>P a&#8217;</em>
for  smaller values of <em>a</em>, and (2) starting from proofs of
<em>P a</em> for <em>smallest</em> values of <em>a</em>.</p>
<p>The rest of this chapter will:</p>
<ul class="simple">
<li><p>provide a concrete and pecific example of this reasoning and how we can automate it using tools we already have, concluding what is called the induction axiom for natural numbers (arguments to <em>P</em>);</p></li>
<li><p>see how the concept of an induction axiom generalizes to any inductively defined type, &#945;;</p></li>
<li><p>introduce the concept of <em>inductive families</em> with recursive constructors;</p></li>
<li><p>introduce the idea of well founded recursion, meaning that a proof for every value of a type can be constructed starting with smallest values of the type.</p></li>
<li><p>recognize that some types have no smallest values, making proof by induction inapplicable in these cases</p></li>
</ul>
<section id="the-idea-by-example">
<h3><span class="section-number">4.5.1. </span>The Idea by Example<a class="headerlink" href="#the-idea-by-example" title="Permalink to this heading">&#61633;</a></h3>
<p>In the last chapter we defined a <em>safe</em> version of <em>fold</em>
by requiring that a proof be given as an argument: that the
value returned for an empty list be a right identity for the
binary operator argument. In many similar situations we will
require that a value be probably both a left and a right
identity.</p>
<p>We found it easy to prove that <em>nat.zero</em> is indeed a right
identity for <em>nat.add</em>. So can&#8217;t we just replicate the proof
that zero is a right identity to show that it&#8217;s also a left
identity? The answer is actually no.</p>
<p>The reason that it was easy to prove that zero is a right
identity is because it&#8217;s already given as an <em>axiom,</em> by
the very definition of <em>nat.add</em>.</p>
<p>In particular, the first  rule in this definition states
exactly that for any <em>a, nat.add a nat.zero = a</em>. Here&#8217;s
the definition of <em>nat.add</em> from Lean&#8217;s core library. Look
at the first case: if zero is the second (right) argument
to add, we just return the first argument, which makes
zero a right zero for any natural number first argument.:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20add%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20a%20%20zero%20%20%20%20%20%3A%3D%20a%0A%7C%20a%20%20(succ%20b)%20%3A%3D%20succ%20(add%20a%20b)" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_54.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">add</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">a</span>  <span class="n">zero</span>     <span class="o">:=</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">a</span>  <span class="o">(</span><span class="n">succ</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span> <span class="n">succ</span> <span class="o">(</span><span class="n">add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Here again is the proof we constructed. We assume <em>n</em> is
an arbitrary natural number. Then by the first rule of add,
<em>nat.add n zero</em> reduces to <em>n</em>, so all that remains to show
is that <em>n = n</em>. Lean automates construction of that proof
using <em>rfl</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20and%20a%20proof%2C%20zero%20on%20the%20right%0Aexample%20%3A%20%E2%88%80%20(a%20%3A%20%E2%84%95)%2C%20nat.add%20a%20nat.zero%20%3D%20a%20%3A%3D%0Abegin%0Aassume%20a%2C%0Asimp%20%5Bnat.add%5D%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_64.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- and a proof, zero on the right</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span> <span class="n">nat.add</span> <span class="n">a</span> <span class="n">nat.zero</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The <em>simp</em> tactict tries to find, and if found applies,
rules/axioms from the definition of the listed functions:
here from just nat.add. We could have used <em>rfl</em> instead
of <em>simp</em>, but writing the proof in this way emphasizes
that <em>simplification of expressions using already proven
or accepted lemmas</em> is a very important maneuver in many
proofs.</p>
<section id="the-problem">
<h4><span class="section-number">4.5.1.1. </span>The Problem<a class="headerlink" href="#the-problem" title="Permalink to this heading">&#61633;</a></h4>
<p>What&#8217;s <em>not</em> provided by the definition of <em>nat.add</em> is
an axiom that stipulates that zero is a <em>left</em> identity
for nat.add. The problem is that if we try the same proof
technique to now prove <em>&#8704; n, 0 + a = a</em> (with zero now on
the left), it doesn&#8217;t work! The definition of <em>nat.add</em>
tells us nothing about the result when zero is added on
the <em>left</em> to a value, <em>a</em>. Let&#8217;s see what happens when
we try.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20n%2C%20nat.add%20nat.zero%20n%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Asimp%20%5Bnat.add%5D%2C%0A--%20that%20didn't%20help%3B%20we're%20stuck!%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_93.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.add</span> <span class="n">nat.zero</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="c1">-- that didn&#39;t help; we&#39;re stuck!</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We might instead consider proof by case analysis
on <em>n</em>. That doesn&#8217;t work either, as we see now.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20n%2C%20nat.add%20nat.zero%20n%20%3D%20n%20%3A%3D%0Abegin%0Aassume%20n%2C%0Acases%20n%20with%20n'%2C%0A--%20first%20case%3A%20zero's%20also%20on%20the%20right%0Asimp%20%5Bnat.add%5D%2C%0A--%20second%20case%2C%20argument%20is%20succ%20of%20some%20n'%0A--%20how%20to%20show%200%20%2B%20(succ%20n')%20%3D%20(succ%20n')%0A--%20but%20again%20we're%20stuck%0Asimp%20%5Bnat.add%5D%2C%0A--%20basically%20back%20where%20we%20started%3B%20stuck.%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_105.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">nat.add</span> <span class="n">nat.zero</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">n</span> <span class="k">with</span> <span class="n">n&#39;</span><span class="o">,</span>
<span class="c1">-- first case: zero&#39;s also on the right</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="c1">-- second case, argument is succ of some n&#39;</span>
<span class="c1">-- how to show 0 + (succ n&#39;) = (succ n&#39;)</span>
<span class="c1">-- but again we&#39;re stuck</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="c1">-- basically back where we started; stuck.</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="a-solution">
<h4><span class="section-number">4.5.1.2. </span>A Solution<a class="headerlink" href="#a-solution" title="Permalink to this heading">&#61633;</a></h4>
<p>From basic arithmetic we know it&#8217;s true that
every natural number, <em>a</em>, has the <em>property</em>
that <em>0 + a = a,</em> but it&#8217;s also now clear that
we don&#8217;t yet have the tools to prove that this
is true. In this section we&#8217;ll present a new
method, <em>proof by induction,</em> that will close
this gap.</p>
<p>To begin, let&#8217;s formally state the <em>property</em>
that we want to prove is true for every <em>nat</em>.
As we&#8217;ve seen before, we&#8217;ll formally state the
property as a predicate, and then we&#8217;ll see a
way to prove that this predicate is true for
every natural number.</p>
<p>Let&#8217;s define <em>(P a)</em> to be the proposition that
<em>0 + a = a</em>. Our goal will then be to show that
<em>&#8704; (a : &#8469;), P a.</em></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20The%20property%20we%20want%20to%20prove%20is%20universal%0Adef%20P%20(a%20%3A%20%E2%84%95)%20%3A%20Prop%20%3A%3D%20nat.add%20nat.zero%20a%20%3D%20a%0A%0A%23check%20P%20%20%20%20%20%20--%20nat%20%E2%86%92%20Prop%20%20%20--%20property%2Fpredicate" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_143.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- The property we want to prove is universal</span>
<span class="kd">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">nat.add</span> <span class="n">nat.zero</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>

<span class="k">#check</span> <span class="n">P</span>      <span class="c1">-- nat &#8594; Prop   -- property/predicate</span>
</pre></div>
</div>
</div><p>Let&#8217;s take a different approach, starting with
a problem instance, with zero on the left, that
we can easily prove: namely when zero is also on
the right, because in this special case we <em>can</em>
use the first axiom/rule of addition. (Yes, we
can use rfl instead, but we&#8217;re interested to see
a general approach.)</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20p0%20%3A%20P%200%20%3A%3D%0Abegin%0Aunfold%20P%2C%20%20%20%20%20%20%20%20%20--%20expand%20definition%20of%20P%0Asimp%20%5Bnat.add%5D%2C%20%20%20%20%20%20%20%20--%20rfl%20to%20finish%20off%20proof%0A%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_159.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">p0</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span>         <span class="c1">-- expand definition of P</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>        <span class="c1">-- rfl to finish off proof</span>

<span class="kd">end</span>
</pre></div>
</div>
</div><p>That was easy but it doesn&#8217;t get us very far. We
next ask the question, from the value, 0, and our
proof of (P 0), can we construct a proof of (P 1)?
In fact we can.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20p1%20%3A%20P%201%20%3A%3D%0Abegin%0Aunfold%20P%2C%0Ahave%20ih%20%3A%3D%20p0%2C%0Aunfold%20P%20at%20ih%2C%0Ashow%20nat.succ%20(nat.add%20nat.zero%20nat.zero)%20%3D%201%2C%20--%20first%20rule%20of%20add%0Arw%20ih%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_173.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">p1</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span>
<span class="k">have</span> <span class="n">ih</span> <span class="o">:=</span> <span class="n">p0</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">P</span> <span class="n">at</span> <span class="n">ih</span><span class="o">,</span>
<span class="k">show</span> <span class="n">nat.succ</span> <span class="o">(</span><span class="n">nat.add</span> <span class="n">nat.zero</span> <span class="n">nat.zero</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">,</span> <span class="c1">-- first rule of add</span>
<span class="n">rw</span> <span class="n">ih</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Lean provides some automation here. First it
applies the second rule of nat.add to change
the goal to (in effect) 1 + (0 + 0) = 1; then
it (in effect) uses p0 to rewrite 0 + 0 as 0,
then it uses the first rule to rewrite 1 + 0
as 1 (zero on the right), and finally rfl to
polish off the proof.</p>
<p>From a proof that 0 is a <em>left</em> identity for
0 can we build a proof that 0 is a left identity
for one! So from a proof of P 1, can we now build
a proof of P 2? Yes, we can!</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20p2%20%3A%20P%202%20%20%3A%3D%0Abegin%0Aunfold%20P%2C%0Ahave%20ih%20%3A%3D%20p1%2C%0Ashow%201%20%2B%20(0%20%2B%201)%20%3D%202%2C%20--%20second%20rule%20of%20add%0Aunfold%20P%20at%20ih%2C%20%20%20%20%20%20%20--%20use%20ih%2C%20Lean%20automation%0Aend%0A%0Atheorem%20p3%20%3A%20P%203%20%20%3A%3D%0Abegin%0Aunfold%20P%2C%0Ahave%20ih%20%3A%3D%20p2%2C%20%20%20%20--%20just%20for%20clarity%0Ashow%201%20%2B%20(0%20%2B%202)%20%3D%203%2C%0Aunfold%20P%20at%20ih%2C%0Aend%0A%0Atheorem%20p4%20%3A%20P%204%20%20%3A%3D%0Abegin%0Ahave%20ih%20%3A%3D%20p3%2C%20%20%20%20--%20just%20for%20clarity%0Ashow%201%20%2B%20(0%20%2B%203)%20%3D%204%2C%0Aunfold%20P%20at%20ih%2C%0Aend%0A%0A%2F-%20It%20looks%20like%20that%20from%20any%20nat%2C%20*a'%20%3A%20nat*%2C%0Aand%20a%20proof%20of%20*P%20a'*%20we%20can%20prove%20*P%20(a'%20%2B%201)*.%0A-%2F" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_197.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">p2</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">2</span>  <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span>
<span class="k">have</span> <span class="n">ih</span> <span class="o">:=</span> <span class="n">p1</span><span class="o">,</span>
<span class="k">show</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">2</span><span class="o">,</span> <span class="c1">-- second rule of add</span>
<span class="n">unfold</span> <span class="n">P</span> <span class="n">at</span> <span class="n">ih</span><span class="o">,</span>       <span class="c1">-- use ih, Lean automation</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">p3</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">3</span>  <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span>
<span class="k">have</span> <span class="n">ih</span> <span class="o">:=</span> <span class="n">p2</span><span class="o">,</span>    <span class="c1">-- just for clarity</span>
<span class="k">show</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">3</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">P</span> <span class="n">at</span> <span class="n">ih</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">p4</span> <span class="o">:</span> <span class="n">P</span> <span class="mi">4</span>  <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">have</span> <span class="n">ih</span> <span class="o">:=</span> <span class="n">p3</span><span class="o">,</span>    <span class="c1">-- just for clarity</span>
<span class="k">show</span> <span class="mi">1</span> <span class="bp">+</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">4</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">P</span> <span class="n">at</span> <span class="n">ih</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c">/-</span><span class="cm"> It looks like that from any nat, *a&#39; : nat*,</span>
<span class="cm">and a proof of *P a&#39;* we can prove *P (a&#39; + 1)*.</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>Clearly we can&#8217;t write such a proof for each value
of <em>a&#8217;</em>. The next question is, <em>Can we generalize the
idea that we can *step up</em> from a proof of <em>P a&#8217;</em> to
a proof of <em>P (a&#8217;+1)</em> for any value of <em>a&#8217;</em>?  That is,
can we show <a href="#id7"><span class="problematic" id="id8">*</span></a>&#8704; (a&#8217; : &#8469;), P a&#8217; &#8594; P (a&#8217; + 1)? We can!</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=lemma%20step%20%3A%20%E2%88%80%20(a'%20%3A%20%E2%84%95)%2C%20P%20a'%20%E2%86%92%20P%20(a'.succ)%20%3A%3D%0Abegin%0Aassume%20a'%20ih%2C%0Aunfold%20P%20at%20ih%2C%0Aunfold%20P%2C%0A--%20some%20tedious%20rewriting%20of%20notations%20is%20needed%0A--%20Lean%20confirms%20that%20these%20rewrites%20are%20valid%0Ashow%20nat.add%200%20a'.succ%20%3D%20a'.succ%2C%0A--%20now%20this%20simplification%20works%0Asimp%20%5Bnat.add%5D%2C%0A--%20same%20problem%20again%0Ashow%200%20%2B%20a'%20%3D%20a'%2C%0A%2F-%0AWe've%20thus%20reduced%20the%20original%20goal%20to%20the%0Agoal%20of%20proving%20the%20hypothesis%20that%20we%20have%0Aalready%20assumed%20(implication%20introduction).%0A-%2F%0Aapply%20ih%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_232.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">lemma</span> <span class="n">step</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span> <span class="n">P</span> <span class="n">a&#39;</span> <span class="bp">&#8594;</span> <span class="n">P</span> <span class="o">(</span><span class="n">a&#39;.succ</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a&#39;</span> <span class="n">ih</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">P</span> <span class="n">at</span> <span class="n">ih</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span>
<span class="c1">-- some tedious rewriting of notations is needed</span>
<span class="c1">-- Lean confirms that these rewrites are valid</span>
<span class="k">show</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="n">a&#39;.succ</span> <span class="bp">=</span> <span class="n">a&#39;.succ</span><span class="o">,</span>
<span class="c1">-- now this simplification works</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="c1">-- same problem again</span>
<span class="k">show</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">a&#39;</span> <span class="bp">=</span> <span class="n">a&#39;</span><span class="o">,</span>
<span class="c">/-</span>
<span class="cm">We&#39;ve thus reduced the original goal to the</span>
<span class="cm">goal of proving the hypothesis that we have</span>
<span class="cm">already assumed (implication introduction).</span>
<span class="cm">-/</span>
<span class="n">apply</span> <span class="n">ih</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We don&#8217;t yet have the proof of <em>&#8704; a, P a</em> that
we seek. What we do have are proofs, <em>p0 : P 0</em>
and <em>step: &#8704; a&#8217;, P a&#8217; &#8594; P (a&#8217;+1).</em> Moreover we&#8217;ve
just seen that if we start with <em>p0</em> and apply
<em>step a</em> times, we can construct a proof of <em>P a</em>
for any value, <em>a</em>. Of course now we can automate
that last step by writing a function that does
just that: take any value, <em>a</em>, start with <em>p0</em>,
and apply <em>step a</em> times, and end up with a proof
of <em>P a</em>. The iterative application of <em>step</em> is
accomplished by recursion.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20formerly%20called%20pa%20(in%20class)%0Adef%20zero_left_ident_add_nat%20%3A%20%E2%88%80%20(a%20%3A%20%E2%84%95)%2C%20(nat.add%200%20a%20%3D%20a)%0A%7C%200%20%3A%3D%20p0%0A%7C%20(nat.succ%20a')%20%3A%3D%20(step%20a'%20(zero_left_ident_add_nat%20a'))" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_266.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- formerly called pa (in class)</span>
<span class="kd">def</span> <span class="n">zero_left_ident_add_nat</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span> <span class="o">(</span><span class="n">nat.add</span> <span class="mi">0</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">p0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">step</span> <span class="n">a&#39;</span> <span class="o">(</span><span class="n">zero_left_ident_add_nat</span> <span class="n">a&#39;</span><span class="o">))</span>
</pre></div>
</div>
</div><p>The function, zero_left_ident_add, proves &#8704; a, P a!
It&#8217;s a universal generalization, so we can apply it to any
specific value of <em>a</em> to get a proof that zero is a left
identity for that particular <em>a</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23reduce%20zero_left_ident_add_nat%200%0A%23reduce%20zero_left_ident_add_nat%201%0A%23reduce%20zero_left_ident_add_nat%202%0A%23reduce%20zero_left_ident_add_nat%203" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_278.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#reduce</span> <span class="n">zero_left_ident_add_nat</span> <span class="mi">0</span>
<span class="k">#reduce</span> <span class="n">zero_left_ident_add_nat</span> <span class="mi">1</span>
<span class="k">#reduce</span> <span class="n">zero_left_ident_add_nat</span> <span class="mi">2</span>
<span class="k">#reduce</span> <span class="n">zero_left_ident_add_nat</span> <span class="mi">3</span>
</pre></div>
</div>
</div><p>Moreover, by inspecting the (semi-unreadable) proof
terms, you can see that the proof term for each value,
<em>a,</em> includes within it a proof term for the next smaller
value, all the way down to the proof term for zero. Just
as larger nat values are built from, and incorporate,
smaller ones, down to zero, so do proofs of <em>P a</em> for
larger value of <em>a</em> build on and incorporate proofs of
<em>P a&#8217;</em> for smaller values of <em>a&#8217;,</em> all the way down to
a proof of <em>P 0</em>. We thus construct proofs of <em>P a</em> for
any <em>a</em> inductively, just as we define the natural numbers
themselves inductively. This method is called <em>proof by
induction</em>.</p>
</section>
<section id="summary-proof-by-induction">
<h4><span class="section-number">4.5.1.3. </span>Summary: Proof by Induction<a class="headerlink" href="#summary-proof-by-induction" title="Permalink to this heading">&#61633;</a></h4>
<p>Let&#8217;s pull the pieces of this story together. We started by
specifying a property, <em>P a := 0 + a = 0</em>, of natural numbers.
Then we then proved that <em>every</em> natural number, <em>a</em>, has this
property: <em>&#8704; (a : &#8469;), P a</em>. The proof relied on two lemmas and
a procedure that uses both of them.</p>
<ul class="simple">
<li><p>First, we constructed a proof <em>refl : P 0</em> (0 is a left identity for 0);</p></li>
<li><p>Second, we proved <em>step : &#8704; a&#8217;, P a&#8217; &#8594; P (a&#8217; + 1) (from any natural number, *a&#8217;,if *we have a proof of *P a&#8217;</em>, then we can derive a proof of P (a&#8217; + 1);</p></li>
<li><p>Finally these facts prove that every natural number <em>a</em> has property <em>P</em> by giving a function that constructs a proof of <em>P a</em> for any <em>a</em>;</p></li>
<li><p>Key idea: apply <em>step</em> to <em>refl a</em> times (by ordinary recursion) to produce a proof of <em>P a</em>.</p></li>
</ul>
<p>For our particular definition of <em>P a</em> at least, we&#8217;ve thus proved this:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=*%E2%88%80%20(a%20%3A%20%E2%84%95)%2C%0A%20%20P%200%20%E2%86%92%0A%20%20(%E2%88%80%20(a'%20%3A%20%E2%84%95)%2C%20P%20a'%20%E2%86%92%20P%20(a'%20%2B%201))%20%E2%86%92%0A%20%20P%20a*" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_314.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="bp">*&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span>
  <span class="n">P</span> <span class="mi">0</span> <span class="bp">&#8594;</span>
  <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span> <span class="n">P</span> <span class="n">a&#39;</span> <span class="bp">&#8594;</span> <span class="n">P</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">&#8594;</span>
  <span class="n">P</span> <span class="n">a</span><span class="bp">*</span>
</pre></div>
</div>
</div><p>If <em>a</em> is an arbitrary natural number, and if we have a
proof, <em>base : P 0,</em> and if we also have a proof, <em>step :
&#8704; (a&#8217; : &#8469;), P a&#8217; &#8594; P (a&#8217; + 1)</em>, then by iteratively applying
<em>step</em> to <em>base</em> we can derive a proof of <em>P a</em>. As <em>a</em>
was arbitrary, we&#8217;ve proved <em>&#8704; a, P a.</em> Moreover, the proofs
constructed in this way have recursive structures.</p>
<p>At this point we&#8217;ve proved that zero is both a left and a
right identity for the natural numbers. We can thus say that
zero is an additive identity (on the left and right) for the
natural numbers.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40nat.rec_on%0A%0A%0Adef%20base_fac%20%3A%3D%201%0A%0Adef%20step_fac%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20n'%20fac_n'%20%3A%3D%20(n'%20%2B%201)%20*%20fac_n'%0A%0Adef%20fac%20(n%20%3A%20nat)%20%3A%20nat%20%3A%3D%0Abegin%0Aapply%20nat.rec_on%20n%2C%0Aexact%20base_fac%2C%0Aexact%20step_fac%2C%0Aend%0A%0Adef%20fac'%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%3A%3D%201%0A%7C%20(nat.succ%20n')%20%3A%3D%20(nat.succ%20n')%20*%20fac'%20n'%0A%0A%23eval%20fac'%205%0A%0A%23eval%20fac%205" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_331.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">nat.rec_on</span>


<span class="kd">def</span> <span class="n">base_fac</span> <span class="o">:=</span> <span class="mi">1</span>

<span class="kd">def</span> <span class="n">step_fac</span> <span class="o">:</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="n">nat</span>
<span class="bp">|</span> <span class="n">n&#39;</span> <span class="n">fac_n&#39;</span> <span class="o">:=</span> <span class="o">(</span><span class="n">n&#39;</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="bp">*</span> <span class="n">fac_n&#39;</span>

<span class="kd">def</span> <span class="n">fac</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">nat.rec_on</span> <span class="n">n</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">base_fac</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">step_fac</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">fac&#39;</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="bp">*</span> <span class="n">fac&#39;</span> <span class="n">n&#39;</span>

<span class="k">#eval</span> <span class="n">fac&#39;</span> <span class="mi">5</span>

<span class="k">#eval</span> <span class="n">fac</span> <span class="mi">5</span>
</pre></div>
</div>
</div></section>
<section id="theorem-0-is-identity-for">
<h4><span class="section-number">4.5.1.4. </span>Theorem: 0 is identity for &#10216;&#8469;, +&#10217;<a class="headerlink" href="#theorem-0-is-identity-for" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20We%20now%20have%20that%20zero%20is%20an%20*additive%20identity%20for%20%E2%84%95*%0A%23check%20zero_left_ident_add_nat%0A%23check%20zero_right_ident_add_nat%0A%0Atheorem%20zero_ident_add_nat%20%3A%0A%20%20%E2%88%80%20(a%20%3A%20%E2%84%95)%2C%0A%20%20%20%20nat.add%20nat.zero%20a%20%3D%20a%20%E2%88%A7%0A%20%20%20%20nat.add%20a%20nat.zero%20%3D%20a%20%3A%3D%0Abegin%0Aintro%20a%2C%0Asplit%2C%0Aapply%20(zero_left_ident_add_nat%20a)%2C%0Aapply%20(zero_right_ident_add_nat%20a)%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_362.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- We now have that zero is an *additive identity for &#8469;*</span>
<span class="k">#check</span> <span class="n">zero_left_ident_add_nat</span>
<span class="k">#check</span> <span class="n">zero_right_ident_add_nat</span>

<span class="kd">theorem</span> <span class="n">zero_ident_add_nat</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span>
    <span class="n">nat.add</span> <span class="n">nat.zero</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">&#8743;</span>
    <span class="n">nat.add</span> <span class="n">a</span> <span class="n">nat.zero</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">intro</span> <span class="n">a</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>
<span class="n">apply</span> <span class="o">(</span><span class="n">zero_left_ident_add_nat</span> <span class="n">a</span><span class="o">),</span>
<span class="n">apply</span> <span class="o">(</span><span class="n">zero_right_ident_add_nat</span> <span class="n">a</span><span class="o">),</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We&#8217;ve now made a major advance toward being able to formalize
our first important algebraic structure, that of a <em>monoid</em>.
In particular, we&#8217;re now well along to showing that &#10216;&#8469;, 0, +&#10217;
is a monoid. We still have some unresolved issues to address,
however.</p>
<ul class="simple">
<li><p>To be a monoid, the given binary operator must be associative</p></li>
<li><p>We&#8217;ll want monoids with other binary operations, e.g., &#10216;&#8469;, 1, <a href="#id9"><span class="problematic" id="id10">*</span></a>&#10217;</p></li>
<li><p>We&#8217;ll want monoids over other types, e.g, &#10216;list &#945;, [], append&#10217;</p></li>
</ul>
<p>Many of the proofs we&#8217;ll need will rely on the induction method.
To get there, we need to understand how induction is a <em>general</em>
method of proof construction. It generalizes:</p>
<ul class="simple">
<li><p>from the property of <em>having 0 as an identity for +</em> to any property of natural numbers</p></li>
<li><p>from properties involving natural number to properties involving other types (e.g., list)</p></li>
</ul>
<p>The plan going forward is:</p>
<ul class="simple">
<li><p>induction axioms (recursive proof building functions) <em>in general</em></p></li>
<li><p>a proof that nat + is associative, giving us what we need for a &#10216;&#8469;, +, 0&#10217; monoid</p></li>
<li><p>proofs that 1 is a * identity, and that * associative, giving us a &#10216;&#8469;, <a href="#id11"><span class="problematic" id="id12">*</span></a>, 1&#10217; monoid</p></li>
<li><p>generalize to other types, with &#10216;list &#945;, append, []&#10217; as a monoid on lists example</p></li>
<li><p>a final version of foldr, extending the binary operation of any monoid to n-ary</p></li>
</ul>
</section>
<section id="induction-axiom-for">
<h4><span class="section-number">4.5.1.5. </span>Induction Axiom for &#8469;<a class="headerlink" href="#induction-axiom-for" title="Permalink to this heading">&#61633;</a></h4>
<p>The principle we&#8217;ve developed is available as an axiom
generated from the definition of the nat data type. The
name of the principle is <em>nat.rec_on</em>. Applying it to the
smaller lemmas yeilds a proof of the generalization.</p>
<p>If you prove the lemmas first, in a bottom-up proof style,
you can just apply the induction principle to a value, <em>a</em>,
and to the two proofs, to get a proof of <em>P a</em>. Or you can
apply the axiom giving only nat value as an argument while
leaving the proof arguments to be provided as proofs of
subgoals.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20The%20induction%20principle%20for%20natural%20numbers.%0A%23check%20%40nat.rec_on" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_419.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- The induction principle for natural numbers.</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">nat.rec_on</span>
</pre></div>
</div>
</div><p>A top-down approach is more typical, wherein we apply the
induction axiom for natural numbers to construct the overall
proof we need, leaving the smaller lemmas to be proved as
subgoals.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20a%2C%20P%20a%20%3A%3D%0Abegin%0Aunfold%20P%2C%0Aassume%20a%2C%0Aapply%20nat.rec_on%20a%2C%0Aexact%20rfl%2C%20%20%20%20--%20base%20case%0Aexact%20step%2C%20%20%20--%20we%20use%20already%20proven%20lemma%0Aend%0A%0A--%20You%20can%20also%20use%20Lean's%20*induction%20tactic*.%0Aexample%20%3A%20%E2%88%80%20a%2C%20P%20a%20%3A%3D%0Abegin%0Aassume%20a%2C%0Aunfold%20P%2C%0Ainduction%20a%20with%20a'%20ih%2C%20--%20applies%20axiom%0Aexact%20rfl%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20base%20case%0Asimp%20%5Bnat.add%5D%2C%0Aassumption%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_429.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">nat.rec_on</span> <span class="n">a</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>    <span class="c1">-- base case</span>
<span class="n">exact</span> <span class="n">step</span><span class="o">,</span>   <span class="c1">-- we use already proven lemma</span>
<span class="kd">end</span>

<span class="c1">-- You can also use Lean&#39;s *induction tactic*.</span>
<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">a</span> <span class="k">with</span> <span class="n">a&#39;</span> <span class="n">ih</span><span class="o">,</span> <span class="c1">-- applies axiom</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>              <span class="c1">-- base case</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="theorem-1-is-identity-for">
<h4><span class="section-number">4.5.1.6. </span>Theorem: 1 is identity for &#10216;&#8469;, <a href="#id13"><span class="problematic" id="id14">*</span></a>&#10217;<a class="headerlink" href="#theorem-1-is-identity-for" title="Permalink to this heading">&#61633;</a></h4>
<p>Here from Lean&#8217;s library is the definition
of natural number multiplication. Your job
is to prove that 1 is an identity (left and
right identity) for &#10216;&#8469;, <a href="#id15"><span class="problematic" id="id16">*</span></a>&#10217;. Fill in the missing proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20nat.mul%0A%2F-%0Adef%20mul%20%3A%20nat%20%E2%86%92%20nat%20%E2%86%92%20nat%0A%7C%20a%200%20%20%20%20%20%3A%3D%200%0A%7C%20a%20(b%2B1)%20%3A%3D%20(mul%20a%20b)%20%2B%20a%0A-%2F%0A%0Atheorem%20mul_one_ident_nat%20%3A%0A%20%20%20%20%E2%88%80%20(a%20%3A%20%E2%84%95)%2C%0A%20%20%20%20(nat.mul%201%20a%20%3D%20a)%20%E2%88%A7%0A%20%20%20%20(nat.mul%20a%201%20%3D%20a)%20%20%3A%3D%0Abegin%0Aassume%20a%2C%0Asplit%2C%0A%0A--%20left%20conjunct%3A%20nat.mul%201%20a%20%3D%20a%0Ainduction%20a%20with%20a'%20ih%2C%0A--%20base%20case%0Asimp%20%5Bnat.mul%5D%2C%0A--%20inductive%20case%0Asimp%20%5Bnat.mul%5D%2C%0Arw%20ih%2C%0A%0A--%20right%20conjunct%3A%20nat.mul%20a%201%20%3D%20a%0Asimp%20%5Bnat.mul%5D%2C%0Aapply%20zero_left_ident_add_nat%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_460.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">nat.mul</span>
<span class="c">/-</span>
<span class="cm">def mul : nat &#8594; nat &#8594; nat</span>
<span class="cm">| a 0     := 0</span>
<span class="cm">| a (b+1) := (mul a b) + a</span>
<span class="cm">-/</span>

<span class="kd">theorem</span> <span class="n">mul_one_ident_nat</span> <span class="o">:</span>
    <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span>
    <span class="o">(</span><span class="n">nat.mul</span> <span class="mi">1</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8743;</span>
    <span class="o">(</span><span class="n">nat.mul</span> <span class="n">a</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>  <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
<span class="n">split</span><span class="o">,</span>

<span class="c1">-- left conjunct: nat.mul 1 a = a</span>
<span class="n">induction</span> <span class="n">a</span> <span class="k">with</span> <span class="n">a&#39;</span> <span class="n">ih</span><span class="o">,</span>
<span class="c1">-- base case</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.mul</span><span class="o">],</span>
<span class="c1">-- inductive case</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.mul</span><span class="o">],</span>
<span class="n">rw</span> <span class="n">ih</span><span class="o">,</span>

<span class="c1">-- right conjunct: nat.mul a 1 = a</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.mul</span><span class="o">],</span>
<span class="n">apply</span> <span class="n">zero_left_ident_add_nat</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="theorems-and-associative">
<h4><span class="section-number">4.5.1.7. </span>Theorems: &#8469; + and * associative<a class="headerlink" href="#theorems-and-associative" title="Permalink to this heading">&#61633;</a></h4>
<p>In this section we&#8217;ll first construct a proof, nat_add_assoc,
that nat.add is associative, then we&#8217;ll do the same, under the
name, nat_mul_assoc, showing that nat.mul is associative, too.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=theorem%20nat_add_assoc%20%3A%0A%20%20%E2%88%80%20(a%20b%20c)%2C%0A%20%20%20%20nat.add%20a%20(nat.add%20b%20c)%20%3D%0A%20%20%20%20nat.add%20(nat.add%20a%20b)%20c%20%3A%3D%0Abegin%0Aassume%20a%20b%20c%2C%0Ainduction%20c%20with%20c'%20ih%2C%0A%0A--%20base%20lemma%0Asimp%20%5Bnat.add%5D%2C%0A%0A--%20induction%20lemma%0Asimp%20%5Bnat.add%5D%2C%0Aassumption%2C%0Aend%0A%0A--%20Yay%2C%20that's%20really%20cool!%0A%0A--%20EXERCISE%3A%20Prove%20that%20nat.mul%20is%20associative%0A%0A%2F-%0AIn%20the%20middle%20of%20trying%20to%20prove%20this%20theorem%2C%20we%20run%20into%20the%20need%0Afor%20another%20theorem%2C%20not%20yet%20proved%3A%20one%20that%20shows%20that%20nat%20add%20and%0Amul%20follow%20the%20distributive%20law%20for%20multiplication%20on%20the%20left%20over%0Aa%20sum.%20We%20present%20here%20an%20example%20of%20how%20one%20can%20assume%20a%20proof%20of%20a%0Alemma%20using%20sorry%2C%20with%20the%20intent%20of%20filling%20it%20in%20later.%20This%20gives%0Ayou%20a%20practical%20approach%20to%20top-down%20proof%20construction%2C%20just%20like%0Ayou%20might%20follow%20a%20discipline%20of%20top-down%20program%20construction.%0A-%2F%0Atheorem%20nat_mul_assoc%20%3A%0A%20%20%E2%88%80%20(a%20b%20c%20%3A%20%E2%84%95)%2C%20nat.mul%20a%20(nat.mul%20b%20c)%20%3D%20nat.mul%20(nat.mul%20a%20b)%20c%20%3A%3D%0Abegin%0Aassume%20a%20b%20c%2C%0Ainduction%20c%20with%20c'%20ih%2C%0A--%20base%20case%0Asimp%20%5Bnat.mul%5D%2C%0A--%20inductive%20case%0Asimp%20%5Bnat.mul%5D%2C%0Arw%20%3C-%20ih%2C%0Ahave%20mul_distrib_add_nat_left%20%3A%0A%20%20%E2%88%80%20x%20y%20z%2C%0A%20%20%20%20nat.mul%20x%20(nat.add%20y%20z)%20%3D%0A%20%20%20%20nat.add%20(nat.mul%20x%20y)%20(nat.mul%20x%20z)%20%3A%3D%0A%20%20%20%20sorry%2C%0Aapply%20mul_distrib_add_nat_left%2C%0Aend%0A%0A--%20We%20leave%20the%20proof%20of%20left%20distributivity%20as%20an%20exercise%20(not%20trivial)%0Alemma%20mul_distrib_add_nat_left%20%3A%0A%20%20%E2%88%80%20x%20y%20z%2C%0A%20%20%20%20nat.mul%20x%20(nat.add%20y%20z)%20%3D%0A%20%20%20%20nat.add%20(nat.mul%20x%20y)%20(nat.mul%20x%20z)%20%3A%3D%20sorry" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_499.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">nat_add_assoc</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">),</span>
    <span class="n">nat.add</span> <span class="n">a</span> <span class="o">(</span><span class="n">nat.add</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">nat.add</span> <span class="o">(</span><span class="n">nat.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">c</span> <span class="k">with</span> <span class="n">c&#39;</span> <span class="n">ih</span><span class="o">,</span>

<span class="c1">-- base lemma</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>

<span class="c1">-- induction lemma</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.add</span><span class="o">],</span>
<span class="n">assumption</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- Yay, that&#39;s really cool!</span>

<span class="c1">-- EXERCISE: Prove that nat.mul is associative</span>

<span class="c">/-</span>
<span class="cm">In the middle of trying to prove this theorem, we run into the need</span>
<span class="cm">for another theorem, not yet proved: one that shows that nat add and</span>
<span class="cm">mul follow the distributive law for multiplication on the left over</span>
<span class="cm">a sum. We present here an example of how one can assume a proof of a</span>
<span class="cm">lemma using sorry, with the intent of filling it in later. This gives</span>
<span class="cm">you a practical approach to top-down proof construction, just like</span>
<span class="cm">you might follow a discipline of top-down program construction.</span>
<span class="cm">-/</span>
<span class="kd">theorem</span> <span class="n">nat_mul_assoc</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span> <span class="n">nat.mul</span> <span class="n">a</span> <span class="o">(</span><span class="n">nat.mul</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat.mul</span> <span class="o">(</span><span class="n">nat.mul</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">c</span> <span class="k">with</span> <span class="n">c&#39;</span> <span class="n">ih</span><span class="o">,</span>
<span class="c1">-- base case</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.mul</span><span class="o">],</span>
<span class="c1">-- inductive case</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">nat.mul</span><span class="o">],</span>
<span class="n">rw</span> <span class="bp">&lt;-</span> <span class="n">ih</span><span class="o">,</span>
<span class="k">have</span> <span class="n">mul_distrib_add_nat_left</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">nat.mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">nat.add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">nat.add</span> <span class="o">(</span><span class="n">nat.mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">nat.mul</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span>
    <span class="gr">sorry</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">mul_distrib_add_nat_left</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- We leave the proof of left distributivity as an exercise (not trivial)</span>
<span class="kd">lemma</span> <span class="n">mul_distrib_add_nat_left</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span>
    <span class="n">nat.mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">nat.add</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="bp">=</span>
    <span class="n">nat.add</span> <span class="o">(</span><span class="n">nat.mul</span> <span class="n">x</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">nat.mul</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">:=</span> <span class="gr">sorry</span>
</pre></div>
</div>
</div></section>
<section id="monoids-and-foldr">
<h4><span class="section-number">4.5.1.8. </span>Monoids and Foldr<a class="headerlink" href="#monoids-and-foldr" title="Permalink to this heading">&#61633;</a></h4>
<p>We can now define a general structure that we can instantiate to
formally represent either and additive or a multiplicative monoid
on the natural numbers. Indeed, we can generalize this definition
to a monoid on values of any type for which a suitable operator and
identity element can be defined.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=universe%20u%0A%0A--%20general%20structure%20(not%20we've%20removed%20%22nat%22%20from%20the%20name)%0Astructure%20monoid%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20Type%20%3A%3D%20mk%3A%3A%0A%20%20(op%20%3A%20%CE%B1%20%20%E2%86%92%20%CE%B1%20%20%E2%86%92%20%CE%B1%20)%0A%20%20(id%20%3A%20%CE%B1%20)%0A%20%20(e%20%3A%20%E2%88%80%20a%2C%20op%20id%20a%20%3D%20a%20%E2%88%A7%20op%20a%20id%20%3D%20a)%0A%20%20(assoc%3A%20%E2%88%80%20a%20b%20c%2C%20op%20a%20(op%20b%20c)%20%3D%20op%20(op%20a%20b)%20c)%0A%0Adef%20nat_add_monoid%20%3A%3D%20monoid.mk%20nat.add%200%20zero_ident_add_nat%20nat_add_assoc%0Adef%20nat_add_monoid'%20%3A%3D%20monoid.mk%20nat.add%201%20zero_ident_add_nat%20nat_add_assoc%20--%20caught%20error%0Adef%20nat_mul_monoid%20%3A%3D%20monoid.mk%20nat.mul%201%20mul_one_ident_nat%20nat_mul_assoc%20%20%20--%20sorry%0A%0A%23reduce%20nat_add_monoid%0A%23reduce%20nat_mul_monoid%0A%0A--%20Monoid%20structure%20instances%0A%23reduce%20foldr%20nat_add_monoid.op%20nat_add_monoid.id%20%5B1%2C2%2C3%2C4%2C5%5D%0A%23reduce%20foldr%20nat_mul_monoid.op%20nat_mul_monoid.id%20%5B1%2C2%2C3%2C4%2C5%5D%0A%0A%0A--%20A%20version%20of%20foldr%20that%20takes%20a%20monoid%20object%20and%20uses%20its%20op%20and%20e%20values%0Adef%20foldr'%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20%40monoid%20%CE%B1%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20%CE%B1%0A%7C%20(monoid.mk%20op%20e%20_%20_)%20l%20%3A%3D%20foldr%20op%20e%20l%0A%0A--%20Safe%20use%20of%20monoid%20instances%20folds%0A%23reduce%20foldr'%20nat_add_monoid%20%5B1%2C2%2C3%2C4%2C5%5D%0A%23reduce%20foldr'%20nat_mul_monoid%20%5B1%2C2%2C3%2C4%2C5%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_566.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">universe</span> <span class="n">u</span>

<span class="c1">-- general structure (not we&#39;ve removed &quot;nat&quot; from the name)</span>
<span class="kd">structure</span> <span class="n">monoid</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">mk</span><span class="o">::</span>
  <span class="o">(</span><span class="n">op</span> <span class="o">:</span> <span class="n">&#945;</span>  <span class="bp">&#8594;</span> <span class="n">&#945;</span>  <span class="bp">&#8594;</span> <span class="n">&#945;</span> <span class="o">)</span>
  <span class="o">(</span><span class="n">id</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="o">)</span>
  <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="n">op</span> <span class="n">id</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">&#8743;</span> <span class="n">op</span> <span class="n">a</span> <span class="n">id</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>
  <span class="o">(</span><span class="n">assoc</span><span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">op</span> <span class="n">a</span> <span class="o">(</span><span class="n">op</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="bp">=</span> <span class="n">op</span> <span class="o">(</span><span class="n">op</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">nat_add_monoid</span> <span class="o">:=</span> <span class="n">monoid.mk</span> <span class="n">nat.add</span> <span class="mi">0</span> <span class="n">zero_ident_add_nat</span> <span class="n">nat_add_assoc</span>
<span class="kd">def</span> <span class="n">nat_add_monoid&#39;</span> <span class="o">:=</span> <span class="n">monoid.mk</span> <span class="n">nat.add</span> <span class="mi">1</span> <span class="n">zero_ident_add_nat</span> <span class="n">nat_add_assoc</span> <span class="c1">-- caught error</span>
<span class="kd">def</span> <span class="n">nat_mul_monoid</span> <span class="o">:=</span> <span class="n">monoid.mk</span> <span class="n">nat.mul</span> <span class="mi">1</span> <span class="n">mul_one_ident_nat</span> <span class="n">nat_mul_assoc</span>   <span class="c1">-- sorry</span>

<span class="k">#reduce</span> <span class="n">nat_add_monoid</span>
<span class="k">#reduce</span> <span class="n">nat_mul_monoid</span>

<span class="c1">-- Monoid structure instances</span>
<span class="k">#reduce</span> <span class="n">foldr</span> <span class="n">nat_add_monoid.op</span> <span class="n">nat_add_monoid.id</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#reduce</span> <span class="n">foldr</span> <span class="n">nat_mul_monoid.op</span> <span class="n">nat_mul_monoid.id</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>


<span class="c1">-- A version of foldr that takes a monoid object and uses its op and e values</span>
<span class="kd">def</span> <span class="n">foldr&#39;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">@</span><span class="n">monoid</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">monoid.mk</span> <span class="n">op</span> <span class="n">e</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="n">l</span> <span class="o">:=</span> <span class="n">foldr</span> <span class="n">op</span> <span class="n">e</span> <span class="n">l</span>

<span class="c1">-- Safe use of monoid instances folds</span>
<span class="k">#reduce</span> <span class="n">foldr&#39;</span> <span class="n">nat_add_monoid</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
<span class="k">#reduce</span> <span class="n">foldr&#39;</span> <span class="n">nat_mul_monoid</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span>
</pre></div>
</div>
</div><p>If we ignore the fact that we don&#8217;t yet have proofs of the
monoid laws for &#10216;list &#945;, [], list.append&#10217; we can actually go
ahead and see that it&#8217;s going to work.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20monoid_list_append'%20%7B%CE%B1%20%3A%20Type%7D%3A%20%40monoid%20(list%20%CE%B1)%20%3A%3D%0A%20%20monoid.mk%20list.append%20%5B%5D%20sorry%20sorry%0A%0A%23eval%20foldr'%20monoid_list_append'%20%5B%5B1%2C2%2C3%5D%2C%5B4%2C5%2C6%5D%2C%5B7%2C8%2C9%5D%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_601.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">monoid_list_append&#39;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}:</span> <span class="bp">@</span><span class="n">monoid</span> <span class="o">(</span><span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">monoid.mk</span> <span class="n">list.append</span> <span class="o">[]</span> <span class="gr">sorry</span> <span class="gr">sorry</span>

<span class="k">#eval</span> <span class="n">foldr&#39;</span> <span class="n">monoid_list_append&#39;</span> <span class="o">[[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],[</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">],[</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">]]</span>
</pre></div>
</div>
</div><p>All that remains is to provide the requisite proofs that
append and nil satisfy the <em>monoid laws</em>. Unlike the proofs
of identities and associativity for natural number operations,
however, we now need to show that [] is an identity for <em>list</em>
append and that append is associative. If proof by induction
worked as well for lists as for natural numbers we&#8217;d be all
set. As we&#8217;ll see next, we&#8217;re in luck.</p>
</section>
</section>
<section id="induction-axioms">
<h3><span class="section-number">4.5.2. </span>Induction Axioms<a class="headerlink" href="#induction-axioms" title="Permalink to this heading">&#61633;</a></h3>
<p>In this chapter, we will meet the idea that there is
an induction axiom for <em>every</em> inductive definition.
We&#8217;ll start by showing that our reasoning about 0
being an identity for nat.add extends directly to
showing that [] is an identity (left and right) for
list.append. We&#8217;ll then discuss the general case.</p>
<section id="theorem-list-append-identity">
<h4><span class="section-number">4.5.2.1. </span>Theorem: [] list append identity<a class="headerlink" href="#theorem-list-append-identity" title="Permalink to this heading">&#61633;</a></h4>
<p>Our overall aim is to show that &#10216;list &#945;, [], ++&#10217; is
a monoid. Then we&#8217;ll be able to use foldr to extend
++ to an operation that will append any number of
lists as long as they are themselves arranged in a
list of lists.</p>
<p>We therefore need to show that [] is an identity on
the left and right for append (++), and that append
is associative. Let&#8217;s take the first theorem here:
[] is an identity for ++.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20To%20be%20proved%0Atheorem%20nil_identity_append_list%20%7B%CE%B1%20%3A%20Type%20u%7D%3A%0A%20%20%E2%88%80%20(l%20%3A%20list%20%CE%B1)%2C%0A%20%20%20%20list.append%20list.nil%20l%20%3D%20l%20%E2%88%A7%0A%20%20%20%20list.append%20l%20list.nil%20%3D%20l%20%3A%3D%20sorry%0A%0A--%20Here%20again%20is%20the%20definition%20list.append%20(%2B%2B).%0A%23check%20%40list.append%0A%2F-%0Adef%20append%20%3A%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%20%20l%20%3A%3D%20l%0A%7C%20(h%20%3A%3A%20s)%20t%20%3A%3D%20h%20%3A%3A%20(append%20s%20t)%0A-%2F" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_640.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- To be proved</span>
<span class="kd">theorem</span> <span class="n">nil_identity_append_list</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span>
    <span class="n">list.append</span> <span class="n">list.nil</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="bp">&#8743;</span>
    <span class="n">list.append</span> <span class="n">l</span> <span class="n">list.nil</span> <span class="bp">=</span> <span class="n">l</span> <span class="o">:=</span> <span class="gr">sorry</span>

<span class="c1">-- Here again is the definition list.append (++).</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">list.append</span>
<span class="c">/-</span>
<span class="cm">def append : list &#945; &#8594; list &#945; &#8594; list &#945;</span>
<span class="cm">| []       l := l</span>
<span class="cm">| (h :: s) t := h :: (append s t)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>By definition, list.nil is a left identity, but as
with nat.add, there&#8217;s no rule telling us that [] is
a right identity. It thus appears (and is the case)
that we will have to prove that [] is an identity on
the right by induction.</p>
<p>Let&#8217;s think about what the induction will look like.
It will be induction on the left argument to append.
First we&#8217;ll need a proof that [] is a right identity
for [] on the left. Then we&#8217;ll need to show that <em>if</em>
for any list, l&#8217; on the left, [] is a right identity
for l&#8217; then it&#8217;s a right identity for any one-larger
list. Such a one-larger list can be any list, hd::l&#8217;,
where hd could be any element of type &#945;.</p>
<p>Let&#8217;s start with a bottom-up approach. We&#8217;ll begin
by formally defining the <em>property</em> of lists that
we want to show is universal, that [] is a right
identity for any list, l.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20list_nil_right_ident_for%20%7B%CE%B1%20%3A%20Type%20u%7D%20(l%20%3A%20list%20%CE%B1)%20%3A%3D%0A%20%20list.append%20l%20%5B%5D%20%3D%20l%0A%0A%0Alemma%20list_base%20%7B%CE%B1%20%3A%20Type%20u%7D%20%3A%0A%20%20list_nil_right_ident_for%20(%5B%5D%20%3A%20list%20%CE%B1)%20%3A%3D%0Abegin%0A--%20unfold%20list_nil_right_ident_for%2C%0Aexact%20rfl%2C%20%20--%20Lean%20unfolds%20name%20automatically%20here%0Aend%0A%0A--%20Now%20let's%20prove%20a%20step%20lemma.%0A%23check%20%40list.rec_on%0A%0Alemma%20list_step%20%7B%CE%B1%20%3A%20Type%20u%7D%20%3A%0A%20%20--%20given%20any%20new%20head%20element%2C%20hd%0A%20%20(%CE%A0%20(hd%20%3A%20%CE%B1)%0A%20%20--%20and%20any%20existing%20list%2C%20l'%0A%20%20%20%20%20(l'%20%3A%20list%20%CE%B1)%2C%0A%20%20--%20if%20%5B%5D%20is%20a%20right%20identity%20for%20l'%0A%20%20%20%20%20list_nil_right_ident_for%20l'%20%E2%86%92%0A%20%20--%20then%20it's%20a%20right%20identity%20for%20one-bigger%20list%0A%20%20%20%20%20list_nil_right_ident_for%20(hd%20%3A%3A%20l'))%20%3A%3D%0Abegin%0Aunfold%20list_nil_right_ident_for%2C%0Aassume%20hd%20l'%20ih%2C%0Asimp%20%5Blist.append%5D%2C%20--%20simplify%20using%20second%20rule%20of%20append%0Aassumption%2C%20%20%20%20%20%20%20%20%20--%20the%20induction%20hypothesis%20finishes%20it%20off%20QED%0Aend%0A%0A--%20Now%20we%20build%20a%20recursive%20function%20to%20return%20proof%20for%20any%20l%0A%23check%20list_base%0A%0Adef%20nil_right_ident_append_list'%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20%E2%88%80%20(l'%20%3A%20list%20%CE%B1)%2C%20list.append%20l'%20%5B%5D%20%3D%20l'%0A%7C%20(list.nil)%20%3A%3D%20list_base%0A%7C%20(h%3A%3At)%20%3A%3D%20list_step%20h%20t%20(nil_right_ident_append_list'%20t)%0A%0A--%20Seems%20to%20work!%0A%23check%20nil_right_ident_append_list'%20%5B1%2C2%5D" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_676.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">list_nil_right_ident_for</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">list.append</span> <span class="n">l</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">l</span>


<span class="kd">lemma</span> <span class="n">list_base</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">list_nil_right_ident_for</span> <span class="o">([]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">-- unfold list_nil_right_ident_for,</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>  <span class="c1">-- Lean unfolds name automatically here</span>
<span class="kd">end</span>

<span class="c1">-- Now let&#39;s prove a step lemma.</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">list.rec_on</span>

<span class="kd">lemma</span> <span class="n">list_step</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span>
  <span class="c1">-- given any new head element, hd</span>
  <span class="o">(</span><span class="bp">&#928;</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span>
  <span class="c1">-- and any existing list, l&#39;</span>
     <span class="o">(</span><span class="n">l&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span>
  <span class="c1">-- if [] is a right identity for l&#39;</span>
     <span class="n">list_nil_right_ident_for</span> <span class="n">l&#39;</span> <span class="bp">&#8594;</span>
  <span class="c1">-- then it&#39;s a right identity for one-bigger list</span>
     <span class="n">list_nil_right_ident_for</span> <span class="o">(</span><span class="n">hd</span> <span class="o">::</span> <span class="n">l&#39;</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">list_nil_right_ident_for</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">hd</span> <span class="n">l&#39;</span> <span class="n">ih</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">list.append</span><span class="o">],</span> <span class="c1">-- simplify using second rule of append</span>
<span class="n">assumption</span><span class="o">,</span>         <span class="c1">-- the induction hypothesis finishes it off QED</span>
<span class="kd">end</span>

<span class="c1">-- Now we build a recursive function to return proof for any l</span>
<span class="k">#check</span> <span class="n">list_base</span>

<span class="kd">def</span> <span class="n">nil_right_ident_append_list&#39;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">l&#39;</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="n">list.append</span> <span class="n">l&#39;</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">l&#39;</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">list.nil</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list_base</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">list_step</span> <span class="n">h</span> <span class="n">t</span> <span class="o">(</span><span class="n">nil_right_ident_append_list&#39;</span> <span class="n">t</span><span class="o">)</span>

<span class="c1">-- Seems to work!</span>
<span class="k">#check</span> <span class="n">nil_right_ident_append_list&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>
</pre></div>
</div>
</div></section>
<section id="induction-axiom-for-lists">
<h4><span class="section-number">4.5.2.2. </span>Induction Axiom for Lists<a class="headerlink" href="#induction-axiom-for-lists" title="Permalink to this heading">&#61633;</a></h4>
<p>We see again that there&#8217;s nothing myseterious about proof by induction.
If we have base values/proofs and step functions to build next-bigger
ones, and we can have a function that (using recursion on these elements)
computes a value/proof for any given input value, and thus for all values
of the input type.</p>
<p>Proof by induction is done by functions that compute results using
recursion on given base values and step functions.  Every inductive
axiom can be understood as a proof of universal generalization that
asserts that every value of some input type has a corresponging result
value of type. These return values can be proofs of properties or they
can be function return values of any type.</p>
<p>Let&#8217;s look at and compare and contrast the induction axioms (they&#8217;re
just higher order functions!) for the nat and list &#945; types. We&#8217;ll then
show how the same ideas developed in the last example apply directly
as well to induction on list values.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40list.rec_on%0A%2F-%0Anat.rec_on%20%3A%0A%20%20%CE%A0%20%7Bmotive%20%3A%20%E2%84%95%20%E2%86%92%20Sort%20u_1%7D%20%20%20--%20property%20or%20return%20value%20type%0A%20%20%20%20(n%20%3A%20%E2%84%95)%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20input%20argument%20value%0A%20%20%20%20motive%200%20%E2%86%92%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20answer%20for%20base%20case%0A%20%20%20%20(%CE%A0%20('n%20%3A%20%E2%84%95)%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20step%20function%20(higher-order!)%0A%20%20%20%20%20%20motive%20n'%20%E2%86%92%0A%20%20%20%20%20%20motive%20n'.succ%0A%20%20%20%20)%20%E2%86%92%0A%20%20motive%20n%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20return%20values%2C%20by%20recursion%0A-%2F%0A%0A%23check%20%40list.rec_on%0A%2F-%0Alist.rec_on%20%3A%0A%20%20%CE%A0%20%7BT%20%3A%20Type%20u_2%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20for%20any%20list%20element%20type%0A%20%20%20%20%7Bmotive%20%3A%20list%20T%20%E2%86%92%20Sort%20u_1%7D%20%20--%20property%20or%20return%20type%0A%20%20%20%20(n%20%3A%20list%20T)%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20input%20argument%20value%0A%20%20%20%20motive%20list.nil%20%E2%86%92%20%20%20%20%20%20%20%20%20%20%20%20%20--%20proof%2Fvalue%20for%20base%20case%0A%20%20%20%20(%CE%A0%20(hd%20%3A%20T)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20step%20function%3A%20understand%20it%0A%20%20%20%20%20%20%20(tl%20%3A%20list%20T)%2C%0A%20%20%20%20%20%20%20motive%20tl%20%E2%86%92%0A%20%20%20%20%20%20%20motive%20(hd%20%3A%3A%20tl))%20%E2%86%92%0A%20%20motive%20n%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20return%20value%2C%20by%20recursion%0A%0A%0AQUESTION%3A%20What%20new%20element%20is%20present%20in%20the%20rule%20for%20lists%0Athat%20isn't%20involved%20in%20the%20rule%20for%20natural%20numbers%3F" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_741.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">list.rec_on</span>
<span class="c">/-</span>
<span class="cm">nat.rec_on :</span>
<span class="cm">  &#928; {motive : &#8469; &#8594; Sort u_1}   -- property or return value type</span>
<span class="cm">    (n : &#8469;),                  -- input argument value</span>
<span class="cm">    motive 0 &#8594;                -- answer for base case</span>
<span class="cm">    (&#928; (&#39;n : &#8469;),              -- step function (higher-order!)</span>
<span class="cm">      motive n&#39; &#8594;</span>
<span class="cm">      motive n&#39;.succ</span>
<span class="cm">    ) &#8594;</span>
<span class="cm">  motive n                    -- return values, by recursion</span>
<span class="cm">-/</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">list.rec_on</span>
<span class="c">/-</span>
<span class="cm">list.rec_on :</span>
<span class="cm">  &#928; {T : Type u_2}                -- for any list element type</span>
<span class="cm">    {motive : list T &#8594; Sort u_1}  -- property or return type</span>
<span class="cm">    (n : list T),                 -- input argument value</span>
<span class="cm">    motive list.nil &#8594;             -- proof/value for base case</span>
<span class="cm">    (&#928; (hd : T)                   -- step function: understand it</span>
<span class="cm">       (tl : list T),</span>
<span class="cm">       motive tl &#8594;</span>
<span class="cm">       motive (hd :: tl)) &#8594;</span>
<span class="cm">  motive n                        -- return value, by recursion</span>


<span class="cm">QUESTION: What new element is present in the rule for lists</span>
<span class="cm">that isn&#39;t involved in the rule for natural numbers?</span>
</pre></div>
</div>
</div><p>Once again we&#8217;ll have to show <em>[]</em> is both a left and
right identity for append, where one proof is by the
definition of append and the other is by induction. We&#8217;ll
also need a proof that <em>list.append</em> is associative:
<a href="#id17"><span class="problematic" id="id18">*</span></a>&#8704; (l m n : list &#945;), (l ++ m) ++ n = l ++ (m ++ n).</p>
<p>Here&#8217;s the definition of list.append.
You can see it defines [] as a left identity for any list.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0Adef%20append%20%3A%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%20%E2%86%92%20list%20%CE%B1%0A%7C%20%5B%5D%20%20%20%20%20%20%20l%20%3A%3D%20l%0A%7C%20(h%20%3A%3A%20s)%20t%20%3A%3D%20h%20%3A%3A%20(append%20s%20t)%0A-%2F%0A%0A%0Atheorem%20nil_left_ident_append_list%20(%CE%B1%20%3A%20Type)%20%3A%20%E2%88%80%20(l%20%3A%20list%20%CE%B1)%2C%20list.nil%20%2B%2B%20l%20%3D%20l%20%3A%3D%0Abegin%0Aassume%20l%2C%0Asimp%20%5Blist.append%5D%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_782.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">def append : list &#945; &#8594; list &#945; &#8594; list &#945;</span>
<span class="cm">| []       l := l</span>
<span class="cm">| (h :: s) t := h :: (append s t)</span>
<span class="cm">-/</span>


<span class="kd">theorem</span> <span class="n">nil_left_ident_append_list</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="n">list.nil</span> <span class="bp">++</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">l</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">list.append</span><span class="o">],</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We run into the same problem as we did before if we take a
naive approach to trying to prove that nil is also a left
identity for ++. And the solution is once again to define
a recursive function by case analysis on l that constructs
a proof of <em>nil ++ l = l</em> for any list l. If l = list.nil,
the proof of nil ++ nil is given by the first rule of list
append, otherwise l = (h::t), and we need to prove that
nil ++ h::t = h::t. By the second axiom of list append,
we can rewrite nil ++ h::t as h::(nil ++ t), where we can
obtain (and then us) a proof that nil ++ t = t by recursion,
terminating when t =nil.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20nil_right_ident_append%20(%CE%B1%20%3A%20Type)%20%3A%0A%20%20%E2%88%80%20(l%20%3A%20list%20%CE%B1)%2C%20l%20%2B%2B%20%5B%5D%20%3D%20l%20%3A%3D%0Abegin%0Aassume%20l%2C%0Ainduction%20l%2C%0Asimp%20%5Blist.append%5D%2C%0Asimp%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_809.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">nil_right_ident_append</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span><span class="o">),</span> <span class="n">l</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">l</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">l</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">l</span><span class="o">,</span>
<span class="n">simp</span> <span class="o">[</span><span class="n">list.append</span><span class="o">],</span>
<span class="n">simp</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="theorem-monoid-list">
<h4><span class="section-number">4.5.2.3. </span>Theorem: monoid (list &#945;)<a class="headerlink" href="#theorem-monoid-list" title="Permalink to this heading">&#61633;</a></h4>
<p>The work you&#8217;ve done until now should have you prepared to finish off
the definition of a monoid instance for list &#945;, [], list.append. You need
the following:</p>
<ul class="simple">
<li><p>a proof that list.append is associative</p></li>
<li><p>to package up the elements you now have into a finished monoid instance</p></li>
<li><p>tests passing this monoid to foldr to see it doing the right things</p></li>
</ul>
<p>This is your homework. You should try it by yourself, for sure, and put strong
effort into solving it. If you end up fruitlessly stuck, you may go ahead and
talk to others, but take the minimal input needed to get unstuck. Maximize your
learning and understanding.</p>
</section>
</section>
<section id="inductive-families">
<h3><span class="section-number">4.5.3. </span>Inductive Families<a class="headerlink" href="#inductive-families" title="Permalink to this heading">&#61633;</a></h3>
<p>Coming soon.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20le%20(n%20%3A%20nat)%3A%20nat%20%E2%86%92%20Prop%0A--%20n%20is%20an%20implicit%20firt%20argument%20to%20each%20constructor%0A%7C%20refl%20%3A%20le%20(n)%20n%0A%7C%20step%20%3A%20%E2%88%80%20m%2C%20le%20(n)%20m%20%E2%86%92%20le%20(n)%20m.succ%0A%0A--%20you%20can%20see%20it%20in%20the%20types%20of%20the%20constructors%0A%23check%20%40le.refl%0A%23check%20%40le.step%0A%0A%0Aexample%20%3A%20le%200%200%20%3A%3D%0Abegin%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%203%203%20%3A%3D%0Abegin%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%200%201%20%3A%3D%0Abegin%0Aapply%20le.step%2C%0Aapply%20le.refl%2C%0Aend%0A%0Aexample%20%3A%20le%200%203%20%3A%3D%0Abegin%0Aapply%20le.step%2C%0Aapply%20le.step%2C%0Aapply%20le.step%2C%0Aapply%20le.refl%2C%0Aend%0A%0A--%20here's%20the%20same%20example%20using%20Lean's%20version%20of%20%22le%22%0A--%20it's%20called%20nat.less_than_or_equal%0Aexample%20%3A%200%20%E2%89%A4%203%20%3A%3D%0Abegin%0Aapply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.step%2C%0A--%20apply%20nat.less_than_or_equal.step%2C%0Aapply%20nat.less_than_or_equal.refl%2C%0Aend%0A%0A--%20repeat%20tactical%20goes%20too%20far%3B%20use%20iterate%20instead%0Aexample%20%3A%201%20%E2%89%A4%204%20%3A%3D%0Abegin%0A--%20repeat%20%7Bapply%20nat.less_than_or_equal.step%7D%2C%0Aiterate%203%20%7Bapply%20nat.less_than_or_equal.step%7D%2C%0Aapply%20nat.less_than_or_equal.refl%2C%0Aend" target="_blank" tryitfile="../examples/A_03_Recursive_Types/unnamed_842.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">le</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">nat</span><span class="o">):</span> <span class="n">nat</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>
<span class="c1">-- n is an implicit firt argument to each constructor</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="n">le</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="n">n</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">m</span><span class="o">,</span> <span class="n">le</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="n">m</span> <span class="bp">&#8594;</span> <span class="n">le</span> <span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="n">m.succ</span>

<span class="c1">-- you can see it in the types of the constructors</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">le.refl</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">le.step</span>


<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">3</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">le</span> <span class="mi">0</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">le.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- here&#39;s the same example using Lean&#39;s version of &quot;le&quot;</span>
<span class="c1">-- it&#39;s called nat.less_than_or_equal</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&#8804;</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">,</span>
<span class="c1">-- apply nat.less_than_or_equal.step,</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.refl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- repeat tactical goes too far; use iterate instead</span>
<span class="kd">example</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&#8804;</span> <span class="mi">4</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="c1">-- repeat {apply nat.less_than_or_equal.step},</span>
<span class="n">iterate</span> <span class="mi">3</span> <span class="o">{</span><span class="n">apply</span> <span class="n">nat.less_than_or_equal.step</span><span class="o">},</span>
<span class="n">apply</span> <span class="n">nat.less_than_or_equal.refl</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="A_02_Constructive_Logic.html" class="btn btn-neutral float-left" title="3. Constructive Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="A_04_Typeclasses.html" class="btn btn-neutral float-right" title="5. Typeclasses" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kevin Sullivan.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>