<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. CS6501 Spring 2023 &mdash; CS6501 Spring 2023 1.2.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Formal Languages" href="A_01_Propositional_Logic.html" />
    <link rel="prev" title="CS6501, Spring 2023, Sullivan" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CS6501 Spring 2023
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. CS6501 Spring 2023</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#to-think-abstractly">1.1. To Think Abstractly</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#abstract-mathematics">1.1.1. Abstract Mathematics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#costs-of-concreteness">1.1.2. Costs of Concreteness</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-path-forward">1.1.3. A Path Forward</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-vision">1.1.4. The Vision</a></li>
<li class="toctree-l3"><a class="reference internal" href="#this-class">1.1.5. This Class</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#welcome-overview">1.2. Welcome. Overview.</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-does-abstract-mean-here">1.2.1. What does <em>abstract</em> mean here?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-abstract-mathematics">1.2.2. Why <em>abstract</em> mathematics?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-is-the-point">1.2.3. What is the point?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">1.2.4. This class</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="A_01_Propositional_Logic.html">2. Formal Languages</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CS6501 Spring 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">1. </span>CS6501 Spring 2023</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/A_00_Introduction.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cs6501-spring-2023">
<span id="introduction"></span><h1><span class="section-number">1. </span>CS6501 Spring 2023<a class="headerlink" href="#cs6501-spring-2023" title="Permalink to this heading">&#61633;</a></h1>
<section id="to-think-abstractly">
<h2><span class="section-number">1.1. </span>To Think Abstractly<a class="headerlink" href="#to-think-abstractly" title="Permalink to this heading">&#61633;</a></h2>
<p>To advance science and engineering, we need languages in
which we can describe and reason about complex worlds. By
a <em>world</em> we mean a collection of objects of interest and
their structures, properties, behaviors, relations to each
other.</p>
<section id="abstract-mathematics">
<h3><span class="section-number">1.1.1. </span>Abstract Mathematics<a class="headerlink" href="#abstract-mathematics" title="Permalink to this heading">&#61633;</a></h3>
<p>Mathematics and formal logics provide such languages. They
give us the intellectual tools we need to think abstractly
and yet with great precision about rich and complex systems:
to represent, reason about, and ultimately design complex
worlds that would otherwise remain beyond our grasps.</p>
<p>As an example, the abstract mathematics of linear and affine
spaces give us languages for describing, reasoning about, and
designing systems that work in the <em>classical</em> physical world
we experience every day. The abstract mathematics of tensor
fields on topological manifolds are essential for describing,
reasoning about, and designing interventions in the <em>quantum</em>
world of particle physics.</p>
<p>By the term, <em>abstract</em>, we mean that descriptions in such
languages represent relevant phenomena precisely, concisely,
and without any unnecessary complexity or inessential detail.</p>
<p>As an example, a physicist might represent two accelerations
applied to a drone in a three-dimensional geometric space in
abstract, coordinate-free terms, by writing this: <em>let a&#8321; and
a&#8322; be accelerations of the drone.</em> This formulation is abstract
insofar as no coordinates are given for these vectors. The
assignment of coordinates to <em>physical</em> quantities is usually
arbitrary and unnecessary to express. A physicist might, for
example, represent <em>the sum of these accelerations</em> simply as
<em>a&#8321; + a&#8322;.</em> This expression has an absolutely precise physical
meaning even though it&#8217;s abstract.</p>
<p>A programmer, by contrast, would typically jump to a choice
of some coordinate system and would then represent the two
physical quantities in the concrete (<em>parametric</em>) terms of
tuples of floating point numbers; with the summation of the
physical accelerations represented by element-wise floating
point addition of the corresponding coordinate tuples.</p>
</section>
<section id="costs-of-concreteness">
<h3><span class="section-number">1.1.2. </span>Costs of Concreteness<a class="headerlink" href="#costs-of-concreteness" title="Permalink to this heading">&#61633;</a></h3>
<p>This ubiquitous approach to programming physical computations
is problematical in multiple dimensions. First, as mentioned,
it substitues concrete representations for abstract, adding
inessesntial complexity to models and computations. Second,
it generally strips away crucial mathematical properties of
the abstract representations of objects of interest, making
it impossible to check programs for consistency with such
mathematics.</p>
<p>For example, in the <em>tf</em> and <em>tf2</em> affine space libraries of
the Robot Operating System (ROS) platform for the programming
of terrestrial robots, points and vectors are represented in
the concrete terms of coordinate tuples relative to arbitrary
coordinate frames. But it gets worse: points and vectors in
this framework are aliases for the same concrete type: a type
of floating-point tuples.</p>
<p>This means, among other things, that one can add points to
points in <em>tf</em> without receiving any type errors from the
programming language system, even though addition of points
to points makes no physical sense and is inconsistent with
the abstract mathematics of the domain. In an affine space,
there is no operation for adding points to point.</p>
<p>The nearly exclusive use of concrete representations in most
everyday programming complicates software design and reasoning
by requiring the manipulation of often complex, inessential
details. And because so much of the structure of the mathematics
of the domain is <em>forgotten</em> in the programming code, it also
becomes impossible for the programming system to check for what
we might call <em>full physical type consistency</em>.</p>
<p>Programming code thus generally ends up deeply disconnected
from the abstract mathematics of the physics of the domain that
it&#8217;s meant to represent, manipulate, implement, and free to
carry out inconsistent operations. As one example, programmers
often struggle mightily using different frames of reference in
a consistent manner, e.g., by adding vectors represented by
numerical tuples but with coordinates expressed in different
frames of reference.</p>
<p>A special case, by the way, is operating incorrectly on values
because they are expressed in different units, such a meters
and feet. We can understand 1 meter and 1 foot as each being
a basis vector for the <em>same</em> one-dimensional physical space.
Clearly adding numerical values of 2 (feet) and 3 (meters) to
produce 5 of <em>something,</em> produces a meaningless result.</p>
</section>
<section id="a-path-forward">
<h3><span class="section-number">1.1.3. </span>A Path Forward<a class="headerlink" href="#a-path-forward" title="Permalink to this heading">&#61633;</a></h3>
<p>So why haven&#8217;t we already deeply connected concrete to code
the abstract mathematics of the domain in which it&#8217;s meant
to operate? Perhaps the most fundamental reason is that math
has up until recently been a quasi-formal, paper-and-pencil
exercise, making it, hard even impossible, to connect code
to such mathematics.</p>
<p>Now, with rapidly developing work by a still small set of
ressearchers in mathematics, the complete formalization and
mechanization of advanced abstract mathematics is becoming
a reality. As and example Massot and his colleagues in 2022
managed to formalize not only a statement, but a proof, of
the local h-principle for first-order, open, ample partial
differential relations, with the possibility of eversion of
the 3-sphere as a corollary.</p>
<p>Their work showed that their approach to formalizing
mathematics is no longer useful mostly just for abstract
algebra, but that it also now promises advances in abstract
geometry (e.g., on manifolds), which is at the very heart
of not only terrestrial robotics but also modern physics
and perhaps even areas such areas as deep learning.</p>
</section>
<section id="the-vision">
<h3><span class="section-number">1.1.4. </span>The Vision<a class="headerlink" href="#the-vision" title="Permalink to this heading">&#61633;</a></h3>
<p>The insight driving this class is that this kind of work
from the  mathematics community is now making it possible
to develop <em>computable abstract mathematics</em> for purposes
of software engineering. Promising application domains for
such work clearly include divere cyber-physical systems and
might be relevant to deep learning as well, with its basic
assumption that real-world data have geometric properties,
such as lying on high-dimensional manifolds.</p>
<p>What we seek are ways to enable use of the abstract mathematical
languages of such domains, coupled with concrete representations
to support computation, with <em>full physical type checking</em> of the
physical mathematics; <em>foundational proofs</em> of correctness of the
mathematics; and explicit link to concrete (often coordinate-based)
representations that are necessary in practical implementations.</p>
</section>
<section id="this-class">
<h3><span class="section-number">1.1.5. </span>This Class<a class="headerlink" href="#this-class" title="Permalink to this heading">&#61633;</a></h3>
<p>The purpose of this class is to introduce computer science
students to the ideas necessary to pursue both research and
development activities based on these ideas. We will use the
preferred tool of the community of mathematicians pushing the
formalization of mathematics, namely the Lean Proof Assistant,
developed by Leo DeMoura at Microsoft research, and the ever
growing <em>mathlib</em> library of formalized mathematics.</p>
</section>
</section>
<section id="welcome-overview">
<h2><span class="section-number">1.2. </span>Welcome. Overview.<a class="headerlink" href="#welcome-overview" title="Permalink to this heading">&#61633;</a></h2>
<p>This is a special topics course in software engineering. The idea
that we will explore is that we can now import ongoing advances
in the formalization of abstract mathematics (in type theory and
to a significant extent around the Lean prover and its mathematics
libraries) as new foundations for engineering software programs for
systems that inhabit domains that have such abstract mathematical
underpinnings. Such domains include physics, and thus also a broad
range of cyber-physical systems.</p>
<p>Along the way, you&#8217;ll learn formal logic and proof construction,
foundations of programming languages, functional programming, and
more. By the end you will know how to use some cutting-edge tools,
type theory and constructive logic proof assistants, to formalize
the abstract mathematics of important application domains.</p>
<section id="what-does-abstract-mean-here">
<h3><span class="section-number">1.2.1. </span>What does <em>abstract</em> mean here?<a class="headerlink" href="#what-does-abstract-mean-here" title="Permalink to this heading">&#61633;</a></h3>
<p>Here, the adjective, abstract, means <em>being coordinate-free</em>.
For the opposite of <em>abstract</em>, we&#8217;ll use <em>parametric</em>. The idea
is that a mathematical object, such as a vector, can be understood
simply as such, with no reference to coordinates; or that same abstract
vector can be represented concretely/parametrically as a struture of
parameter values expressed relative to some given frame of reference.</p>
</section>
<section id="why-abstract-mathematics">
<h3><span class="section-number">1.2.2. </span>Why <em>abstract</em> mathematics?<a class="headerlink" href="#why-abstract-mathematics" title="Permalink to this heading">&#61633;</a></h3>
<p>A premise of this class is that domain experts (e.g., in the
physics of terrestrial robotics, or of elemenary particles) speak,
model, analyze, and understand the operation of systems in the
abstract mathematical language of the domain, and very often not
in terms of ultimately arbitrarily selected frames of reference .</p>
<p>This is clear in physics where complex mathematical structures
such as tensor fields on topological manifolds are essential for
precise definitions of phenomena in particle physics.</p>
<p>Domain-specific abstract mathematics formalized in type theory
is what we see as an important language of the domain, to serve
as a basis for programming with static checking of abstractions,
and with parametric representations carried along as necessary.</p>
</section>
<section id="what-is-the-point">
<h3><span class="section-number">1.2.3. </span>What is the point?<a class="headerlink" href="#what-is-the-point" title="Permalink to this heading">&#61633;</a></h3>
<p>A remarkable feature of constructive logics as hosted by many
proof assistants is that they can compute. Computation is now
wholly integral to practical logical reasoning if only because
some proofs require systematic case analysis over very large
numbers of cases, given as the outputs of other computations.</p>
<p>This is is relevant because it suggests that fully formalizing
the fully developed mathematical language of the given domain,
we will be well on our way to having reference specifications
and with computable implementations.</p>
<p>Going even further, the most recent version of Lean is intended
as an efficient general-purpose programming language as well as
a proof assistant, compiling to C, and with workable language
interoperability interfaces.</p>
<p>In the future we expect to be able to statically type check and
foundationally verify &#8220;code&#8221; written in the abstract mathematics
of the domain and with very little custom coding needed also to
have corresponding verified implementations, even if only used as
test oracles for production code.</p>
<p>This is the of abstract specifictions from which concrete
implementations are derived. I will not say refined because
in practice most derivations are not refinements but rather
toyish models of semantically rich and complex computations
in the source domain.</p>
</section>
<section id="id1">
<h3><span class="section-number">1.2.4. </span>This class<a class="headerlink" href="#id1" title="Permalink to this heading">&#61633;</a></h3>
<p>The first major part of this class will teach you the fundamentals
of programming and reasoning in Lean 3. We will mainly use Lean 3,
nothwithstaning that Lean 4 is garnering real attention and effort.
Student might wish to explore Lean 4 as an optional class activity.</p>
<p>The second part of the class will focus on how to formalized abstract
mathematical structures in Lean, and how we might such capabilities
to  these advances in formalizing mathematics to help meet
the need for statically type checked specifications in the abstract
language of the domain, with corresponding parametric representations
carried along for computational possibly and oher purposes.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="CS6501, Spring 2023, Sullivan" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="A_01_Propositional_Logic.html" class="btn btn-neutral float-right" title="2. Formal Languages" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kevin Sullivan.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>