<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6. Algebraic Structures &mdash; CS6501 Spring 2023 1.2.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Index" href="genindex.html" />
    <link rel="prev" title="5. Typeclasses" href="A_04_Typeclasses.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CS6501 Spring 2023
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="A_00_Introduction.html">1. CS6501 Spring 2023</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_01_Propositional_Logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_02_Constructive_Logic.html">3. Constructive Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_03_Recursive_Types.html">4. Recursive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_04_Typeclasses.html">5. Typeclasses</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Algebraic Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#monoids">6.1. Monoids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extended-example">6.1.1. Extended Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#elements-operation-proofs">6.1.2. Elements, Operation, Proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monoid-typeclass">6.1.3. Monoid typeclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semigroup">6.1.4. Semigroup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#has-mul">6.1.5. has_mul</a></li>
<li class="toctree-l3"><a class="reference internal" href="#has-mul-instance">6.1.6. has_mul instance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semigroup-instance">6.1.7. semigroup instance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mul-one-class-instance">6.1.8. mul_one_class instance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-we-get">6.1.9. What we get</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#groups">6.2. Groups</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples">6.2.1. Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rotation-groups">6.2.1.1. Rotation groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#translation-groups">6.2.1.2. Translation groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chapter-plan">6.2.1.3. Chapter plan</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#typeclasses">6.2.2. Typeclasses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#group">6.2.2.1. group</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monoid">6.2.2.2. monoid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#div-inv-monoid">6.2.2.3. div_inv_monoid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#has-inv">6.2.2.4. has_inv</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#instances">6.2.3. Instances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#has-inv-rot">6.2.3.1. has_inv rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#has-div-rot">6.2.3.2. has_div rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#div-inv-monoid-rot">6.2.3.3. div_inv_monoid rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aside-int-type">6.2.3.4. aside: int type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#group-rot">6.2.3.5. group rot</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#actions">6.3. Actions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#target-type">6.3.1. Target Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">6.3.2. Typeclasses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#has-smul">6.3.2.1. has_smul</a></li>
<li class="toctree-l4"><a class="reference internal" href="#group-action">6.3.2.2. group_action</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">6.3.3. Instances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#has-smul-rot-tri">6.3.3.1. has_smul rot tri</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mul-action-m">6.3.3.2. mul_action M &#945;</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#discussion">6.3.4. Discussion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#torsors">6.4. Torsors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">6.4.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#readings">6.4.2. Readings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#typeclass">6.4.3. Typeclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">6.4.4. Instances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#add-monoid-rot">6.4.4.1. add_monoid rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-group-rot">6.4.4.2. add_group rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#has-vadd-rot-tri">6.4.4.3. has_vadd rot tri</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-action-rot-tri">6.4.4.4. add_action rot tri</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-torsor-rot-tri">6.4.4.5. add_torsor rot tri</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#programming">6.4.5. Programming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">6.4.6. Discussion</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#an-archictural-template">6.4.6.1. An archictural template</a></li>
<li class="toctree-l4"><a class="reference internal" href="#role-of-origin">6.4.6.2. Role of origin</a></li>
<li class="toctree-l4"><a class="reference internal" href="#path-forward">6.4.6.3. Path Forward</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#modules">6.5. Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modules-in-lean">6.5.1. Modules in Lean</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">6.5.2. Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">6.5.3. Typeclasses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module">6.5.3.1. module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#semiring">6.5.3.2. semiring &#8484;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#add-comm-monoid-rot">6.5.3.3. add_comm_monoid &#8484; rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#distrib-mul-action-rot">6.5.3.4. distrib_mul_action &#8484; rot</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#typeclass-instances">6.5.4. Typeclass instances</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">6.5.4.1. add_comm_monoid rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">6.5.4.2. distrib_mul_action &#8484; rot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">6.5.4.3. semiring &#8484;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-rot">6.5.4.4. module &#8484; rot</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#foolproof-abstract-mathematics">6.5.5. Foolproof abstract mathematics</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CS6501 Spring 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">6. </span>Algebraic Structures</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/A_05_Algebraic_Structures.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="algebraic-structures">
<span id="introduction"></span><h1><span class="section-number">6. </span>Algebraic Structures<a class="headerlink" href="#algebraic-structures" title="Permalink to this heading">&#61633;</a></h1>
<section id="monoids">
<h2><span class="section-number">6.1. </span>Monoids<a class="headerlink" href="#monoids" title="Permalink to this heading">&#61633;</a></h2>
<p>In this section, we&#8217;ll analyze and use the definition of monoids provided
by Lean&#8217;s <em>mathlib</em>.</p>
<section id="extended-example">
<h3><span class="section-number">6.1.1. </span>Extended Example<a class="headerlink" href="#extended-example" title="Permalink to this heading">&#61633;</a></h3>
<p>As an exceptionally simple example, we&#8217;ll define an instance of this
concept where the elements of a multiplicative monoid are <em>rotations</em>
of an equilateral triangle that leave its vertices pointing in the
same direction as the original. We call such rotations <em>symmetries</em>
of an equilateral triange.</p>
<p>Think of such a triangle with a black dot marking the top vertex when
the triangle is in an un-rotated state. The symetries are rotations
that leave the rotated triangle sitting right on top of where it was
in its unrotated state. These are rotations by 0 degrees, which
leaves the dot where it is; by 120 degrees, which rotates the dot by one
vertex counterclockwise; and by 240 degrees, which rotates the dot two
vertices counterclockwise. Rotating by 360 degrees leaves the dot exactly
where it started, and so is equal to the zero rotation.</p>
<p>These are all of the <em>rotational symmetries</em> of an equilateral triangle.
We&#8217;ll call them <em>r0</em>, <em>r120</em>, and <em>r240</em>. Again these are the <em>elements</em>
of our monoid, well call it <em>rot</em>, short for the <em>rotational
symmetries of an equilateral triangle</em>.</p>
<p>To be a monoid we also need an associative operator that takes any two
monoid elements and returns another monoid element. Our operator will
work by <em>composing</em> translations, and we&#8217;ll use multiplicative notation
for this operation. As an example, if we compose r120 with r120 we get
a rotation by 240 degrees, which is r240; composing r240 and r120 is
rotates by 360 degrees giving back the original triangle, and so is
equal to r0. It&#8217;s a simple exercise to write out the <em>multiplication
table</em> for this operator.</p>
<p>Finally we need our set of elements to includes an identity element,
e, that when composed with any element, r, just yields r. Clearly
r0 serves this purpose.</p>
</section>
<section id="elements-operation-proofs">
<h3><span class="section-number">6.1.2. </span>Elements, Operation, Proofs<a class="headerlink" href="#elements-operation-proofs" title="Permalink to this heading">&#61633;</a></h3>
<p>To formally specify our monoid of rotational symmetries of a regular
triangle as a monoid, we&#8217;ll need to represent the set of rotations
and the composition operation, and we&#8217;ll need to prove that these
components satisfy the monoid laws.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20We%20represent%20the%20set%20of%20monoid%20elements%20(rotations)%20as%20a%20type%0Ainductive%20rot%0A%7C%20r0%0A%7C%20r120%0A%7C%20r240%0A%0Aopen%20rot%0A%0A--%20We%20represent%20the%20operation%20as%20a%20binary%20operation%20on%20this%0Adef%20rot_mul%20%3A%20rot%20%E2%86%92%20rot%20%E2%86%92%20rot%0A%7C%20r0%20r0%20%3A%3D%20r0%0A%7C%20r0%20r120%20%3A%3D%20r120%0A%7C%20r0%20r240%20%3A%3D%20r240%0A%7C%20r120%20r0%20%3A%3D%20r120%0A%7C%20r120%20r120%20%3A%3D%20r240%0A%7C%20r120%20r240%20%3A%3D%20r0%0A%7C%20r240%20r0%20%3A%3D%20r240%0A%7C%20r240%20r120%20%3A%3D%20r0%0A%7C%20r240%20r240%20%3A%3D%20r120%0A%0A--%20We%20need%20a%20proof%20that%20r0%20is%20an%20identity%20for%20this%20operation%0A%0Atheorem%20rot_left_ident%20%3A%20%E2%88%80%20(r%20%3A%20rot)%2C%20rot_mul%20r0%20r%20%3D%20r%20%20%3A%3D%0Abegin%0Aassume%20r%2C%0Acases%20r%2C%0Arepeat%20%7Bexact%20rfl%2C%7D%0Aend%0A%0Atheorem%20rot_right_ident%20%3A%20%E2%88%80%20(r%20%3A%20rot)%2C%20rot_mul%20r%20%20r0%20%3D%20r%20%3A%3D%0Abegin%0Aassume%20r%2C%0Acases%20r%2C%0Arepeat%20%7Bapply%20rfl%7D%2C%0Aend%0A%0A--%20And%20we%20need%20a%20proof%20that%20the%20operation%20is%20associative%0A%0Atheorem%20rot_mul_assoc%20%3A%0A%20%20%E2%88%80%20(e1%20e2%20e3%20%3A%20rot)%2C%0A%20%20%20%20rot_mul%20(rot_mul%20e1%20e2)%20e3%20%3D%20rot_mul%20e1%20(rot_mul%20e2%20e3)%20%3A%3D%0Abegin%0Aassume%20e1%20e2%20e3%2C%0A%0Acases%20e1%2C%0Arepeat%20%7B%0A%20%20cases%20e2%2C%0A%20%20repeat%20%7B%0A%20%20%20%20cases%20e3%2C%0A%20%20%20%20repeat%20%7Bexact%20rfl%7D%7D%2C%0A%20%20%7D%2C%0Aend" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_52.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- We represent the set of monoid elements (rotations) as a type</span>
<span class="kd">inductive</span> <span class="n">rot</span>
<span class="bp">|</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">r240</span>

<span class="kn">open</span> <span class="n">rot</span>

<span class="c1">-- We represent the operation as a binary operation on this</span>
<span class="kd">def</span> <span class="n">rot_mul</span> <span class="o">:</span> <span class="n">rot</span> <span class="bp">&#8594;</span> <span class="n">rot</span> <span class="bp">&#8594;</span> <span class="n">rot</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="n">r120</span> <span class="o">:=</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="n">r240</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">r120</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">r240</span> <span class="o">:=</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">r120</span> <span class="o">:=</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">r240</span> <span class="o">:=</span> <span class="n">r120</span>

<span class="c1">-- We need a proof that r0 is an identity for this operation</span>

<span class="kd">theorem</span> <span class="n">rot_left_ident</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">rot_mul</span> <span class="n">r0</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">r</span>  <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">r</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">r</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">,}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">rot_right_ident</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">rot_mul</span> <span class="n">r</span>  <span class="n">r0</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">r</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">r</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">apply</span> <span class="n">rfl</span><span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- And we need a proof that the operation is associative</span>

<span class="kd">theorem</span> <span class="n">rot_mul_assoc</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span>
    <span class="n">rot_mul</span> <span class="o">(</span><span class="n">rot_mul</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="n">e3</span> <span class="bp">=</span> <span class="n">rot_mul</span> <span class="n">e1</span> <span class="o">(</span><span class="n">rot_mul</span> <span class="n">e2</span> <span class="n">e3</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span><span class="o">,</span>

<span class="n">cases</span> <span class="n">e1</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span>
  <span class="n">cases</span> <span class="n">e2</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">e3</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">}},</span>
  <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="monoid-typeclass">
<h3><span class="section-number">6.1.3. </span>Monoid typeclass<a class="headerlink" href="#monoid-typeclass" title="Permalink to this heading">&#61633;</a></h3>
<p>That&#8217;s all we need to have a monoid. Next we assemble these
elements into an instance of Lean&#8217;s monoid typeclass. Once we
do that, we&#8217;ll benefit from all of the machinery (including
notations and other operations) that come Lean&#8217;s monoid and
its underlying typeclass definitions. So let&#8217;s look to see
exactly what&#8217;s needed to create our own monoid instance.
Here&#8217;s Lean&#8217;s definition of monoid.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40monoid%0A%2F-%0Aclass%20monoid%20(M%20%3A%20Type%20u)%20extends%20semigroup%20M%2C%20mul_one_class%20M%20%3A%3D%0A(npow%20%3A%20%E2%84%95%20%E2%86%92%20M%20%E2%86%92%20M%20%3A%3D%20npow_rec)%0A(npow_zero'%20%3A%20%E2%88%80%20x%2C%20npow%200%20x%20%3D%201%20.%20try_refl_tac)%0A(npow_succ'%20%3A%20%E2%88%80%20(n%20%3A%20%E2%84%95)%20x%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x%20.%20try_refl_tac)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_119.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">monoid</span>
<span class="c">/-</span>
<span class="cm">class monoid (M : Type u) extends semigroup M, mul_one_class M :=</span>
<span class="cm">(npow : &#8469; &#8594; M &#8594; M := npow_rec)</span>
<span class="cm">(npow_zero&#39; : &#8704; x, npow 0 x = 1 . try_refl_tac)</span>
<span class="cm">(npow_succ&#39; : &#8704; (n : &#8469;) x, npow n.succ x = x * npow n x . try_refl_tac)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>We see that a monoid on a carrier set, <em>M</em> (here of rotations), will
extend semi-group and mul_one_class typeclasses, so we&#8217;ll need to go
look at those. The typeclass itself requires an operation n_pow, which
will be defined recursively as applying a given operation <em>n</em> times.
The proofs require base and recursive step cases, which will be given
by the base and inductive rules of the given function. Let&#8217;s ignore the
details of notation for now. What&#8217;s important to know is that these
proofs are given values here that will be computed automatically
when a definition of npow is actually given.</p>
<p>The <em>major</em> insight to gain from this definition is that, to define
a monoid typeclass instance, we need to already have instances of
Lean&#8217;s semigroup and mul_one_class typeclasses. So Let&#8217;s see what
we need for those, digging down until we reach simplest typeclasses.
We&#8217;ll then build our monoid typeclass instances in a bottom-up
fashion.</p>
</section>
<section id="semigroup">
<h3><span class="section-number">6.1.4. </span>Semigroup<a class="headerlink" href="#semigroup" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40semigroup%0A%2F-%0Aclass%20semigroup%20(G%20%3A%20Type%20u)%20extends%20has_mul%20G%20%3A%3D%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%20%3A%20G%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_149.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">semigroup</span>
<span class="c">/-</span>
<span class="cm">class semigroup (G : Type u) extends has_mul G :=</span>
<span class="cm">(mul_assoc : &#8704; a b c : G, a * b * c = a * (b * c))</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>We see that to define a semigroup instance we&#8217;ll need an instance
of has_mul, so let&#8217;s look at that.
TEXT.</p>
</section>
<section id="has-mul">
<h3><span class="section-number">6.1.5. </span>has_mul<a class="headerlink" href="#has-mul" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40has_mul%0A%2F-%0Aclass%20has_mul%20%20%20%20%20%20(%CE%B1%20%3A%20Type%20u)%20%3A%3D%20(mul%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20%CE%B1)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_165.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">has_mul</span>
<span class="c">/-</span>
<span class="cm">class has_mul      (&#945; : Type u) := (mul : &#945; &#8594; &#945; &#8594; &#945;)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
<section id="has-mul-instance">
<h3><span class="section-number">6.1.6. </span>has_mul instance<a class="headerlink" href="#has-mul-instance" title="Permalink to this heading">&#61633;</a></h3>
<p>Hooray, we have everything we need to define an instance of this
typeclass, namely just a multiplication operator (mul) for objects
in our monoid. That operator is rot_mul. (Note that you can define
typeclass instances without giving them names, which is typical.)</p>
<p>You see here the use of angle-brackets to specify the field
values of a given structure. It&#8217;s easier to use than has_mul.mk.</p>
</section>
<section id="semigroup-instance">
<h3><span class="section-number">6.1.7. </span>semigroup instance<a class="headerlink" href="#semigroup-instance" title="Permalink to this heading">&#61633;</a></h3>
<p>Now we&#8217;ve got what we need to specify a semigroup typeclass
instance, which simply adds the constraint (in the form of a
proof) that the operator be associative.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20check%20the%20constructor%20to%20see%20the%20required%20field%20values%0A%23check%20%40semigroup.mk%0A%2F-%0A%CE%A0%20%7BG%20%3A%20Type%20u%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20carrier%20set%20implicit%0A%20%20(mul%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20operator%0A%20%20(%E2%88%80%20(a%20b%20c%20%3A%20G)%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%20%E2%86%92%20%20--%20proof%20of%20associativity%0Asemigroup%20G%0A-%2F%0A%0Ainstance%20%3A%20semigroup%20rot%20%3A%3D%20%E2%9F%A8%20rot_mul%2C%20rot_mul_assoc%20%E2%9F%A9%0A%23check%20%40mul_one_class" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_191.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- check the constructor to see the required field values</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">semigroup.mk</span>
<span class="c">/-</span>
<span class="cm">&#928; {G : Type u}                                -- carrier set implicit</span>
<span class="cm">  (mul : G &#8594; G &#8594; G),                          -- operator</span>
<span class="cm">  (&#8704; (a b c : G), a * b * c = a * (b * c)) &#8594;  -- proof of associativity</span>
<span class="cm">semigroup G</span>
<span class="cm">-/</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="n">rot</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">rot_mul</span><span class="o">,</span> <span class="n">rot_mul_assoc</span> <span class="o">&#10217;</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">mul_one_class</span>
</pre></div>
</div>
</div></section>
<section id="mul-one-class-instance">
<h3><span class="section-number">6.1.8. </span>mul_one_class instance<a class="headerlink" href="#mul-one-class-instance" title="Permalink to this heading">&#61633;</a></h3>
<p>To complete a typeclass instance for monoid, we also need an instance
for mul_one_class, and as we&#8217;ll now see, that in turn requires
instances of has_one and has_mul. We aready have an instance of has_mul,
so all we need to define now is has_one, which identities the identity
element in the monoid, which will then be denoted by <em>1</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40mul_one_class%0A%23check%20%40has_one%0A%23check%20%40has_mul%0A%0A%2F-%0Aclass%20mul_one_class%20(M%20%3A%20Type%20u)%20extends%20has_one%20M%2C%20has_mul%20M%20%3A%3D%0A(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%201%20*%20a%20%3D%20a)%0A(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%20a%20*%201%20%3D%20a)%0A%0Aclass%20has_one%20%20%20%20%20%20(%CE%B1%20%3A%20Type%20u)%20%3A%3D%20(one%20%3A%20%CE%B1)%0A-%2F%0Ainstance%20%3A%20has_one%20rot%20%3A%3D%20%E2%9F%A8%20r0%20%E2%9F%A9%0A%0A%23check%20%40mul_one_class.mk%0A%2F-%0A%20%CE%A0%20%7BM%20%3A%20Type%20u%7D%0A%20%20%20(one%20%3A%20M)%0A%20%20%20(mul%20%3A%20M%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20%20(%E2%88%80%20(a%20%3A%20M)%2C%201%20*%20a%20%3D%20a)%20%E2%86%92%0A%20%20%20(%E2%88%80%20(a%20%3A%20M)%2C%20a%20*%201%20%3D%20a)%20%E2%86%92%0A%20%20mul_one_class%20M%0A-%2F%0Ainstance%20%3A%20mul_one_class%20rot%20%3A%3D%0A%E2%9F%A8%20r0%2C%20rot_mul%2C%20rot_left_ident%2C%20rot_right_ident%20%E2%9F%A9%0A%0A--%20Finally%20we'll%20need%20a%20definition%20of%20npow%0Adef%20rot_npow%20%3A%20%E2%84%95%20%E2%86%92%20rot%20%E2%86%92%20rot%0A%7C%200%20x%20%3A%3D%201%0A%7C%20(nat.succ%20n')%20x%20%3A%3D%20rot_mul%20x%20(rot_npow%20n'%20x)" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_215.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">mul_one_class</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">has_one</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">has_mul</span>

<span class="c">/-</span>
<span class="cm">class mul_one_class (M : Type u) extends has_one M, has_mul M :=</span>
<span class="cm">(one_mul : &#8704; (a : M), 1 * a = a)</span>
<span class="cm">(mul_one : &#8704; (a : M), a * 1 = a)</span>

<span class="cm">class has_one      (&#945; : Type u) := (one : &#945;)</span>
<span class="cm">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">rot</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">r0</span> <span class="o">&#10217;</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">mul_one_class.mk</span>
<span class="c">/-</span>
<span class="cm"> &#928; {M : Type u}</span>
<span class="cm">   (one : M)</span>
<span class="cm">   (mul : M &#8594; M &#8594; M),</span>
<span class="cm">   (&#8704; (a : M), 1 * a = a) &#8594;</span>
<span class="cm">   (&#8704; (a : M), a * 1 = a) &#8594;</span>
<span class="cm">  mul_one_class M</span>
<span class="cm">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_one_class</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span> <span class="n">r0</span><span class="o">,</span> <span class="n">rot_mul</span><span class="o">,</span> <span class="n">rot_left_ident</span><span class="o">,</span> <span class="n">rot_right_ident</span> <span class="o">&#10217;</span>

<span class="c1">-- Finally we&#39;ll need a definition of npow</span>
<span class="kd">def</span> <span class="n">rot_npow</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">rot</span> <span class="bp">&#8594;</span> <span class="n">rot</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rot_mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">rot_npow</span> <span class="n">n&#39;</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Yay. We can now assemble our monoid instance.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40monoid.mk%0A%2F-%0A%CE%A0%20%7BM%20%3A%20Type%20u_1%7D%0A%20%20(mul%20%3A%20M%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20(%E2%88%80%20(a%20b%20c%20%3A%20M)%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%20%E2%86%92%0A%20%20%CE%A0%20(one%20%3A%20M)%0A%20%20%20%20(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%201%20*%20a%20%3D%20a)%0A%20%20%20%20(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%20a%20*%201%20%3D%20a)%0A%20%20%20%20(npow%20%3A%20%E2%84%95%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20%20%20--%20synthesized%20parameters%0A%20%20%20%20auto_param%20(%E2%88%80%20(x%20%3A%20M)%2C%20npow%200%20x%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20M)%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20monoid%0A-%2F%0Ainstance%20%3A%20monoid%20rot%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_mul%2C%0A%20%20rot_mul_assoc%2C%0A%20%201%2C%0A%20%20rot_left_ident%2C%0A%20%20rot_right_ident%2C%0A%20%20rot_npow%2C%0A%E2%9F%A9%0A%0A--%20Synthesized%20fields%0A%23check%20monoid.npow_zero'%0A%23reduce%20monoid.npow_succ'" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_249.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">monoid.mk</span>
<span class="c">/-</span>
<span class="cm">&#928; {M : Type u_1}</span>
<span class="cm">  (mul : M &#8594; M &#8594; M),</span>
<span class="cm">  (&#8704; (a b c : M), a * b * c = a * (b * c)) &#8594;</span>
<span class="cm">  &#928; (one : M)</span>
<span class="cm">    (one_mul : &#8704; (a : M), 1 * a = a)</span>
<span class="cm">    (mul_one : &#8704; (a : M), a * 1 = a)</span>
<span class="cm">    (npow : &#8469; &#8594; M &#8594; M),</span>
<span class="cm">    -- synthesized parameters</span>
<span class="cm">    auto_param (&#8704; (x : M), npow 0 x = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (x : M), npow n.succ x = x * npow n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">  monoid</span>
<span class="cm">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_mul</span><span class="o">,</span>
  <span class="n">rot_mul_assoc</span><span class="o">,</span>
  <span class="mi">1</span><span class="o">,</span>
  <span class="n">rot_left_ident</span><span class="o">,</span>
  <span class="n">rot_right_ident</span><span class="o">,</span>
  <span class="n">rot_npow</span><span class="o">,</span>
<span class="o">&#10217;</span>

<span class="c1">-- Synthesized fields</span>
<span class="k">#check</span> <span class="n">monoid.npow_zero&#39;</span>
<span class="k">#reduce</span> <span class="n">monoid.npow_succ&#39;</span>
</pre></div>
</div>
</div></section>
<section id="what-we-get">
<h3><span class="section-number">6.1.9. </span>What we get<a class="headerlink" href="#what-we-get" title="Permalink to this heading">&#61633;</a></h3>
<p>Having defined the monoid of rotational symmetries of a
regular triangle, we can now use the notations (namely 1
and <a href="#id1"><span class="problematic" id="id2">*</span></a>) associated with the monoid identity and operator.
Second, we can now define another version of foldr that
takes a Lean monoid as an argument and extends its binary
operator to n-ary, taking an arbitrary number of arguments
in a list.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20Notations!%0A%23reduce%20(1%20%3A%20rot)%0A%23reduce%20(r120%20*%201)%0A%23reduce%20(r120%20*%20r120)%0A%0A--%20foldr%20using%20monoid%20notation%0Adef%20mul_foldr%20%7B%CE%B1%20%3A%20Type%7D%20%5Bmonoid%20%CE%B1%5D%20%3A%20list%20%CE%B1%20%E2%86%92%20%CE%B1%0A%7C%20%20list.nil%20%3A%3D%201%0A%7C%20(h%3A%3At)%20%3A%3D%20h%20*%20mul_foldr%20t%0A%0A%23reduce%20mul_foldr%20%5B%5D%0A%23reduce%20mul_foldr%20%5Br120%2Cr120%5D%0A%23reduce%20mul_foldr%20%5Br120%2Cr120%2Cr120%5D%0A%0A--%20we%20could%20also%20do%20this%2C%20as%20in%20the%20previous%20chapter%0Adef%20rot_comp_n%20%3A%3D%20%40mul_foldr%20rot%0A%23reduce%20rot_comp_n%20%5B%5D%0A%23reduce%20rot_comp_n%20%5Br120%2Cr120%5D%0A%23reduce%20rot_comp_n%20%5Br120%2Cr120%2Cr120%5D" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_290.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Notations!</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">rot</span><span class="o">)</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="n">r120</span> <span class="bp">*</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="n">r120</span> <span class="bp">*</span> <span class="n">r120</span><span class="o">)</span>

<span class="c1">-- foldr using monoid notation</span>
<span class="kd">def</span> <span class="n">mul_foldr</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">&#945;</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span>
<span class="bp">|</span>  <span class="n">list.nil</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span> <span class="bp">*</span> <span class="n">mul_foldr</span> <span class="n">t</span>

<span class="k">#reduce</span> <span class="n">mul_foldr</span> <span class="o">[]</span>
<span class="k">#reduce</span> <span class="n">mul_foldr</span> <span class="o">[</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">]</span>
<span class="k">#reduce</span> <span class="n">mul_foldr</span> <span class="o">[</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">]</span>

<span class="c1">-- we could also do this, as in the previous chapter</span>
<span class="kd">def</span> <span class="n">rot_comp_n</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">mul_foldr</span> <span class="n">rot</span>
<span class="k">#reduce</span> <span class="n">rot_comp_n</span> <span class="o">[]</span>
<span class="k">#reduce</span> <span class="n">rot_comp_n</span> <span class="o">[</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">]</span>
<span class="k">#reduce</span> <span class="n">rot_comp_n</span> <span class="o">[</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">]</span>
</pre></div>
</div>
</div><p>In conclusion, by define a Lean monoid typeclass instance
for our set of rotation-representing objects, rot, we
have obtained:</p>
<ul class="simple">
<li><p>a proven-consistent representation of this particular monoid</p></li>
<li><p>the ability to extend the monoid operator to an n-ary version</p></li>
<li><p>to do that using a &#8220;safe&#8221; (new) version of the foldr function</p></li>
<li><p>a complete, precise, abstract, computable definition of monoid</p></li>
</ul>
</section>
</section>
<section id="groups">
<h2><span class="section-number">6.2. </span>Groups<a class="headerlink" href="#groups" title="Permalink to this heading">&#61633;</a></h2>
<p>In this chapter, we&#8217;ll turn to a first study of groups.
Simply put, a group is an algebraic structure that includes
all of the structure of a monoid with the addition of an
inverse operator. This operator then makes it possible to
define the related notion of division in a group, defining
<em>div a b,</em> usually denoted (a / b), as <em>(mul a (inv b))</em>.
We&#8217;ll be particularly interested in viewing group elements,
of some type, &#945;, as specifying <em>actions</em> or <em>transformations</em>
of objects of some other (often the same) type, &#946;.</p>
<section id="examples">
<h3><span class="section-number">6.2.1. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">&#61633;</a></h3>
<p>As concrete examples let&#8217;s consider two groups, one whose
elements represent rotation actions that can be applied to
objects in some 3-D space, and one whose elements represent
translations (straight-line movements) of objects. We&#8217;ll
look at the concept of a rotation group first.</p>
<section id="rotation-groups">
<h4><span class="section-number">6.2.1.1. </span>Rotation groups<a class="headerlink" href="#rotation-groups" title="Permalink to this heading">&#61633;</a></h4>
<p>In this view, the multiplication operation of the group is
understood as <em>composing</em> actions. If <em>a1</em> and <em>a2</em> are two
rotations, for example, then <em>(a2 * a1)</em> is the overall
rotation that results when rotation <em>a1</em> is followed by
rotation <em>a2</em>. That every group also has the structure of
a monoid let&#8217;s us fold any arbitrary sequence of actions
to obtain a single resultant action, also in the group.</p>
<p>The inverse operation of the group is then understood as a
<em>undo</em> action, one for each and every action in the group.
If <em>a</em> is 90 degree counter-clockwise rotation in the 2-D
plane, for example, then <em>a&#8315;&#185;</em> is would be the 90 degree
<em>clockwise</em> rotation that undoes the effect of <em>a</em>. The
overall action, <em>a&#8315;&#185; * a,</em> is thus <em>e</em>, the action that
performs no rotation at all.</p>
</section>
<section id="translation-groups">
<h4><span class="section-number">6.2.1.2. </span>Translation groups<a class="headerlink" href="#translation-groups" title="Permalink to this heading">&#61633;</a></h4>
<p>As another example of a group, consider a vector space,
familiar from basic linear algebra. It is a group. The
elements are vectors. A vector, v, acts on an object, p,
by <em>translating</em> it through a straight-line motion by a
distance, and in the direction, of v. Vector addition is
the (additive) group operator, so <em>v2 + v1</em> is the action
that has the effect of translating an object by v1 then
by v2. The zero vector is the group identity that leaves
objects unchanged. Finally, the (additive) inverse, -v,
of a vector, v, undoes the action of v so that the effect
of v + (-v), usually written v - v, does no translation
at all. It&#8217;s the zero vector.</p>
</section>
<section id="chapter-plan">
<h4><span class="section-number">6.2.1.3. </span>Chapter plan<a class="headerlink" href="#chapter-plan" title="Permalink to this heading">&#61633;</a></h4>
<p>In the rest of this chapter, we&#8217;ll work out an extended
example of a formal specification of, and of computation
involving, a small, discrete, finite group, namely the
group of <em>rotational symmetries</em> of an equilateral triangle,
In the first section, we&#8217;ll formalize the rotation group
itself. In the second section, we&#8217;ll formalize the group
action, of rotations on (representations of) equilateral
triangles.</p>
<p>A rotation of this kind rotates an equilateral triangle by
an amount that makes the resulting triang sit right on top
of the original equilateral triangle. These are rotations
by 0, 120, and 240 degrees. There are no other rotational
symmetries of such a triangle.</p>
<p>A group structure on a collection of objects of a given
type, &#945;, is (typically) specified in Lean by instantiating
the <em>group</em> typeclass for &#945;. The group typeclass extends
from several parent typclasses, including monoid, which
reflects the fact that every group with its operator and
identity also satisfies the monoid axioms.</p>
<p>We&#8217;ll use the same method as in the last section to analyze
and then provide the values needed to instantiate the group
typeclass for a new type, with three values, representing the
set of symmetry rotations. We&#8217;ll start top-down, with Lean&#8217;s
group typeclass, see what typeclasses it extends, and then
construct the elements needed to instantiate all of these
typeclasses, finally assembing all of these pieces into a
group typeclass instance for our set of rotation-representing
group elements.</p>
</section>
</section>
<section id="typeclasses">
<h3><span class="section-number">6.2.2. </span>Typeclasses<a class="headerlink" href="#typeclasses" title="Permalink to this heading">&#61633;</a></h3>
<p>In this section we&#8217;ll go over the numerous typeclasses that
have to be instantiated before the group class can be.</p>
<section id="group">
<h4><span class="section-number">6.2.2.1. </span>group<a class="headerlink" href="#group" title="Permalink to this heading">&#61633;</a></h4>
<p>Here&#8217;s the definition of the group typeclass in Lean.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40group%0A%2F-%0Aclass%20group%20(G%20%3A%20Type%20u)%20extends%20div_inv_monoid%20G%20%3A%3D%0A(mul_left_inv%20%3A%20%E2%88%80%20a%20%3A%20G%2C%20a%E2%81%BB%C2%B9%20*%20a%20%3D%201)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_114.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">group</span>
<span class="c">/-</span>
<span class="cm">class group (G : Type u) extends div_inv_monoid G :=</span>
<span class="cm">(mul_left_inv : &#8704; a : G, a&#8315;&#185; * a = 1)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>Every group is a monoid but with some additional structure,
namely inverses for every element. Inverses in turn enable
the definition division (multiplication by inverse) and the
definition of exponentiation of an element to integer powers,
including negatives.</p>
<p>[KS: Bothered by mismatch between hierarchy as taught in
school and the weirdly refactored abstractions we&#8217;re seeing
here.]</p>
</section>
<section id="monoid">
<h4><span class="section-number">6.2.2.2. </span>monoid<a class="headerlink" href="#monoid" title="Permalink to this heading">&#61633;</a></h4>
<p>In Lean, the statement that every group is automatically
a monoid means a few things. First, the group typeclass
builds on (<em>extends</em>) monoid. Second, given  group typeclass
instance it will always be possible to extract from it a
monoid instance.</p>
<p>As something of a detailed design detail, In Lean, the
group class doesn&#8217;t extend from monoid directly. Rather
it extends a typeclass call div_inv_monoid, representing
a monoid enriched with an inverse operation that behaves
like one, and a division operation defined simply as
(monoid) multiplication/composition by the inverse of
the second argument.</p>
</section>
<section id="div-inv-monoid">
<h4><span class="section-number">6.2.2.3. </span>div_inv_monoid<a class="headerlink" href="#div-inv-monoid" title="Permalink to this heading">&#61633;</a></h4>
<p>An instance of <em>div_inv_monoid &#945;</em> provides</p>
<ul class="simple">
<li><p>inv: binary operation, a&#8315;&#185;, from has_inv</p></li>
<li><p>div: definition of a / b to be a * b&#8315;&#185;</p></li>
<li><p>div_eq_mul_inv: proof of &#8704; a b : G, a / b = a * b&#8315;&#185;</p></li>
<li><p>left inverse: multiplying by inverse on left yields 1 <em>(&#8704; a, a&#8315;&#185; * a = 1)</em></p></li>
</ul>
<p>, implements a&#8315;&#185; inverse operation</p>
<p>We will now drill down on the div_inv_monoid typeclass.</p>
<p>As a reminder, here it is again. We&#8217;ll first look at the
classes it inherits, and then the field it adds to those
from its parent classes.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0Aclass%20div_inv_monoid%20(G%20%3A%20Type%20u)%20extends%20monoid%20G%2C%20has_inv%20G%2C%20has_div%20G%20%3A%3D%0A(div%20%3A%3D%20%CE%BB%20a%20b%2C%20a%20*%20b%E2%81%BB%C2%B9)%0A(div_eq_mul_inv%20%3A%20%E2%88%80%20a%20b%20%3A%20G%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9%20.%20try_refl_tac)%0A(zpow%20%3A%20%E2%84%A4%20%E2%86%92%20G%20%E2%86%92%20G%20%3A%3D%20zpow_rec)%0A(zpow_zero'%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%20zpow%200%20a%20%3D%201%20.%20try_refl_tac)%0A(zpow_succ'%20%3A%0A%20%20%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20zpow%20(int.of_nat%20n)%20a%20.%20try_refl_tac)%0A(zpow_neg'%20%3A%0A%20%20%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(-%5B1%20%2B%20n%5D)%20a%20%3D%20(zpow%20n.succ%20a)%E2%81%BB%C2%B9%20.%20try_refl_tac)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_167.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">class div_inv_monoid (G : Type u) extends monoid G, has_inv G, has_div G :=</span>
<span class="cm">(div := &#955; a b, a * b&#8315;&#185;)</span>
<span class="cm">(div_eq_mul_inv : &#8704; a b : G, a / b = a * b&#8315;&#185; . try_refl_tac)</span>
<span class="cm">(zpow : &#8484; &#8594; G &#8594; G := zpow_rec)</span>
<span class="cm">(zpow_zero&#39; : &#8704; (a : G), zpow 0 a = 1 . try_refl_tac)</span>
<span class="cm">(zpow_succ&#39; :</span>
<span class="cm">  &#8704; (n : &#8469;) (a : G), zpow (int.of_nat n.succ) a = a * zpow (int.of_nat n) a . try_refl_tac)</span>
<span class="cm">(zpow_neg&#39; :</span>
<span class="cm">  &#8704; (n : &#8469;) (a : G), zpow (-[1 + n]) a = (zpow n.succ a)&#8315;&#185; . try_refl_tac)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>This typeclass extends from the monoid, has_inv, and has_div classes
and then adds several additional fields. Let&#8217;s first see what fields
div_inv_monoid inherits from its parent classes.</p>
<p>From <em>monoid</em>, div_inv_monoid inherits the following:</p>
<ul class="simple">
<li><p>mul, an associative binary operator, with notation (a * b)</p></li>
<li><p>e, an identity element for mul, with notation 1</p></li>
<li><p>npow, for computing a&#8319; by multiplication of a by itself n times</p></li>
<li><p>npow_zero&#8217;, a proof that a&#8304; = 1</p></li>
<li><p>npow_succ&#8217;, a proof that npow n a is multiplication iterated n times (&#8704; (n : &#8469;) x, npow n.succ x = x * npow n x . try_refl_tac))</p></li>
</ul>
<p>From <em>has_inv</em>, div_inv_monoid inherits a single unary operator,
inv (for inverse), for monoid elements, wotj the notation, a&#8315;&#185;.
From the has_div class, div_inv_monoid obtains a single binary
operation, div, with notation (a / b) for (div a b).  So far, then,
a div_inv_monoid instance will provide operators and notations for
multiplication, exponentiation by a natural number, inverse, and
division for monoid elements.</p>
<p>The div_inv_monoid class then adds multiple fields values to
extend and constrain this inherited structure. Let&#8217;s look at each
of these fields in turn.</p>
<ul class="simple">
<li><p>div, defining (a / b) as a * b&#8315;&#185;</p></li>
<li><p>div_eq_mul_inv, requiring that division be multiplication by inverse</p></li>
<li><p>zpow, which generalizes exponentiation to include negative exponents</p></li>
<li><p>a proof of (&#8704; (x : rot), rot_npow 0 x = 1)</p></li>
<li><p>a proof of (&#8704; (n : &#8469;) (x : rot), rot_npow n.succ x = x * rot_npow n x)</p></li>
<li><p>a proof of (&#8704; (a b : rot), a / b = a * b&#8315;&#185;)</p></li>
<li><p>a proof of (&#8704; (n : &#8469;) (a : rot), rot_zpow (int.of_nat n.succ) a = a * rot_zpow (int.of_nat n) a) :=</p></li>
<li><p>a proof of (&#8704; (n : &#8469;) (a : rot), rot_zpow -[1+ n] a = (rot_zpow &#8593;(n.succ) a)&#8315;&#185;)</p></li>
</ul>
<p>Finally, to all of this structure the <em>group</em> typeclass adds one
additional constraint, (mul_left_inv : &#8704; a : G, a&#8315;&#185; * a = 1), which
requires that inv and mul work together correctly, in the sense that
for any monoid element, a, that mul (inv a) a = 1. We can say that
it requires a&#8315;&#185; to always act as a <em>left inverse</em> for any <em>a</em>.</p>
<p>To create a group typeclass instance, we need to instantiate the
parent typeclasses and then apply the group typeclass constructor
to the right arguments. We will now construct a group typeclass
instance for rot in a bottom-up manner, first constructing
instances for the parent typeclasses and finally instantiating
the group typeclass.</p>
<p>To see what values have to be given to a typeclass constructor,
you can #check the constructor type. So let&#8217;s now do this for
the parent typeclasses, starting with has_inv and has_div, then
for div_inv_monoid, and finally for group.</p>
<p>We&#8217;ll tackle has_inv first. We check the constructor type to
see what arguments it needs. Then we construct the right
argument values: in this case an implementation of inverse
(inv) for rot in particular. And finally we instantiate
the typeclass.</p>
</section>
<section id="has-inv">
<h4><span class="section-number">6.2.2.4. </span>has_inv<a class="headerlink" href="#has-inv" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40has_inv%0A%23check%20%40has_inv.mk%0A%2F-%0A%CE%A0%20%7B%CE%B1%20%3A%20Type%20u%7D%2C%20(%CE%B1%20%E2%86%92%20%CE%B1)%20%E2%86%92%20has_inv%20%CE%B1%0A%0AThe%20has_inv%20typeclass%20requires%20an%20implementation%0Aof%20a%20unary%20operation%2C%20inv%2C%20on%20%CE%B1%2C%20and%20provides%20a%E2%81%BB%C2%B9%0Aas%20a%20standard%20mathematical%20notation.%20It%20does%20not%0Aconstrain%20the%20behavior%20of%20inv%20in%20any%20way%2C%20leaving%0Athat%20task%20to%20downstream%20typeclasses%20that%20inherit%0Afrom%20this%20one.%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_242.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">has_inv</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">has_inv.mk</span>
<span class="c">/-</span>
<span class="cm">&#928; {&#945; : Type u}, (&#945; &#8594; &#945;) &#8594; has_inv &#945;</span>

<span class="cm">The has_inv typeclass requires an implementation</span>
<span class="cm">of a unary operation, inv, on &#945;, and provides a&#8315;&#185;</span>
<span class="cm">as a standard mathematical notation. It does not</span>
<span class="cm">constrain the behavior of inv in any way, leaving</span>
<span class="cm">that task to downstream typeclasses that inherit</span>
<span class="cm">from this one.</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
</section>
<section id="instances">
<h3><span class="section-number">6.2.3. </span>Instances<a class="headerlink" href="#instances" title="Permalink to this heading">&#61633;</a></h3>
<p>We&#8217;ll build the required instances to enable construction
of a group typeclass instance for elements of type rot.</p>
<section id="has-inv-rot">
<h4><span class="section-number">6.2.3.1. </span>has_inv rot<a class="headerlink" href="#has-inv-rot" title="Permalink to this heading">&#61633;</a></h4>
<p>To instantiate has_inv, we have to provide an implementation
of this operation for arguments of type rot. Once we have
that, the rest is straightforward. We&#8217;ll call our overloaded
implementation function, rot_inv. We define the function by
case analysis on the rot argument, returning in each case
the rot value that when multiplied by the argument returns
1.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20rot%0Adef%20rot_inv%20%3A%20rot%20%E2%86%92%20rot%20%20%20%20%20%20%20%20%20%20%20--%20HOMEWORK%0A%7C%20r0%20%3A%3D%20r0%0A%7C%20r120%20%3A%3D%20r240%0A%7C%20r240%20%3A%3D%20r120%0A%0Ainstance%20%3A%20has_inv%20rot%20%3A%3D%20%E2%9F%A8%20rot_inv%20%E2%9F%A9%20%20--%20%E2%9F%A8%20%E2%9F%A9%20applies%20mk%0A%0A--%20example%2C%20cool!%0A%23reduce%20r120%5E2" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_276.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">rot</span>
<span class="kd">def</span> <span class="n">rot_inv</span> <span class="o">:</span> <span class="n">rot</span> <span class="bp">&#8594;</span> <span class="n">rot</span>           <span class="c1">-- HOMEWORK</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="o">:=</span> <span class="n">r120</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="n">rot</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">rot_inv</span> <span class="o">&#10217;</span>  <span class="c1">-- &#10216; &#10217; applies mk</span>

<span class="c1">-- example, cool!</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">^</span><span class="mi">2</span>
</pre></div>
</div>
</div><p>Instantiating has_inv gives us the &#8315;&#185; notation,
which we can use to assert that multiplying on
the left by the inverse always yields the identity.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20(r%20%3A%20rot)%2C%20(r%E2%81%BB%C2%B9%20*%20r%20%3D%201)%20%3A%3D%0Abegin%0Aassume%20r%2C%0Acases%20r%2C%0Arepeat%20%7Bexact%20rfl%2C%20%7D%2C%0Aend" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_293.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span><span class="bp">&#8315;&#185;</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">r</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">r</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Next we do the same thing for has_div: (1) define a binary
operation, rot_div, to use in overloading the generic div
function for values of type rot; then (2) instantiate
the div typeclass using this value, which, among other things,
will provides (a / b) as a standard notation for a * b&#8315;&#185;
(which in turn of course desugars to mul a (inv b)).</p>
</section>
<section id="has-div-rot">
<h4><span class="section-number">6.2.3.2. </span>has_div rot<a class="headerlink" href="#has-div-rot" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20rot_div%20%3A%20rot%20%E2%86%92%20rot%20%E2%86%92%20rot%20%3A%3D%20%CE%BB%20a%20b%2C%20a%20*%20b%E2%81%BB%C2%B9%0Ainstance%20%3A%20has_div%20rot%20%3A%3D%20%E2%9F%A8%20rot_div%20%E2%9F%A9%0Aexample%20%3A%20r240%20%2F%20r240%20%3D%201%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_312.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">rot_div</span> <span class="o">:</span> <span class="n">rot</span> <span class="bp">&#8594;</span> <span class="n">rot</span> <span class="bp">&#8594;</span> <span class="n">rot</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">&#8315;&#185;</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_div</span> <span class="n">rot</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">rot_div</span> <span class="o">&#10217;</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">r240</span> <span class="bp">/</span> <span class="n">r240</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div></section>
<section id="div-inv-monoid-rot">
<h4><span class="section-number">6.2.3.3. </span>div_inv_monoid rot<a class="headerlink" href="#div-inv-monoid-rot" title="Permalink to this heading">&#61633;</a></h4>
<p>We now have typeclass instances for rot for each of the
typeclasses that div_inv_monoid extends. We now look at how
to instantiate div_inv_monoid for rot. We begin by looking
at the constructor for this typeclass. Here it is.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40div_inv_monoid.mk%0A%2F-%0Adiv_inv_monoid.mk%20%3A%0A%20%20%CE%A0%20--%20arguments%0A%20%20%20%20%7BG%20%3A%20Type%20u_1%7D%0A%20%20%20%20(mul%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20%20%20(mul_assoc%20%3A%20%E2%88%80%20(a%20b%20c%20%3A%20G)%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%0A%20%20%20%20(one%20%3A%20G)%0A%20%20%20%20(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%201%20*%20a%20%3D%20a)%0A%20%20%20%20(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%20a%20*%201%20%3D%20a)%0A%20%20%20%20(npow%20%3A%20%E2%84%95%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20%20%20(npow_zero'%20%3A%20auto_param%20(%E2%88%80%20(x%20%3A%20G)%2C%20npow%200%20x%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(npow_succ'%20%3A%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20G)%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(inv%20%3A%20G%20%E2%86%92%20G)%0A%20%20%20%20(div%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%2C%20%20--%20comma%0A%20%20%20%20auto_param%20(%E2%88%80%20(a%20b%20%3A%20G)%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%CE%A0%20(zpow%20%3A%20%E2%84%A4%20%E2%86%92%20G%20%E2%86%92%20G)%2C%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(a%20%3A%20G)%2C%20zpow%200%20a%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20zpow%20(int.of_nat%20n)%20a)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20-%5B1%2B%20n%5D%20a%20%3D%20(zpow%20%E2%86%91(n.succ)%20a)%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20div_inv_monoid%20G%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_327.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">div_inv_monoid.mk</span>
<span class="c">/-</span>
<span class="cm">div_inv_monoid.mk :</span>
<span class="cm">  &#928; -- arguments</span>
<span class="cm">    {G : Type u_1}</span>
<span class="cm">    (mul : G &#8594; G &#8594; G)</span>
<span class="cm">    (mul_assoc : &#8704; (a b c : G), a * b * c = a * (b * c))</span>
<span class="cm">    (one : G)</span>
<span class="cm">    (one_mul : &#8704; (a : G), 1 * a = a)</span>
<span class="cm">    (mul_one : &#8704; (a : G), a * 1 = a)</span>
<span class="cm">    (npow : &#8469; &#8594; G &#8594; G)</span>
<span class="cm">    (npow_zero&#39; : auto_param (&#8704; (x : G), npow 0 x = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (npow_succ&#39; : auto_param (&#8704; (n : &#8469;) (x : G), npow n.succ x = x * npow n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (inv : G &#8594; G)</span>
<span class="cm">    (div : G &#8594; G &#8594; G),  -- comma</span>
<span class="cm">    auto_param (&#8704; (a b : G), a / b = a * b&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">    &#928; (zpow : &#8484; &#8594; G &#8594; G),</span>
<span class="cm">      auto_param (&#8704; (a : G), zpow 0 a = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : G), zpow (int.of_nat n.succ) a = a * zpow (int.of_nat n) a) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : G), zpow -[1+ n] a = (zpow &#8593;(n.succ) a)&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">  div_inv_monoid G</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>From the constructor type we can see that we&#8217;ll need to provide
explicit argument values for mul, mul_assoc, one, one_mul, mul_one,
npow, npow_zero&#8217;, and npow_succ&#8217;, all which we already have from
our instantiation of the monoid typeclass. We&#8217;ll also need functions
for inv and div on rot elements, which we just produced. Finally
we&#8217;ll need an implementation of zpow along proofs that it&#8217;s behavior
satisfies certain axiom.</p>
<p>Let&#8217;s talk about zpow first. As you will recall, the npow function
computes a&#8319; (a multiplied by itself n times), where a is any monoid
element and n is any <em>natural number</em>, i.e., non-negative exponent
value. The zpow function, by contrast, computes a&#7611;, where z is any
integer value. If m is non-negative, then a&#7504; is just (npow m a) but
returning an integer. If m is negative, we define a&#7504; = 1 / a&#8315;&#7504;, as
in ordinary arithmetic. The division here is of course the monoid
div function.</p>
<p>We haven&#8217;t previously defined a function with integer inputs, nor
have we seen how the int type is defined in Lean. We will define
zpow by case analysis on its int argument, where the two cases
correspond to non-negative and negative values, respectively. To
prepare to define zpow, we need to understand the int type in more
details, so let&#8217;s do that next, ending with a definition of zpow.</p>
</section>
<section id="aside-int-type">
<h4><span class="section-number">6.2.3.4. </span>aside: int type<a class="headerlink" href="#aside-int-type" title="Permalink to this heading">&#61633;</a></h4>
<p>The integer type has two constructors. The first takes a natural
number, n, and returns it packaged up as an integer, int.of_nat n.
The second takes a natural number, n, and returns a term, namely
(int.neg_succ_of_nat n), representing -(n+1).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20int%0A%2F-%0Ainductive%20int%20%3A%20Type%0A%7C%20of_nat%20%3A%20nat%20%E2%86%92%20int%0A%7C%20neg_succ_of_nat%20%3A%20nat%20%E2%86%92%20int%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_384.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">int</span>
<span class="c">/-</span>
<span class="cm">inductive int : Type</span>
<span class="cm">| of_nat : nat &#8594; int</span>
<span class="cm">| neg_succ_of_nat : nat &#8594; int</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>Example will help. First, (int.of_nat 3) represents the <em>integer,</em>
not the natural number, 3. Second, the term, (int.neg_succ_of_nat n),
represents the integer, -(n+1), so (int.neg_succ_of_nat 0) represents
-1, while (int.neg_succ_of_nat 4) represents the integer value, -5.
Admittedly the constructors seem strange at first, but they do provide
one term for each and every integer. The +1 in the second assures that
we don&#8217;t end up with two distinct representations of 0.</p>
<p>In any case, we can now define zpow for rot by case analysis on
the <em>int</em> argument. The only remaining question is what to do in each
case.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20an%20example%0A%0Adef%20isNeg%20%3A%20%E2%84%A4%20%E2%86%92%20bool%0A%7C%20(int.of_nat%20n)%20%3A%3D%20ff%0A%7C%20(int.neg_succ_of_nat%20n)%20%3A%3D%20tt%0A%23eval%20isNeg%20(-5%20%3A%20int)%0A%0A%0A--%20hint%3A%20think%20about%20rot_npow%20from%20monoid%0Adef%20rot_zpow%20%3A%20%E2%84%A4%20%E2%86%92%20rot%20%E2%86%92%20rot%0A%7C%20(int.of_nat%20n)%20r%20%3A%3D%20rot_npow%20n%20r%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20HOMEWORK%0A%7C%20(int.neg_succ_of_nat%20n)%20r%20%3A%3D%20(rot_npow%20(n%2B1)%20r)%E2%81%BB%C2%B9%20%20%20--%20HOMEWORK%0A%0A%23reduce%20rot_zpow%20(-2%3A%E2%84%A4)%20r240%20--%20yay!%20expect%20240" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_405.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- an example</span>

<span class="kd">def</span> <span class="n">isNeg</span> <span class="o">:</span> <span class="n">&#8484;</span> <span class="bp">&#8594;</span> <span class="n">bool</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int.of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">ff</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int.neg_succ_of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">tt</span>
<span class="k">#eval</span> <span class="n">isNeg</span> <span class="o">(</span><span class="bp">-</span><span class="mi">5</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span>


<span class="c1">-- hint: think about rot_npow from monoid</span>
<span class="kd">def</span> <span class="n">rot_zpow</span> <span class="o">:</span> <span class="n">&#8484;</span> <span class="bp">&#8594;</span> <span class="n">rot</span> <span class="bp">&#8594;</span> <span class="n">rot</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int.of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">rot_npow</span> <span class="n">n</span> <span class="n">r</span>                    <span class="c1">-- HOMEWORK</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int.neg_succ_of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">(</span><span class="n">rot_npow</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span><span class="bp">&#8315;&#185;</span>   <span class="c1">-- HOMEWORK</span>

<span class="k">#reduce</span> <span class="n">rot_zpow</span> <span class="o">(</span><span class="bp">-</span><span class="mi">2</span><span class="o">:</span><span class="n">&#8484;</span><span class="o">)</span> <span class="n">r240</span> <span class="c1">-- yay! expect 240</span>
</pre></div>
</div>
</div><p>We now have all the building blocks needed to assemble
an instance of div_inv_monoid for objects of type rot.
Here&#8217;s the constructor type, again. Lean will infer values
of each field marked as auto_param, so when applying the
constructor, just use _ for each of these field values.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20just%20to%20be%20explicit%2C%20we%20already%20have%20the%20following%20two%20proofs%0Alemma%20rot_npow_zero%20%3A%20(%E2%88%80%20(x%20%3A%20rot)%2C%20rot_npow%200%20x%20%3D%201)%20%3A%3D%0A%20%20%20monoid.npow_zero'%0A%0Alemma%20rot_npow_succ%20%3A%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20rot)%2C%20rot_npow%20n.succ%20x%20%3D%20x%20*%20rot_npow%20n%20x)%20%3A%3D%0A%20%20monoid.npow_succ'%0A%0A--%20We%20need%20related%20proofs%20linking%20div%20and%20inv%20and%20proofs%20of%20axioms%20for%20zpow%0Alemma%20rot_div_inv%20%3A%20(%E2%88%80%20(a%20b%20%3A%20rot)%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9)%20%3A%3D%0Abegin%0Aassume%20a%20b%2C%0Aexact%20rfl%2C%0Aend%0A%0Alemma%20rot_zpow_non_neg%20%3A%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20rot)%2C%20rot_zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20rot_zpow%20(int.of_nat%20n)%20a)%20%3A%3D%0Abegin%0Aassume%20n%20a%2C%0Aexact%20rfl%2C%0Aend%0A%0Adef%20rot_zpow_neg%20%3A%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20rot)%2C%20rot_zpow%20-%5B1%2B%20n%5D%20a%20%3D%20(rot_zpow%20%E2%86%91(n.succ)%20a)%E2%81%BB%C2%B9)%20%3A%3D%0Abegin%0Aassume%20n%20a%2C%0Aexact%20rfl%2C%0Aend%0A%0A%23check%20%40div_inv_monoid.mk%0A%2F-%0Adiv_inv_monoid.mk%20%3A%0A%20%20%CE%A0%20--%20arguments%0A%20%20%20%20%7BG%20%3A%20Type%20u_1%7D%0A%20%20%20%20(mul%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20%20%20(mul_assoc%20%3A%20%E2%88%80%20(a%20b%20c%20%3A%20G)%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%0A%20%20%20%20(one%20%3A%20G)%0A%20%20%20%20(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%201%20*%20a%20%3D%20a)%0A%20%20%20%20(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%20a%20*%201%20%3D%20a)%0A%20%20%20%20(npow%20%3A%20%E2%84%95%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20%20%20(npow_zero'%20%3A%20auto_param%20(%E2%88%80%20(x%20%3A%20G)%2C%20npow%200%20x%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(npow_succ'%20%3A%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20G)%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(inv%20%3A%20G%20%E2%86%92%20G)%0A%20%20%20%20(div%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%2C%20%20--%20comma%0A%20%20%20%20auto_param%20(%E2%88%80%20(a%20b%20%3A%20G)%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%CE%A0%20(zpow%20%3A%20%E2%84%A4%20%E2%86%92%20G%20%E2%86%92%20G)%2C%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(a%20%3A%20G)%2C%20zpow%200%20a%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20zpow%20(int.of_nat%20n)%20a)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20-%5B1%2B%20n%5D%20a%20%3D%20(zpow%20%E2%86%91(n.succ)%20a)%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20div_inv_monoid%20G%0A-%2F%0A%0A%23check%20rot_npow%0A%0Ainstance%20rot_div_inv_monoid%20%3A%20div_inv_monoid%20rot%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_mul%2C%0A%20%20rot_mul_assoc%2C%0A%20%201%2C%0A%20%20rot_left_ident%2C%0A%20%20rot_right_ident%2C%0A%20%20rot_npow%2C%0A%20%20rot_npow_zero%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20autoparam%0A%20%20rot_npow_succ%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20autoparam%0A%20%20rot_inv%2C%0A%20%20rot_div%2C%0A%20%20rot_div_inv%2C%0A%20%20rot_zpow%0A%E2%9F%A9%0A%0A%2F-%0ANow%20we%20can%20see%20the%20structure%20we've%20built!%0AThe%20proofs%20are%20erased%20in%20this%20presentation%0Aand%20only%20the%20computational%20data%20are%20named.%0A-%2F%0A%23reduce%20%40rot_div_inv_monoid" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_430.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- just to be explicit, we already have the following two proofs</span>
<span class="kd">lemma</span> <span class="n">rot_npow_zero</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">rot_npow</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
   <span class="n">monoid.npow_zero&#39;</span>

<span class="kd">lemma</span> <span class="n">rot_npow_succ</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">rot_npow</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">rot_npow</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">monoid.npow_succ&#39;</span>

<span class="c1">-- We need related proofs linking div and inv and proofs of axioms for zpow</span>
<span class="kd">lemma</span> <span class="n">rot_div_inv</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">&#8315;&#185;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">rot_zpow_non_neg</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">rot_zpow</span> <span class="o">(</span><span class="n">int.of_nat</span> <span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">rot_zpow</span> <span class="o">(</span><span class="n">int.of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">rot_zpow_neg</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">rot_zpow</span> <span class="bp">-</span><span class="o">[</span><span class="mi">1</span><span class="bp">+</span> <span class="n">n</span><span class="o">]</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">rot_zpow</span> <span class="bp">&#8593;</span><span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span><span class="bp">&#8315;&#185;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">div_inv_monoid.mk</span>
<span class="c">/-</span>
<span class="cm">div_inv_monoid.mk :</span>
<span class="cm">  &#928; -- arguments</span>
<span class="cm">    {G : Type u_1}</span>
<span class="cm">    (mul : G &#8594; G &#8594; G)</span>
<span class="cm">    (mul_assoc : &#8704; (a b c : G), a * b * c = a * (b * c))</span>
<span class="cm">    (one : G)</span>
<span class="cm">    (one_mul : &#8704; (a : G), 1 * a = a)</span>
<span class="cm">    (mul_one : &#8704; (a : G), a * 1 = a)</span>
<span class="cm">    (npow : &#8469; &#8594; G &#8594; G)</span>
<span class="cm">    (npow_zero&#39; : auto_param (&#8704; (x : G), npow 0 x = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (npow_succ&#39; : auto_param (&#8704; (n : &#8469;) (x : G), npow n.succ x = x * npow n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (inv : G &#8594; G)</span>
<span class="cm">    (div : G &#8594; G &#8594; G),  -- comma</span>
<span class="cm">    auto_param (&#8704; (a b : G), a / b = a * b&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">    &#928; (zpow : &#8484; &#8594; G &#8594; G),</span>
<span class="cm">      auto_param (&#8704; (a : G), zpow 0 a = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : G), zpow (int.of_nat n.succ) a = a * zpow (int.of_nat n) a) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : G), zpow -[1+ n] a = (zpow &#8593;(n.succ) a)&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">  div_inv_monoid G</span>
<span class="cm">-/</span>

<span class="k">#check</span> <span class="n">rot_npow</span>

<span class="kd">instance</span> <span class="n">rot_div_inv_monoid</span> <span class="o">:</span> <span class="n">div_inv_monoid</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_mul</span><span class="o">,</span>
  <span class="n">rot_mul_assoc</span><span class="o">,</span>
  <span class="mi">1</span><span class="o">,</span>
  <span class="n">rot_left_ident</span><span class="o">,</span>
  <span class="n">rot_right_ident</span><span class="o">,</span>
  <span class="n">rot_npow</span><span class="o">,</span>
  <span class="n">rot_npow_zero</span><span class="o">,</span>                <span class="c1">-- autoparam</span>
  <span class="n">rot_npow_succ</span><span class="o">,</span>                <span class="c1">-- autoparam</span>
  <span class="n">rot_inv</span><span class="o">,</span>
  <span class="n">rot_div</span><span class="o">,</span>
  <span class="n">rot_div_inv</span><span class="o">,</span>
  <span class="n">rot_zpow</span>
<span class="o">&#10217;</span>

<span class="c">/-</span>
<span class="cm">Now we can see the structure we&#39;ve built!</span>
<span class="cm">The proofs are erased in this presentation</span>
<span class="cm">and only the computational data are named.</span>
<span class="cm">-/</span>
<span class="k">#reduce</span> <span class="bp">@</span><span class="n">rot_div_inv_monoid</span>
</pre></div>
</div>
</div></section>
<section id="group-rot">
<h4><span class="section-number">6.2.3.5. </span>group rot<a class="headerlink" href="#group-rot" title="Permalink to this heading">&#61633;</a></h4>
<p>And now, finally, we can instantiate the group class
for rot elements.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20group%0A%2F-%0Aclass%20group%20(G%20%3A%20Type%20u)%20extends%20div_inv_monoid%20G%20%3A%3D%0A(mul_left_inv%20%3A%20%E2%88%80%20a%20%3A%20G%2C%20a%E2%81%BB%C2%B9%20*%20a%20%3D%201)%0A-%2F%0A%23check%20%40group.mk%0A%2F-%0A%CE%A0%20%7BG%20%3A%20Type%20u_1%7D%0A%20%20(mul%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20(mul_assoc%20%3A%20%E2%88%80%20(a%20b%20c%20%3A%20G)%2C%0A%20%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%0A%20%20(one%20%3A%20G)%0A%20%20(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%201%20*%20a%20%3D%20a)%0A%20%20(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%20a%20*%201%20%3D%20a)%0A%20%20(npow%20%3A%20%E2%84%95%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20(npow_zero'%20%3A%20auto_param%20(%E2%88%80%20(x%20%3A%20G)%2C%20npow%200%20x%20%3D%201)%0A%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(npow_succ'%20%3A%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20G)%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(inv%20%3A%20G%20%E2%86%92%20G)%20(div%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20(div_eq_mul_inv%20%3A%20auto_param%20(%E2%88%80%20(a%20b%20%3A%20G)%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(zpow%20%3A%20%E2%84%A4%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20(zpow_zero'%20%3A%20auto_param%20(%E2%88%80%20(a%20%3A%20G)%2C%20zpow%200%20a%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(zpow_succ'%20%3A%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20zpow%20(int.of_nat%20n)%20a)%0A%20%20%20%20%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(zpow_neg'%20%3A%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20-%5B1%2B%20n%5D%20a%20%3D%20(zpow%20%E2%86%91(n.succ)%20a)%E2%81%BB%C2%B9)%0A%20%20%20%20%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%2C%20(%E2%88%80%20(a%20%3A%20G)%2C%20a%E2%81%BB%C2%B9%20*%20a%20%3D%201)%20%E2%86%92%0A%20%20group%20G%0A-%2F%0A%0Alemma%20rot_left_inv%20%3A%20(%E2%88%80%20(a%20%3A%20rot)%2C%20a%E2%81%BB%C2%B9%20*%20a%20%3D%201)%20%3A%3D%0Abegin%0Aassume%20a%2C%0Acases%20a%2C%0Arepeat%20%7Bexact%20rfl%7D%2C%0Aend%0A%0A%0Ainstance%20rot_group%20%3A%20group%20rot%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_mul%2C%0A%20%20rot_mul_assoc%2C%0A%20%201%2C%0A%20%20rot_left_ident%2C%0A%20%20rot_right_ident%2C%0A%20%20rot_npow%2C%0A%20%20rot_npow_zero%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20autoparam%0A%20%20rot_npow_succ%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20autoparam%0A%20%20rot_inv%2C%0A%20%20rot_div%2C%0A%20%20rot_div_inv%2C%0A%20%20rot_zpow%2C%0A%20%20rot_npow_zero%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20same%20proof%20again%0A%20%20rot_zpow_non_neg%2C%20%20%20%20%20%20%20%20%20%20%20%20%20--%20explicit%20typing%20needed%0A%20%20rot_zpow_neg%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20same%0A%20%20rot_left_inv%0A%E2%9F%A9" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_514.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">group</span>
<span class="c">/-</span>
<span class="cm">class group (G : Type u) extends div_inv_monoid G :=</span>
<span class="cm">(mul_left_inv : &#8704; a : G, a&#8315;&#185; * a = 1)</span>
<span class="cm">-/</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">group.mk</span>
<span class="c">/-</span>
<span class="cm">&#928; {G : Type u_1}</span>
<span class="cm">  (mul : G &#8594; G &#8594; G)</span>
<span class="cm">  (mul_assoc : &#8704; (a b c : G),</span>
<span class="cm">  a * b * c = a * (b * c))</span>
<span class="cm">  (one : G)</span>
<span class="cm">  (one_mul : &#8704; (a : G), 1 * a = a)</span>
<span class="cm">  (mul_one : &#8704; (a : G), a * 1 = a)</span>
<span class="cm">  (npow : &#8469; &#8594; G &#8594; G)</span>
<span class="cm">  (npow_zero&#39; : auto_param (&#8704; (x : G), npow 0 x = 1)</span>
<span class="cm">  (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (npow_succ&#39; :</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (x : G), npow n.succ x = x * npow n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (inv : G &#8594; G) (div : G &#8594; G &#8594; G)</span>
<span class="cm">  (div_eq_mul_inv : auto_param (&#8704; (a b : G), a / b = a * b&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (zpow : &#8484; &#8594; G &#8594; G)</span>
<span class="cm">  (zpow_zero&#39; : auto_param (&#8704; (a : G), zpow 0 a = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (zpow_succ&#39; :</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (a : G), zpow (int.of_nat n.succ) a = a * zpow (int.of_nat n) a)</span>
<span class="cm">      (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (zpow_neg&#39; :</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (a : G), zpow -[1+ n] a = (zpow &#8593;(n.succ) a)&#8315;&#185;)</span>
<span class="cm">      (name.mk_string &quot;try_refl_tac&quot; name.anonymous)), (&#8704; (a : G), a&#8315;&#185; * a = 1) &#8594;</span>
<span class="cm">  group G</span>
<span class="cm">-/</span>

<span class="kd">lemma</span> <span class="n">rot_left_inv</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">a</span><span class="bp">&#8315;&#185;</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
<span class="kd">end</span>


<span class="kd">instance</span> <span class="n">rot_group</span> <span class="o">:</span> <span class="n">group</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_mul</span><span class="o">,</span>
  <span class="n">rot_mul_assoc</span><span class="o">,</span>
  <span class="mi">1</span><span class="o">,</span>
  <span class="n">rot_left_ident</span><span class="o">,</span>
  <span class="n">rot_right_ident</span><span class="o">,</span>
  <span class="n">rot_npow</span><span class="o">,</span>
  <span class="n">rot_npow_zero</span><span class="o">,</span>                <span class="c1">-- autoparam</span>
  <span class="n">rot_npow_succ</span><span class="o">,</span>                <span class="c1">-- autoparam</span>
  <span class="n">rot_inv</span><span class="o">,</span>
  <span class="n">rot_div</span><span class="o">,</span>
  <span class="n">rot_div_inv</span><span class="o">,</span>
  <span class="n">rot_zpow</span><span class="o">,</span>
  <span class="n">rot_npow_zero</span><span class="o">,</span>                <span class="c1">-- same proof again</span>
  <span class="n">rot_zpow_non_neg</span><span class="o">,</span>             <span class="c1">-- explicit typing needed</span>
  <span class="n">rot_zpow_neg</span><span class="o">,</span>                 <span class="c1">-- same</span>
  <span class="n">rot_left_inv</span>
<span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>What we&#8217;ve finally done is to show that we can impose a
group structure on elements of type rot, given our
definitions of mul, inv, div, npow, and zpow.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23reduce%20r120%20*%20r120%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20multiplication%0A%23reduce%20r120%E2%81%BB%C2%B9%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20inverses%0A%23reduce%20r120%20%2F%20r240%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20division%0A%23reduce%20r120%5E4%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20exponentiation%20by%20nat%0A%23reduce%20r120%5E(4%3Aint)%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20exponentiation%20by%20non-negative%20int%0A%23reduce%20r120%5E(-4%3Aint)%20%20%20%20%20%20%20%20%20%20%20%20%20--%20exponentiation%20by%20negative%20int" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_580.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#reduce</span> <span class="n">r120</span> <span class="bp">*</span> <span class="n">r120</span>               <span class="c1">-- multiplication</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">&#8315;&#185;</span>                    <span class="c1">-- inverses</span>
<span class="k">#reduce</span> <span class="n">r120</span> <span class="bp">/</span> <span class="n">r240</span>               <span class="c1">-- division</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">^</span><span class="mi">4</span>                    <span class="c1">-- exponentiation by nat</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">^</span><span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">int</span><span class="o">)</span>              <span class="c1">-- exponentiation by non-negative int</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">^</span><span class="o">(</span><span class="bp">-</span><span class="mi">4</span><span class="o">:</span><span class="n">int</span><span class="o">)</span>             <span class="c1">-- exponentiation by negative int</span>
</pre></div>
</div>
</div></section>
</section>
</section>
<section id="actions">
<h2><span class="section-number">6.3. </span>Actions<a class="headerlink" href="#actions" title="Permalink to this heading">&#61633;</a></h2>
<p>We now seen that group elements can be understood as
actions that can be performed on some other kinds of
objects. For example, elements of the Lie group, S1,
namely points on the complex unit circle, represent
rotations of vectors specified by arbitrary complex
numbers. Moreover, every possible degree of rotation
has a corresponding group element. It&#8217;s a continuous
transformation group.</p>
<p>By contrast, our group of rotational symmetries of an
equilateral triangle (rotations that put it right back
on top of itself) is hardly continuous. Nevertheless,
it can be understood as a group of actions, acting on
such a triangle.</p>
<p>More generally, an action acts on something, and in
general these somethings are not of the same type as
the actions themselves. For example, elements of S1
are <em>special</em> complex numbers, lying on the unit circle,
and understood on any arbitrary vector, represented by
an complex number, by complex number multiplication,
thereby effecting a pure rotation (no dilation) of the
target vector.</p>
<p>We thus now have two types involved: the type of the
group elements and the type of the objects that the group
elements act upon. In this chapter, we&#8217;ll use G as the name
of the type of group elements, and &#945; for the type of the
objects that group elements act on.</p>
<p>To make the concept of a group action clearer, we&#8217;ll develop
it in the context of our running example of the rotational
symmetries of equilateral triangles. What these actions act
on are equilaterial triangles. We&#8217;ll overload an operation
called smul, introduced by the group_action typeclass, and
denoted g &#8226; b to represent the result of applying the action
g to the object b, with a result of the same type b has. As
an example, if b is the triangle rotated 120 degrees then
the result of applying the r120 action to b would be the
triangle rotated 240 degrees.</p>
<p>We could define a generalized triangle type, but in this
example, there are only three configurations that we care
about: not rotated, rotated by 120 degrees, and rotated by
240 degrees. That means we can represent this set with a
type, we&#8217;ll call it tri, with just three values. We&#8217;ll
call them t0, t120, and t240.</p>
<p>The concept of a group acting on objects of some type is
fundamental in mathematics. And there&#8217;s a notation for that.
If g &#8712; G and b &#8712; &#945; then we can write (g &#8226; b) to denote the
result of g acting on b.</p>
<p>Lean provides this notation through instantiation of its
group_action typeclass. In addition to this notation, this
typeclass requires verification of the two actioms of group
actions, namely that 1 &#8226; b = b, and that (g&#8321; * g&#8322;) &#8226; b =
g&#8321; &#8226; (g&#8322; &#8226; b).</p>
<p>So, first, the group identity has to act as an identity
for &#945;. Second, you can compose transformations (g&#8321; * g&#8322;)
then apply the result to a target, or you can transform
by g&#8321; the result of transforming b by g&#8322;, and you&#8217;ll get
the same results.</p>
<p>It&#8217;s easier to think about sequential application of
transformations than applications of their compositions,
but as we&#8217;ll see, the ability to compose arbitrary
transforms into reduced transforms will be essential.</p>
<section id="target-type">
<h3><span class="section-number">6.3.1. </span>Target Type<a class="headerlink" href="#target-type" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=inductive%20tri%0A%7C%20t0%0A%7C%20t120%0A%7C%20t240" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_79.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">tri</span>
<span class="bp">|</span> <span class="n">t0</span>
<span class="bp">|</span> <span class="n">t120</span>
<span class="bp">|</span> <span class="n">t240</span>
</pre></div>
</div>
</div></section>
<section id="id3">
<h3><span class="section-number">6.3.2. </span>Typeclasses<a class="headerlink" href="#id3" title="Permalink to this heading">&#61633;</a></h3>
<p>To instantiate the group_action typeclass, we&#8217;ll have to
do so for the group_smul class, providing an implementation
of the <em>smul</em> function that computes the results of group
actions; and we&#8217;ll have to gven proofs of compliance with
the two axioms. At the end of the chapter we&#8217;ll introduce
some other examples and emphasize that the step taken in
this chapter has given us a way not only to represent
but also to apply transformations. The smul operation, &#8226;,
applies a group element representing an operation to a
given target object, returning its transformed state.</p>
<section id="has-smul">
<h4><span class="section-number">6.3.2.1. </span>has_smul<a class="headerlink" href="#has-smul" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0A%40%5Bext%2C%20class%5D%0Astructure%20has_smul%20(M%20%3A%20Type%20u_1)%20(%CE%B1%20%3A%20Type%20u_2)%20%3A%0AType%20(max%20u_1%20u_2)%0A%20%20%20%20smul%20%3A%20M%20%E2%86%92%20%CE%B1%20%E2%86%92%20%CE%B1%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_105.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">@[ext, class]</span>
<span class="cm">structure has_smul (M : Type u_1) (&#945; : Type u_2) :</span>
<span class="cm">Type (max u_1 u_2)</span>
<span class="cm">    smul : M &#8594; &#945; &#8594; &#945;</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
<section id="group-action">
<h4><span class="section-number">6.3.2.2. </span>group_action<a class="headerlink" href="#group-action" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0Auniverses%20u_10%20u_11%0A%0A%40%5Bext%2C%20class%5D%0Astructure%20mul_action%20(%CE%B1%20%3A%20Type%20u_10)%20(%CE%B1%20%3A%20Type%20u_11)%20%5Bmonoid%20%CE%B1%5D%20%3A%0AType%20(max%20u_10%20u_11)%20%3A%3D%0A(%20%20%20%20to_has_smul%20%3A%20has_smul%20%CE%B1%20%CE%B1)%0A(%20%20%20%20one_smul%20%3A%20%E2%88%80%20(b%20%3A%20%CE%B1)%2C%201%20%E2%80%A2%20b%20%3D%20b)%0A(%20%20%20%20mul_smul%20%3A%20%E2%88%80%20(x%20y%20%3A%20%CE%B1)%20(b%20%3A%20%CE%B1)%2C%20(x%20*%20y)%20%E2%80%A2%20b%20%3D%20x%20%E2%80%A2%20y%20%E2%80%A2%20b)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_118.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">universes u_10 u_11</span>

<span class="cm">@[ext, class]</span>
<span class="cm">structure mul_action (&#945; : Type u_10) (&#945; : Type u_11) [monoid &#945;] :</span>
<span class="cm">Type (max u_10 u_11) :=</span>
<span class="cm">(    to_has_smul : has_smul &#945; &#945;)</span>
<span class="cm">(    one_smul : &#8704; (b : &#945;), 1 &#8226; b = b)</span>
<span class="cm">(    mul_smul : &#8704; (x y : &#945;) (b : &#945;), (x * y) &#8226; b = x &#8226; y &#8226; b)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
</section>
<section id="id4">
<h3><span class="section-number">6.3.3. </span>Instances<a class="headerlink" href="#id4" title="Permalink to this heading">&#61633;</a></h3>
<section id="has-smul-rot-tri">
<h4><span class="section-number">6.3.3.1. </span>has_smul rot tri<a class="headerlink" href="#has-smul-rot-tri" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20mul_rot_tri%20%3A%20rot%20%E2%86%92%20tri%20%E2%86%92%20tri%0A%7C%20r0%20t%20%3A%3D%20t%0A%7C%20r120%20t0%20%3A%3D%20t120%0A%7C%20r120%20t120%20%3A%3D%20t240%0A%7C%20r120%20t240%20%3A%3D%20t0%0A%7C%20r240%20t0%20%3A%3D%20t240%0A%7C%20r240%20t120%20%3A%3D%20t0%0A%7C%20r240%20t240%20%3A%3D%20t120%0A%0Ainstance%20%3A%20has_smul%20rot%20tri%20%3A%3D%20%E2%9F%A8%20mul_rot_tri%20%E2%9F%A9%0A%0A%23reduce%20r0%20%E2%80%A2%20t0%0A%23reduce%20r240%20%E2%80%A2%20t0%0A%23reduce%20r240%20%E2%80%A2%20t120" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_138.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">mul_rot_tri</span> <span class="o">:</span> <span class="n">rot</span> <span class="bp">&#8594;</span> <span class="n">tri</span> <span class="bp">&#8594;</span> <span class="n">tri</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">t</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">t0</span> <span class="o">:=</span> <span class="n">t120</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">t120</span> <span class="o">:=</span> <span class="n">t240</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">t240</span> <span class="o">:=</span> <span class="n">t0</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">t0</span> <span class="o">:=</span> <span class="n">t240</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">t120</span> <span class="o">:=</span> <span class="n">t0</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">t240</span> <span class="o">:=</span> <span class="n">t120</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_smul</span> <span class="n">rot</span> <span class="n">tri</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">mul_rot_tri</span> <span class="o">&#10217;</span>

<span class="k">#reduce</span> <span class="n">r0</span> <span class="bp">&#8226;</span> <span class="n">t0</span>
<span class="k">#reduce</span> <span class="n">r240</span> <span class="bp">&#8226;</span> <span class="n">t0</span>
<span class="k">#reduce</span> <span class="n">r240</span> <span class="bp">&#8226;</span> <span class="n">t120</span>
</pre></div>
</div>
</div></section>
<section id="mul-action-m">
<h4><span class="section-number">6.3.3.2. </span>mul_action M &#945;<a class="headerlink" href="#mul-action-m" title="Permalink to this heading">&#61633;</a></h4>
<p><cite>mul_action M &#945;</cite> and its additive version <cite>add_action G P</cite>
are typeclasses used for actions of multiplicative and
additive monoids and groups; they extend notation classes
<cite>has_smul</cite> and <cite>has_vadd</cite> defined in <cite>algebra.group.defs</cite>;</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=lemma%20rot_one_action%20%3A%20%E2%88%80%20(b%20%3A%20tri)%2C%20(1%20%3A%20rot)%20%E2%80%A2%20b%20%3D%20b%20%3A%3D%0Abegin%0Aassume%20b%2C%0Acases%20b%2C%0Arepeat%20%7Bexact%20rfl%7D%2C%0Aend%0A%0Adef%20rot_prod_action%20%3A%20%E2%88%80%20(x%20y%20%3A%20rot)%20(t%20%3A%20tri)%2C%20(x%20*%20y)%20%E2%80%A2%20t%20%3D%20x%20%E2%80%A2%20y%20%E2%80%A2%20t%20%3A%3D%0Abegin%0A%0Aassume%20x%20y%20t%2C%0Acases%20t%2C%0A%0A%20%20cases%20x%2C%0A%20%20cases%20y%2C%0A%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20cases%20y%2C%0A%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20cases%20y%2C%0A%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%0A%20%20cases%20x%2C%0A%20%20cases%20y%2C%0A%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20cases%20y%2C%0A%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20cases%20y%2C%0A%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20cases%20y%2C%0A%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%0Acases%20x%2C%0Arepeat%20%7B%20exact%20rfl%2C%7D%2C%0Acases%20x%2C%0Arepeat%20%7B%20exact%20rfl%2C%7D%2C%0Acases%20x%2C%0Arepeat%20%7Bexact%20rfl%2C%7D%2C%0A%0Aend%0A%0A%0Ainstance%20%3A%20mul_action%20rot%20tri%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_one_action%2C%0A%20%20rot_prod_action%2C%0A%E2%9F%A9" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_164.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">lemma</span> <span class="n">rot_one_action</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">tri</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">rot</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">b</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">rot_prod_action</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">rot</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">tri</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">t</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">&#8226;</span> <span class="n">y</span> <span class="bp">&#8226;</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>

<span class="k">assume</span> <span class="n">x</span> <span class="n">y</span> <span class="n">t</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">t</span><span class="o">,</span>

  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>

  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>

<span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span><span class="o">,},</span>
<span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span><span class="o">,},</span>
<span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">,},</span>

<span class="kd">end</span>


<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">rot</span> <span class="n">tri</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_one_action</span><span class="o">,</span>
  <span class="n">rot_prod_action</span><span class="o">,</span>
<span class="o">&#10217;</span>
</pre></div>
</div>
</div></section>
</section>
<section id="discussion">
<h3><span class="section-number">6.3.4. </span>Discussion<a class="headerlink" href="#discussion" title="Permalink to this heading">&#61633;</a></h3>
</section>
</section>
<section id="torsors">
<h2><span class="section-number">6.4. </span>Torsors<a class="headerlink" href="#torsors" title="Permalink to this heading">&#61633;</a></h2>
<section id="id5">
<h3><span class="section-number">6.4.1. </span>Introduction<a class="headerlink" href="#id5" title="Permalink to this heading">&#61633;</a></h3>
<p>Might it be that the triangle elements of tri can be
understood as points in a space, and that elements of rot
can be understood as differences between points in a way
that turns the points into a torsor over the group of
rotations?</p>
<p>From a group action we know that the effect of a sequence
of actions on a triangle is the same as the action of the
sum (in the group) of the actions.</p>
<p>When actions are expensive (e.g., involving actions on
real, physical things), it can be hugely beneficial to
compute the sum then just take one action that gets to
the same end result.</p>
<p>In this chapter we&#8217;ll see how to formalize this idea
again using our example of the rotational symmetry
group of an equilateral triangle. We will the see that
the set of triangles themselves, with an appropriate
<em>difference</em> operation, constitutes a torsor for that
group.</p>
<p>When the actions form a group (an additive group), we
can combine them using addition and subtraction. If the
actions form a richer structure, such as a <em>module</em> or a
<em>vector space</em>, then we can do even richer mathematics
with actions before applying them.</p>
<p>The &#8220;architecture&#8221; of a structured collection of actions
acting on a set of objects</p>
</section>
<section id="readings">
<h3><span class="section-number">6.4.2. </span>Readings<a class="headerlink" href="#readings" title="Permalink to this heading">&#61633;</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://math.ucr.edu/home/baez/torsors.html">Torsors made easy</a></p></li>
<li><p><a class="reference external" href="https://github.com/leanprover-community/mathlib/blob/master/src/algebra/add_torsor.lean">Additive torsors in Lean</a></p></li>
<li><p><a class="reference external" href="https://math.ucr.edu/home/baez/">Prof. Baez page</a></p></li>
</ul>
<p>From Baez, Torsors made easy:</p>
<ul class="simple">
<li><p>Newtonian Physics: Energy is relative to an arbitrary zero. Energy differences lie in the group of real numbers R, but energies themselves do not: they lie in an R-torsor.</p></li>
<li><p>Electromagnetism: Voltage is relative to an arbitrary zero. Voltage differences lie in the group of real numbers R, but voltages themselves do not: they lie in an R-torsor.</p></li>
<li><p>Quantum Mechanics: Phases are relative. &#8220;[W]e can multiply the phase of a quantum state by any unit complex number without changing the physics&#8230;.What makes sense &#8230; is to talk about the relative phase between two states that differ only by a phase.&#8221; Relative phases lie in the group of unit complex numbers, which is called U(1), but phases themselves do not: they lie in a U(1)-torsor.</p></li>
<li><p>An affine space <em>A</em> is a torsor for a vector space <em>V</em>.</p></li>
</ul>
</section>
<section id="typeclass">
<h3><span class="section-number">6.4.3. </span>Typeclass<a class="headerlink" href="#typeclass" title="Permalink to this heading">&#61633;</a></h3>
<p>We&#8217;ll  now set out to formalize the notion of a G-torsor as
an instance of the typeclass, add_torsor G P, for G = rot and
P = tri. Here G is the set of rotations as an <em>additive</em> group.</p>
<p>Paraphrasing from the mathlib documentation, an (add_torsor
G P) gives a structure to a nonempty type P, acted on by an
add_group G with a (transitive &amp; free) action given by the +&#7525;
operation on G and corresponding subtraction given by the -&#7525;
operation. In the case of G being a vector space, P is then
an affine space.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0Astructure%20add_torsor%20(G%20%3A%20out_param%20(Type%20u_1))%20(P%20%3A%20Type%20u_2)%20%5Bout_param%20(add_group%20G)%5D%20%3A%0AType%20(max%20u_1%20u_2)%0A%20%20%20%20to_add_action%20%3A%20add_action%20G%20P%20%20%20%20--%20action%20of%20group%20elements%20on%20triangles%20(%2B%E1%B5%A5)%0A%20%20%20%20to_has_vsub%20%3A%20has_vsub%20G%20P%20%20%20%20%20%20%20%20--%20binary%20difference%20operation%20on%20triangles%20(-%E1%B5%A5)%0A%20%20%20%20nonempty%20%3A%20nonempty%20P%20%20%20%20%20%20%20%20%20%20%20%20%20--%20a%20condition%20to%20be%20a%20torsor%20is%20non-emptiness%0A%0A%20%20%20%20--%20The%20torsor%20axioms%3B%20what%20do%20they%20mean%20geometrically%3F%0A%20%20%20%20vsub_vadd'%20%3A%20%E2%88%80%20(p1%20p2%20%3A%20P)%2C%20p1%20-%E1%B5%A5%20p2%20%2B%E1%B5%A5%20p2%20%3D%20p1%0A%20%20%20%20vadd_vsub'%20%3A%20%E2%88%80%20(g%20%3A%20G)%20(p%20%3A%20P)%2C%20g%20%2B%E1%B5%A5%20p%20-%E1%B5%A5%20p%20%3D%20g%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_70.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">structure add_torsor (G : out_param (Type u_1)) (P : Type u_2) [out_param (add_group G)] :</span>
<span class="cm">Type (max u_1 u_2)</span>
<span class="cm">    to_add_action : add_action G P    -- action of group elements on triangles (+&#7525;)</span>
<span class="cm">    to_has_vsub : has_vsub G P        -- binary difference operation on triangles (-&#7525;)</span>
<span class="cm">    nonempty : nonempty P             -- a condition to be a torsor is non-emptiness</span>

<span class="cm">    -- The torsor axioms; what do they mean geometrically?</span>
<span class="cm">    vsub_vadd&#39; : &#8704; (p1 p2 : P), p1 -&#7525; p2 +&#7525; p2 = p1</span>
<span class="cm">    vadd_vsub&#39; : &#8704; (g : G) (p : P), g +&#7525; p -&#7525; p = g</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
<section id="id6">
<h3><span class="section-number">6.4.4. </span>Instances<a class="headerlink" href="#id6" title="Permalink to this heading">&#61633;</a></h3>
<p>First we need to recast our multiplicative group, rot,
as an additive group. And just as (mul) group inherits
from (mul) monoid, we&#8217;ll need to have add_group inherit
from add_monoid. This and related steps will be easy as
we can just relabel our existing mul operation as add,
and all the proofs (e.g., of associativity) just carry
through.</p>
<section id="add-monoid-rot">
<h4><span class="section-number">6.4.4.1. </span>add_monoid rot<a class="headerlink" href="#add-monoid-rot" title="Permalink to this heading">&#61633;</a></h4>
<p>To structure rot as an additive group, we need first to
structure it as as additive monoid. So we now take these
steps: first an <em>additive</em> monoid of rotations, the the
corresponding additive group.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20renaming%0Adef%20rot_add%20%3A%3D%20rot_mul%0Adef%20rot_add_assoc%20%3A%3D%20rot_mul_assoc%0Adef%20foo%20%3A%3D%20rot_npow%0A%0A%23check%20%40add_monoid.mk%0A%0A%2F-%0A%CE%A0%20%7BM%20%3A%20Type%20u_1%7D%0A%20%20(add%20%3A%20M%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20(%E2%88%80%20(a%20b%20c%20%3A%20M)%2C%20a%20%2B%20b%20%2B%20c%20%3D%20a%20%2B%20(b%20%2B%20c))%20%E2%86%92%0A%20%20%CE%A0%20(zero%20%3A%20M)%0A%20%20(zero_add%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%200%20%2B%20a%20%3D%20a)%0A%20%20(add_zero%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%20a%20%2B%200%20%3D%20a)%0A%20%20(nsmul%20%3A%20%E2%84%95%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20auto_param%20(%E2%88%80%20(x%20%3A%20M)%2C%20nsmul%200%20x%20%3D%200)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20M)%2C%20nsmul%20n.succ%20x%20%3D%20x%20%2B%20nsmul%20n%20x)%0A%20%20%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20add_monoid%20MLea%0A-%2F%0A%0A%0Aopen%20rot%0Ainstance%20%3A%20add_monoid%20rot%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_add%2C%20%20%20%20%20%20%20%20--%20same%20operation%20now%20viewed%20as%20addition%0A%20%20rot_add_assoc%2C%20%20--%20same%20trick%0A%20%20r0%2C%0A%20%20begin%0A%20%20%20%20assume%20a%2C%0A%20%20%20%20cases%20a%2C%0A%20%20%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20end%2C%0A%20%20begin%0A%20%20%20%20assume%20a%2C%0A%20%20%20%20cases%20a%2C%0A%20%20%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20end%2C%0A%20%20foo%2C%20%20%20%20--%20TODO%3A%20fix%20naming%0A%E2%9F%A9%0A%0A--%20The%20add_monoid%20structure%20gives%20us%20addition%20and%20the%20%2B%20notation%20for%20it%0A--%20We%20think%20of%20monoid%20addition%20as%20akin%20to%20vector%20addition%0A%23reduce%20r120%20%2B%20r120%20%20%20%20--%20overloaded%20%2B%0A%23reduce%20r120%20%2B%20r0%20%20%20%20%20%20--%20overloaded%200" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_104.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- renaming</span>
<span class="kd">def</span> <span class="n">rot_add</span> <span class="o">:=</span> <span class="n">rot_mul</span>
<span class="kd">def</span> <span class="n">rot_add_assoc</span> <span class="o">:=</span> <span class="n">rot_mul_assoc</span>
<span class="kd">def</span> <span class="n">foo</span> <span class="o">:=</span> <span class="n">rot_npow</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">add_monoid.mk</span>

<span class="c">/-</span>
<span class="cm">&#928; {M : Type u_1}</span>
<span class="cm">  (add : M &#8594; M &#8594; M),</span>
<span class="cm">  (&#8704; (a b c : M), a + b + c = a + (b + c)) &#8594;</span>
<span class="cm">  &#928; (zero : M)</span>
<span class="cm">  (zero_add : &#8704; (a : M), 0 + a = a)</span>
<span class="cm">  (add_zero : &#8704; (a : M), a + 0 = a)</span>
<span class="cm">  (nsmul : &#8469; &#8594; M &#8594; M),</span>
<span class="cm">  auto_param (&#8704; (x : M), nsmul 0 x = 0) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">  auto_param (&#8704; (n : &#8469;) (x : M), nsmul n.succ x = x + nsmul n x)</span>
<span class="cm">    (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">  add_monoid MLea</span>
<span class="cm">-/</span>


<span class="kn">open</span> <span class="n">rot</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_monoid</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_add</span><span class="o">,</span>        <span class="c1">-- same operation now viewed as addition</span>
  <span class="n">rot_add_assoc</span><span class="o">,</span>  <span class="c1">-- same trick</span>
  <span class="n">r0</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">foo</span><span class="o">,</span>    <span class="c1">-- TODO: fix naming</span>
<span class="o">&#10217;</span>

<span class="c1">-- The add_monoid structure gives us addition and the + notation for it</span>
<span class="c1">-- We think of monoid addition as akin to vector addition</span>
<span class="k">#reduce</span> <span class="n">r120</span> <span class="bp">+</span> <span class="n">r120</span>    <span class="c1">-- overloaded +</span>
<span class="k">#reduce</span> <span class="n">r120</span> <span class="bp">+</span> <span class="n">r0</span>      <span class="c1">-- overloaded 0</span>
</pre></div>
</div>
</div><p>Now we can formulate our collection of rotations as an additive group.</p>
</section>
<section id="add-group-rot">
<h4><span class="section-number">6.4.4.2. </span>add_group rot<a class="headerlink" href="#add-group-rot" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40add_group.mk%0A%2F-%0Aadd_group.mk%20%3A%0A%20%20%CE%A0%0A%20%20%20%20%7BA%20%3A%20Type%20u_1%7D%0A%20%20%20%20(add%20%3A%20A%20%E2%86%92%20A%20%E2%86%92%20A)%0A%20%20%20%20(add_assoc%20%3A%20%E2%88%80%20(a%20b%20c%20%3A%20A)%2C%20a%20%2B%20b%20%2B%20c%20%3D%20a%20%2B%20(b%20%2B%20c))%0A%20%20%20%20(zero%20%3A%20A)%0A%20%20%20%20(zero_add%20%3A%20%E2%88%80%20(a%20%3A%20A)%2C%200%20%2B%20a%20%3D%20a)%0A%20%20%20%20(add_zero%20%3A%20%E2%88%80%20(a%20%3A%20A)%2C%20a%20%2B%200%20%3D%20a)%0A%20%20%20%20(nsmul%20%3A%20%E2%84%95%20%E2%86%92%20A%20%E2%86%92%20A)%0A%20%20%20%20(nsmul_zero'%20%3A%20auto_param%20(%E2%88%80%20(x%20%3A%20A)%2C%20nsmul%200%20x%20%3D%200)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(nsmul_succ'%20%3A%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20A)%2C%20nsmul%20n.succ%20x%20%3D%20x%20%2B%20nsmul%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(neg%20%3A%20A%20%E2%86%92%20A)%0A%20%20%20%20(sub%20%3A%20A%20%E2%86%92%20A%20%E2%86%92%20A)%0A%20%20%20%20(sub_eq_add_neg%20%3A%20auto_param%20(%E2%88%80%20(a%20b%20%3A%20A)%2C%20a%20-%20b%20%3D%20a%20%2B%20-b)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(zsmul%20%3A%20%E2%84%A4%20%E2%86%92%20A%20%E2%86%92%20A)%0A%20%20%20%20(zsmul_zero'%20%3A%20auto_param%20(%E2%88%80%20(a%20%3A%20A)%2C%20zsmul%200%20a%20%3D%200)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(zsmul_succ'%20%3A%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20A)%2C%20zsmul%20(int.of_nat%20n.succ)%20a%20%3D%20a%20%2B%20zsmul%20(int.of_nat%20n)%20a)%0A%20%20%20%20%20%20%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(zsmul_neg'%20%3A%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20A)%2C%20zsmul%20-%5B1%2B%20n%5D%20a%20%3D%20-zsmul%20%E2%86%91(n.succ)%20a)%0A%20%20%20%20%20%20%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%2C%20(%E2%88%80%20(a%20%3A%20A)%2C%20-a%20%2B%20a%20%3D%200)%20%E2%86%92%20add_group%20A%0A-%2F%0A%0Ainstance%20%3A%20add_group%20rot%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_add%2C%20%20%20%20%20%20%20%20--%20stealing%20it%20for%20use%20here%0A%20%20rot_add_assoc%2C%20%20--%20even%20works%20for%20this%0A%20%200%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20r0%20denoted%200%20is%20additive%20identity%0A%20%20rot_left_ident%2C%0A%20%20rot_right_ident%2C%0A%20%20foo%2C%20%20%20%20%20%20%20--%20again%20reusing%20mult%20operator%0A%20%20--%20nsmul%200%0A%20%20begin%20assume%20x%2C%20exact%20rfl%2C%20end%2C%0A%20%20begin%0A%20%20%20%20assume%20n%20x%2C%0A%20%20%20%20simp%20%5Bfoo%5D%2C%20%20%20--%20TODO%3A%20fix%20naming%0A%20%20%20%20exact%20rfl%2C%0A%20%20end%2C%0A%20%20rot_inv%2C%0A%20%20(%CE%BB%20r1%20r2%2C%20r1%20%2B%20(rot_inv%20r2))%2C%0A%20%20begin%0A%20%20%20%20assume%20a%20b%2C%0A%20%20%20%20exact%20rfl%2C%0A%20%20end%2C%0A%20%20rot_zpow%2C%20%20%20%20%20%20%20--%20TODO%3A%20fix%20naming%0A%20%20begin%0A%20%20%20%20assume%20r%2C%0A%20%20%20%20exact%20rfl%2C%0A%20%20end%2C%0A%20%20begin%0A%20%20%20%20assume%20n%20a%2C%0A%20%20%20%20exact%20rfl%2C%0A%20%20end%2C%0A%20%20begin%0A%20%20%20%20assume%20n%20a%2C%0A%20%20%20%20exact%20rfl%2C%0A%20%20end%2C%0A%20%20begin%0A%20%20%20%20assume%20a%2C%0A%20%20%20%20cases%20a%2C%0A%20%20%20%20repeat%20%7Bexact%20rfl%2C%7D%0A%20%20end%2C%0A%E2%9F%A9%0A--%20So%20here%20we%20have%20the%20add_group%20we%20need%20for%20torsor%0A--%20What%20it%20gives%20us%20(because%20of%20inverses)%20is%20subtraction%0A%0A%23reduce%20r120%20-%20r120" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_160.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">add_group.mk</span>
<span class="c">/-</span>
<span class="cm">add_group.mk :</span>
<span class="cm">  &#928;</span>
<span class="cm">    {A : Type u_1}</span>
<span class="cm">    (add : A &#8594; A &#8594; A)</span>
<span class="cm">    (add_assoc : &#8704; (a b c : A), a + b + c = a + (b + c))</span>
<span class="cm">    (zero : A)</span>
<span class="cm">    (zero_add : &#8704; (a : A), 0 + a = a)</span>
<span class="cm">    (add_zero : &#8704; (a : A), a + 0 = a)</span>
<span class="cm">    (nsmul : &#8469; &#8594; A &#8594; A)</span>
<span class="cm">    (nsmul_zero&#39; : auto_param (&#8704; (x : A), nsmul 0 x = 0) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (nsmul_succ&#39; :</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (x : A), nsmul n.succ x = x + nsmul n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (neg : A &#8594; A)</span>
<span class="cm">    (sub : A &#8594; A &#8594; A)</span>
<span class="cm">    (sub_eq_add_neg : auto_param (&#8704; (a b : A), a - b = a + -b) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (zsmul : &#8484; &#8594; A &#8594; A)</span>
<span class="cm">    (zsmul_zero&#39; : auto_param (&#8704; (a : A), zsmul 0 a = 0) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (zsmul_succ&#39; :</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : A), zsmul (int.of_nat n.succ) a = a + zsmul (int.of_nat n) a)</span>
<span class="cm">        (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (zsmul_neg&#39; :</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : A), zsmul -[1+ n] a = -zsmul &#8593;(n.succ) a)</span>
<span class="cm">        (name.mk_string &quot;try_refl_tac&quot; name.anonymous)), (&#8704; (a : A), -a + a = 0) &#8594; add_group A</span>
<span class="cm">-/</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_group</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_add</span><span class="o">,</span>        <span class="c1">-- stealing it for use here</span>
  <span class="n">rot_add_assoc</span><span class="o">,</span>  <span class="c1">-- even works for this</span>
  <span class="mi">0</span><span class="o">,</span>              <span class="c1">-- r0 denoted 0 is additive identity</span>
  <span class="n">rot_left_ident</span><span class="o">,</span>
  <span class="n">rot_right_ident</span><span class="o">,</span>
  <span class="n">foo</span><span class="o">,</span>       <span class="c1">-- again reusing mult operator</span>
  <span class="c1">-- nsmul 0</span>
  <span class="kd">begin</span> <span class="k">assume</span> <span class="n">x</span><span class="o">,</span> <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span> <span class="kd">end</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">n</span> <span class="n">x</span><span class="o">,</span>
    <span class="n">simp</span> <span class="o">[</span><span class="n">foo</span><span class="o">],</span>   <span class="c1">-- TODO: fix naming</span>
    <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">rot_inv</span><span class="o">,</span>
  <span class="o">(</span><span class="bp">&#955;</span> <span class="n">r1</span> <span class="n">r2</span><span class="o">,</span> <span class="n">r1</span> <span class="bp">+</span> <span class="o">(</span><span class="n">rot_inv</span> <span class="n">r2</span><span class="o">)),</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="n">rot_zpow</span><span class="o">,</span>       <span class="c1">-- TODO: fix naming</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">r</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">,}</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">&#10217;</span>
<span class="c1">-- So here we have the add_group we need for torsor</span>
<span class="c1">-- What it gives us (because of inverses) is subtraction</span>

<span class="k">#reduce</span> <span class="n">r120</span> <span class="bp">-</span> <span class="n">r120</span>
</pre></div>
</div>
</div><p>Next we formulate the action of a rotation on a triange.
We do it in two steps, first adding a binary operation
taking a rot and a tri and yielding a tri, with +&#7525; as
notation; then we formally define an add_action and show
that it satisfies the axioms for an additive action.</p>
</section>
<section id="has-vadd-rot-tri">
<h4><span class="section-number">6.4.4.3. </span>has_vadd rot tri<a class="headerlink" href="#has-vadd-rot-tri" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20view%20mul%20action%2C%20mul_rot_tri%2C%20as%20an%20additive%20action%0A--%20a%20rotation%20%22adds%20itself%22%20to%20any%20tri%20to%20rotate%20it%20thusly%0A%0A--%20We%20need%20additive%20action%2C%20borrow%20mult%20version%20(hack)%0Adef%20add_rot_tri%20%3A%3D%20mul_rot_tri%0Ainstance%20%3A%20has_vadd%20rot%20tri%20%3A%3D%20%E2%9F%A8%20add_rot_tri%20%E2%9F%A9%0A%0A--%20Now%20we've%20got%20the%20%22action%22" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_246.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- view mul action, mul_rot_tri, as an additive action</span>
<span class="c1">-- a rotation &quot;adds itself&quot; to any tri to rotate it thusly</span>

<span class="c1">-- We need additive action, borrow mult version (hack)</span>
<span class="kd">def</span> <span class="n">add_rot_tri</span> <span class="o">:=</span> <span class="n">mul_rot_tri</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_vadd</span> <span class="n">rot</span> <span class="n">tri</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">add_rot_tri</span> <span class="o">&#10217;</span>

<span class="c1">-- Now we&#39;ve got the &quot;action&quot;</span>
</pre></div>
</div>
</div></section>
<section id="add-action-rot-tri">
<h4><span class="section-number">6.4.4.4. </span>add_action rot tri<a class="headerlink" href="#add-action-rot-tri" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0A%40%5Bext%2C%20class%5D%0Astructure%20add_action%20(G%20%3A%20Type%20u_10)%20(P%20%3A%20Type%20u_11)%20%5Badd_monoid%20G%5D%20%3A%0AType%20(max%20u_10%20u_11)%0A%20%20%20%20to_has_vadd%20%3A%20has_vadd%20G%20P%0A%20%20%20%20zero_vadd%20%3A%20%E2%88%80%20(p%20%3A%20P)%2C%200%20%2B%E1%B5%A5%20p%20%3D%20p%0A%20%20%20%20add_vadd%20%3A%20%E2%88%80%20(g%E2%82%81%20g%E2%82%82%20%3A%20G)%20(p%20%3A%20P)%2C%20g%E2%82%81%20%2B%20g%E2%82%82%20%2B%E1%B5%A5%20p%20%3D%20g%E2%82%81%20%2B%E1%B5%A5%20(g%E2%82%82%20%2B%E1%B5%A5%20p)%0A-%2F%0A%0A%23check%20%40add_action.mk%0A%2F-%0Aadd_action.mk%20%3A%0A%CE%A0%0A%20%20%7BG%20%3A%20Type%20u_10%7D%0A%20%20%7BP%20%3A%20Type%20u_11%7D%0A%20%20%5B_inst_1%20%3A%20add_monoid%20G%5D%0A%20%20%5B_to_has_vadd%20%3A%20has_vadd%20G%20P%5D%2C%0A(%E2%88%80%20(p%20%3A%20P)%2C%200%20%2B%E1%B5%A5%20p%20%3D%20p)%20%E2%86%92%0A(%E2%88%80%20(g%E2%82%81%20g%E2%82%82%20%3A%20G)%20(p%20%3A%20P)%2C%20g%E2%82%81%20%2B%20g%E2%82%82%20%2B%E1%B5%A5%20p%20%3D%20g%E2%82%81%20%2B%E1%B5%A5%20(g%E2%82%82%20%2B%E1%B5%A5%20p))%20%E2%86%92%0Aadd_action%20G%20P%0A-%2F%0A%0Ainstance%20%3A%20add_action%20rot%20tri%20%3A%3D%0A%E2%9F%A8%0A%20%20--%20(%E2%88%80%20(p%20%3A%20P)%2C%200%20%2B%E1%B5%A5%20p%20%3D%20p)%0A%20%20begin%0A%20%20%20%20assume%20t%2C%0A%20%20%20%20cases%20t%2C%0A%20%20%20%20repeat%20%7Bexact%20rfl%2C%7D%0A%20%20end%2C%0A%0A%20%20--%20(%E2%88%80%20(g%E2%82%81%20g%E2%82%82%20%3A%20G)%20(p%20%3A%20P)%2C%20g%E2%82%81%20%2B%20g%E2%82%82%20%2B%E1%B5%A5%20p%20%3D%20g%E2%82%81%20%2B%E1%B5%A5%20(g%E2%82%82%20%2B%E1%B5%A5%20p))%0A%20%20begin%0A%20%20%20%20assume%20g%20h%20t%2C%0A%20%20%20%20cases%20t%2C%0A%20%20%20%20%20%20repeat%20%7B%0A%20%20%20%20%20%20%20%20cases%20g%2C%0A%20%20%20%20%20%20%20%20%20%20repeat%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20cases%20h%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20repeat%20%7B%20exact%20rfl%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%2C%0A%20%20end%0A%E2%9F%A9" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_263.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">@[ext, class]</span>
<span class="cm">structure add_action (G : Type u_10) (P : Type u_11) [add_monoid G] :</span>
<span class="cm">Type (max u_10 u_11)</span>
<span class="cm">    to_has_vadd : has_vadd G P</span>
<span class="cm">    zero_vadd : &#8704; (p : P), 0 +&#7525; p = p</span>
<span class="cm">    add_vadd : &#8704; (g&#8321; g&#8322; : G) (p : P), g&#8321; + g&#8322; +&#7525; p = g&#8321; +&#7525; (g&#8322; +&#7525; p)</span>
<span class="cm">-/</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">add_action.mk</span>
<span class="c">/-</span>
<span class="cm">add_action.mk :</span>
<span class="cm">&#928;</span>
<span class="cm">  {G : Type u_10}</span>
<span class="cm">  {P : Type u_11}</span>
<span class="cm">  [_inst_1 : add_monoid G]</span>
<span class="cm">  [_to_has_vadd : has_vadd G P],</span>
<span class="cm">(&#8704; (p : P), 0 +&#7525; p = p) &#8594;</span>
<span class="cm">(&#8704; (g&#8321; g&#8322; : G) (p : P), g&#8321; + g&#8322; +&#7525; p = g&#8321; +&#7525; (g&#8322; +&#7525; p)) &#8594;</span>
<span class="cm">add_action G P</span>
<span class="cm">-/</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_action</span> <span class="n">rot</span> <span class="n">tri</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="c1">-- (&#8704; (p : P), 0 +&#7525; p = p)</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">,}</span>
  <span class="kd">end</span><span class="o">,</span>

  <span class="c1">-- (&#8704; (g&#8321; g&#8322; : G) (p : P), g&#8321; + g&#8322; +&#7525; p = g&#8321; +&#7525; (g&#8322; +&#7525; p))</span>
  <span class="kd">begin</span>
    <span class="k">assume</span> <span class="n">g</span> <span class="n">h</span> <span class="n">t</span><span class="o">,</span>
    <span class="n">cases</span> <span class="n">t</span><span class="o">,</span>
      <span class="n">repeat</span> <span class="o">{</span>
        <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
          <span class="n">repeat</span> <span class="o">{</span>
            <span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
              <span class="n">repeat</span> <span class="o">{</span> <span class="n">exact</span> <span class="n">rfl</span> <span class="o">}</span>
          <span class="o">}</span>
      <span class="o">},</span>
  <span class="kd">end</span>
<span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>Yay. We&#8217;re now able to prove that triangles for a torsor
for our additive group of rotations.</p>
</section>
<section id="add-torsor-rot-tri">
<h4><span class="section-number">6.4.4.5. </span>add_torsor rot tri<a class="headerlink" href="#add-torsor-rot-tri" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20With%20this%20additive%20action%20we%20can%20now%20instantiate%20torsor%20rot%20tri.%0A%0A%23check%20%40add_torsor%0A%2F-%0Aclass%20add_torsor%20(G%20%3A%20out_param%20Type*)%20(P%20%3A%20Type*)%20%5Bout_param%20%24%20add_group%20G%5D%0A%20%20extends%20add_action%20G%20P%2C%20has_vsub%20G%20P%20%3A%3D%0A%5Bnonempty%20%3A%20nonempty%20P%5D%0A(vsub_vadd'%20%3A%20%E2%88%80%20(p1%20p2%20%3A%20P)%2C%20(p1%20-%E1%B5%A5%20p2%20%3A%20G)%20%2B%E1%B5%A5%20p2%20%3D%20p1)%0A(vadd_vsub'%20%3A%20%E2%88%80%20(g%20%3A%20G)%20(p%20%3A%20P)%2C%20g%20%2B%E1%B5%A5%20p%20-%E1%B5%A5%20p%20%3D%20g)%0A-%2F%0A%0A--%20we%20need%20nonemtpy%20tri%0Ainstance%20%3A%20nonempty%20tri%20%3A%3D%20%E2%9F%A8%20tri.t0%20%E2%9F%A9%20%20%20--%20maybe%20open%20namespace%3F%0A%0A--%20we%20need%20has_vsub%20rot%20tri%0Adef%20vsub_rot_tri%20%3A%20tri%20%E2%86%92%20tri%20%E2%86%92%20rot%0A%7C%20tri.t0%20tri.t0%20%3A%3D%200%0A%7C%20tri.t0%20tri.t120%20%3A%3D%20r240%0A%7C%20tri.t0%20tri.t240%20%3A%3D%20r120%0A%7C%20tri.t120%20tri.t0%20%3A%3D%20r120%0A%7C%20tri.t120%20tri.t120%20%3A%3D%200%0A%7C%20tri.t120%20tri.t240%20%3A%3D%20r240%0A%7C%20tri.t240%20tri.t0%20%3A%3D%20r240%0A%7C%20tri.t240%20tri.t120%20%3A%3D%20r120%0A%7C%20tri.t240%20tri.t240%20%3A%3D%200%0Ainstance%20%3A%20has_vsub%20rot%20tri%20%3A%3D%20%E2%9F%A8%20vsub_rot_tri%E2%9F%A9%0A%0A--%20Ready!%0A%23check%20%40add_torsor.mk%0A%2F-%0Aadd_torsor.mk%20%3A%0A%CE%A0%0A%20%20%7BG%20%3A%20out_param%20(Type%20u_1)%7D%0A%20%20%7BP%20%3A%20Type%20u_2%7D%0A%20%20%5B_inst_1%20%3A%20out_param%20(add_group%20G)%5D%0A%20%20%5B_to_add_action%20%3A%20add_action%20G%20P%5D%0A%20%20%5B_to_has_vsub%20%3A%20has_vsub%20G%20P%5D%0A%20%20%5Bnonempty%20%3A%20nonempty%20P%5D%2C%0A(%E2%88%80%20(p1%20p2%20%3A%20P)%2C%20p1%20-%E1%B5%A5%20p2%20%2B%E1%B5%A5%20p2%20%3D%20p1)%20%E2%86%92%0A(%E2%88%80%20(g%20%3A%20G)%20(p%20%3A%20P)%2C%20g%20%2B%E1%B5%A5%20p%20-%E1%B5%A5%20p%20%3D%20g)%20%E2%86%92%0Aadd_torsor%20G%20P%0A-%2F%0A%0Ainstance%20%3A%20add_torsor%20rot%20tri%20%3A%3D%20add_torsor.mk%0A%0A--%20%E2%88%80%20(p1%20p2%20%3A%20%3Fm_1)%2C%20p1%20-%E1%B5%A5%20p2%20%2B%E1%B5%A5%20p2%20%3D%20p1%20%3A%20Prop%0Abegin%0A%20%20assume%20p1%20p2%2C%0A%20%20cases%20p1%2C%0A%20%20repeat%20%7B%0A%20%20%20%20cases%20p2%2C%0A%20%20%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20%7D%0Aend%0A%0A--%20(%E2%88%80%20(g%20%3A%20G)%20(p%20%3A%20P)%2C%20g%20%2B%E1%B5%A5%20p%20-%E1%B5%A5%20p%20%3D%20g)%0Abegin%0A%20%20assume%20g%20p%2C%0A%20%20cases%20g%2C%0A%20%20repeat%20%7B%0A%20%20%20%20cases%20p%2C%0A%20%20%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20%7D%2C%0Aend" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_319.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- With this additive action we can now instantiate torsor rot tri.</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">add_torsor</span>
<span class="c">/-</span>
<span class="cm">class add_torsor (G : out_param Type*) (P : Type*) [out_param $ add_group G]</span>
<span class="cm">  extends add_action G P, has_vsub G P :=</span>
<span class="cm">[nonempty : nonempty P]</span>
<span class="cm">(vsub_vadd&#39; : &#8704; (p1 p2 : P), (p1 -&#7525; p2 : G) +&#7525; p2 = p1)</span>
<span class="cm">(vadd_vsub&#39; : &#8704; (g : G) (p : P), g +&#7525; p -&#7525; p = g)</span>
<span class="cm">-/</span>

<span class="c1">-- we need nonemtpy tri</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">nonempty</span> <span class="n">tri</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">tri.t0</span> <span class="o">&#10217;</span>   <span class="c1">-- maybe open namespace?</span>

<span class="c1">-- we need has_vsub rot tri</span>
<span class="kd">def</span> <span class="n">vsub_rot_tri</span> <span class="o">:</span> <span class="n">tri</span> <span class="bp">&#8594;</span> <span class="n">tri</span> <span class="bp">&#8594;</span> <span class="n">rot</span>
<span class="bp">|</span> <span class="n">tri.t0</span> <span class="n">tri.t0</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">tri.t0</span> <span class="n">tri.t120</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">tri.t0</span> <span class="n">tri.t240</span> <span class="o">:=</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">tri.t120</span> <span class="n">tri.t0</span> <span class="o">:=</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">tri.t120</span> <span class="n">tri.t120</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">tri.t120</span> <span class="n">tri.t240</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">tri.t240</span> <span class="n">tri.t0</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">tri.t240</span> <span class="n">tri.t120</span> <span class="o">:=</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">tri.t240</span> <span class="n">tri.t240</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_vsub</span> <span class="n">rot</span> <span class="n">tri</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">vsub_rot_tri</span><span class="o">&#10217;</span>

<span class="c1">-- Ready!</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">add_torsor.mk</span>
<span class="c">/-</span>
<span class="cm">add_torsor.mk :</span>
<span class="cm">&#928;</span>
<span class="cm">  {G : out_param (Type u_1)}</span>
<span class="cm">  {P : Type u_2}</span>
<span class="cm">  [_inst_1 : out_param (add_group G)]</span>
<span class="cm">  [_to_add_action : add_action G P]</span>
<span class="cm">  [_to_has_vsub : has_vsub G P]</span>
<span class="cm">  [nonempty : nonempty P],</span>
<span class="cm">(&#8704; (p1 p2 : P), p1 -&#7525; p2 +&#7525; p2 = p1) &#8594;</span>
<span class="cm">(&#8704; (g : G) (p : P), g +&#7525; p -&#7525; p = g) &#8594;</span>
<span class="cm">add_torsor G P</span>
<span class="cm">-/</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_torsor</span> <span class="n">rot</span> <span class="n">tri</span> <span class="o">:=</span> <span class="n">add_torsor.mk</span>

<span class="c1">-- &#8704; (p1 p2 : ?m_1), p1 -&#7525; p2 +&#7525; p2 = p1 : Prop</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">p1</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">p2</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="o">}</span>
<span class="kd">end</span>

<span class="c1">-- (&#8704; (g : G) (p : P), g +&#7525; p -&#7525; p = g)</span>
<span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">g</span> <span class="n">p</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">p</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
</section>
<section id="programming">
<h3><span class="section-number">6.4.5. </span>Programming<a class="headerlink" href="#programming" title="Permalink to this heading">&#61633;</a></h3>
<p>We can now perform interesting computations specified in
the mathematical language of the domain.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23reduce%20r120%20%2B%E1%B5%A5%20r240%20%2B%E1%B5%A5%20-r0%20%2B%E1%B5%A5%20-r120%20%2B%E1%B5%A5%20r0%20%2B%E1%B5%A5%20tri.t0%20%20--%20five%20costly%20actions%20(%2B%E1%B5%A5)%0A--%20r120%20acting%20on%20the%20result%20of%20r240%20acting%20on%20the%20result%20of%20...%20r0%20acting%20on%20t0" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_393.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#reduce</span> <span class="n">r120</span> <span class="bp">+&#7525;</span> <span class="n">r240</span> <span class="bp">+&#7525;</span> <span class="bp">-</span><span class="n">r0</span> <span class="bp">+&#7525;</span> <span class="bp">-</span><span class="n">r120</span> <span class="bp">+&#7525;</span> <span class="n">r0</span> <span class="bp">+&#7525;</span> <span class="n">tri.t0</span>  <span class="c1">-- five costly actions (+&#7525;)</span>
<span class="c1">-- r120 acting on the result of r240 acting on the result of ... r0 acting on t0</span>
</pre></div>
</div>
</div><p>If actions are expensive, and you need to apply multiple actions, the structure
we&#8217;ve created makes it possible to <em>compute</em> the net action and to apply it only
once with a guarantee that the result will be the same.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23reduce%20r120%20%20%2B%20r240%20%20-%20%20r0%20%20-%20%20r120%20%20%2B%20r0%20%2B%E1%B5%A5%20tri.t0%20%20--%20add%20in%20group%2C%20then%20just%20one!%0A--%20the%20sum%20of%20r120%20and%20r240%20and%20...%20acting%20on%20t0." target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_402.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#reduce</span> <span class="n">r120</span>  <span class="bp">+</span> <span class="n">r240</span>  <span class="bp">-</span>  <span class="n">r0</span>  <span class="bp">-</span>  <span class="n">r120</span>  <span class="bp">+</span> <span class="n">r0</span> <span class="bp">+&#7525;</span> <span class="n">tri.t0</span>  <span class="c1">-- add in group, then just one!</span>
<span class="c1">-- the sum of r120 and r240 and ... acting on t0.</span>
</pre></div>
</div>
</div></section>
<section id="id7">
<h3><span class="section-number">6.4.6. </span>Discussion<a class="headerlink" href="#id7" title="Permalink to this heading">&#61633;</a></h3>
<p>Under construction.</p>
<p>Now we have a simple but beautiful and useful new arithmetic
and mathematical architecture. The architectural components
are a collection of <em>points</em> and a collection of <em>actions</em>
corresponding to differences between points. In our running
example, the collection of actions is rot, and it is a group;
and the collection of points is tri. In addition, we have a
set of essential operations:</p>
<ul class="simple">
<li><p>addition of actions to produce resulting actions (+ or -)</p></li>
<li><p>actions acting on points to produce new points (+&#7525;)</p></li>
<li><p>differences of points yielding new actions (-&#7525;)</p></li>
</ul>
<p>Finally we have the torsor axioms.</p>
<ul class="simple">
<li><p>&#8704; (p1 p2 : Point), (p1 -&#7525; p2) +&#7525; p2 = p1</p></li>
<li><p>(&#8704; (g : Group) (p : Point), g +&#7525; p -&#7525; p = g)</p></li>
</ul>
<p>The first axiom insists that adding the difference
between two points to the second point must get you
back to the first point. To visualize p1 -&#7525; p2, put
an arrowhead pointing to p1 then drag a line to p2.
That arrow is a visualization of the difference. A
key idea is that you can move that arrow around, to
put its tail at any point. If you leave it right at
p2, then it must point right back to p1.</p>
<p>The second axiom insists that if you subtract any
point p from the result of applying an action g to
p then the difference between these points must be
just g.</p>
<section id="an-archictural-template">
<h4><span class="section-number">6.4.6.1. </span>An archictural template<a class="headerlink" href="#an-archictural-template" title="Permalink to this heading">&#61633;</a></h4>
<p>This structure combines a torsor of points with the
collection of differences between points. Each such
difference, in turn, acts on any given point through
addition of itself to that point, thereby displacing
the point by exactly the difference it represents.</p>
</section>
<section id="role-of-origin">
<h4><span class="section-number">6.4.6.2. </span>Role of origin<a class="headerlink" href="#role-of-origin" title="Permalink to this heading">&#61633;</a></h4>
<p>The end result is that the structure of differences
also maps the torsor of points as long as one chooses
an origin point from which the actions reach all the
other points. Because all three points in our example
algebraic structure look the same, it doesn&#8217;t matter
which we pick as an origin. The differences give us a
kind of <em>coordinatization</em> of the points relative to
a <em>non-canonical</em> (arbitrary) choice of origin point.</p>
<p>We can lay down the structure of the differences
g : G, by placing the zero difference at any origin
point o : P, and letting every other point be mapped
by its displacement from that origin. One ends up
with a &#8220;G map&#8221; of all points relative to that origin.</p>
</section>
<section id="path-forward">
<h4><span class="section-number">6.4.6.3. </span>Path Forward<a class="headerlink" href="#path-forward" title="Permalink to this heading">&#61633;</a></h4>
<p>Our plan is to enrich the architecture we now have
in hand. One key enrichment will be to replace mere
groups of transformations with vector spaces, where
each vector acts on any given point by addition of
itself to the point. The corresponding point torsors
are then affine spaces. To understand vector spaces
one in turn needs concepts such as fields and rings,
which extend groups with additional structure.</p>
<p>Briefly stated, a ring is a <em>commutative</em> additive
group (+) together with an associative multiplication
operator satisfying the usual left/right distributive
laws. In a field, there are multiplicative inverses,
as well, except for at 0.</p>
<p>A vector space has its coefficients from a field. A
slightly weaker structure is called a module. It has
its coefficients from a ring. Modules thus generalize
from vector spaces by relaxing the requirement for
multiplicative inverses (thus division) of actions.</p>
<p><cite>Modules &lt;https://www.youtube.com/watch?v=IvukAijXgLE&gt;_</cite></p>
<p>To be sure that we&#8217;ve given modules their due, we will
cross through them on our way to replacing the rot group
in our example so far with a one dimensional vector space
over a (coefficient) <em>field</em>, K. The corresponding point
torsor will then be the corresonding affine space.</p>
</section>
</section>
</section>
<section id="modules">
<h2><span class="section-number">6.5. </span>Modules<a class="headerlink" href="#modules" title="Permalink to this heading">&#61633;</a></h2>
<p>We&#8217;ve now undertood what it means to be a torsor over
a group. A concrete example is our torsor of triangles
over a group of rotational symmetries. That fact that
rotational symmetries form an additive group lets us
do <em>additive group math</em> on symmetries: associative add,
additively invert, subtract, zero left/right identity.</p>
<p>In this chapter, we strengthen this concept by upgrading
a mere additive group of actions/differences to a <em>module</em>
of actions. In comparison with a group, G, a module adds a
set of scalars and an operation for multiplying group
actions by scalars.</p>
<p>For example, if s is a scalar and v is a group action,
then s &#8226; v is scalar multiplication of s and v yielding a
new, &#8220;scaled&#8221; group action.</p>
<p>The set of scalars must form at least a <em>ring</em>, so you
can add, invert, substract, and multiply scalars by each
other (+, -, <a href="#id8"><span class="problematic" id="id9">*</span></a>). For example, the integers for a ring:
you can multiply, add, invert, and thus subtract them,
but dividing them generally doesn&#8217;t produce new integers.</p>
<p>If sclars have multiplicative inverses as well, and thus
division, then you have a scalar <em>field</em>. For example, the
set of real numbers minus {0} forms a field. A module with
a scalar <em>field</em> is called a vector space.</p>
<p>The overall picture, then, is one in which, in a module,
you can not only add, invert, and substract actions, but
you can also multiply (<em>scale</em>) them by scalars. Example:
if v&#8321; and v&#8322; are group actions and s&#8321; and s&#8322; are scalars,
then s&#8321; &#8226; (v1 +&#7525; v2) is also an action, s&#8321; &#8226; v&#8321; + s&#8321; &#8226; v&#8322;;
and (s&#8321; + s&#8322;) &#8226; v1 = s&#8226; v&#8321; + s&#8321; &#8226; v&#8322;, is too. A module is
a generalization of a vector space where you can&#8217;t always
compute inverses of scalars.</p>
<p>Once we have modules, as richer sets of group actions, then
we&#8217;ll be able to form torsors over <em>modules</em>. That takes us
right right up to the threshold of affine spaces, which are
simply torsors over <em>vector</em> spaces. Vector spaces are just
modules with that extra structure on their sets of scalars.</p>
<section id="modules-in-lean">
<h3><span class="section-number">6.5.1. </span>Modules in Lean<a class="headerlink" href="#modules-in-lean" title="Permalink to this heading">&#61633;</a></h3>
<p>In Lean, one can form a module from an <em>additive commutative
monoid</em> M, and a <em>semi-ring,</em> R, of scalars. A module relaxes
the need for an underlying <em>group</em> of actions by relaxing the
need for additive inverses of actions. And unlike a full ring,
a semi-ring omits the requirement for additive inverses (and
thus subtraction) of scalars.</p>
<p>Note that in a ring, the existence of additive inverses means
that 0 is a multiplicative zero (prove it to yourself); in a
semi-ring, by contrast, without additive inverses, one has to
identify the multiplicative zero explicitly (and show that it
is one).</p>
</section>
<section id="example">
<h3><span class="section-number">6.5.2. </span>Example<a class="headerlink" href="#example" title="Permalink to this heading">&#61633;</a></h3>
<p>That all sounds pretty abstract. To make it more real, could
we turn our <em>group</em> of triangle rotations into a module? We
already have addition and subtraction of rotations. Would it
make sense to scale rotations?</p>
<p>The answer is yes it does, but with restrictions. We can&#8217;t
scale rotations by real numbers, for example, as that would
give rise to fractional rotations (like 1/2 or r120) that
would no longer be symmetries. We&#8217;ve already seen, however,
that it makes sense to multiply rotations by integers, as
that&#8217;s nothing other than iterated addition.</p>
<p>To turn our group of rotations into a module, we now have
most of what we need: &#8484; will be our ring of scalars acting
to <em>scale</em> rotations, but only by integer amounts. If &#8484; were
a field, we&#8217;d have a vector space, but it&#8217;s not so we have a
module.</p>
<p>Now if we have a rotation, m, from our <em>module</em> of rotations
and an integer, r, how should we define the scalar product,
r &#8226; m? The result needs to be another action, namely one that
is <em>scaled</em> by that integer value. As indicated above, what
will work is to define r &#8226; m as m added to itself r times.
And that is nothing other than the operation we already have
currently called rot_zpow : &#8484; &#8594; rot &#8594; rot.</p>
</section>
<section id="id10">
<h3><span class="section-number">6.5.3. </span>Typeclasses<a class="headerlink" href="#id10" title="Permalink to this heading">&#61633;</a></h3>
<p>So that&#8217;s the idea. Let&#8217;s turn to analyze the typeclasses we
will have to instantiate to formally represent our module of
rotations. Then we&#8217;ll have everything we need to have a torsor
of triangles over a module of rotations.</p>
<section id="module">
<h4><span class="section-number">6.5.3.1. </span>module<a class="headerlink" href="#module" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0A--%20here's%20the%20module%20typeclass%0Aclass%20module%20(R%20%3A%20Type%20u)%20(M%20%3A%20Type%20v)%20%5Bsemiring%20R%5D%0A%20%20%5Badd_comm_monoid%20M%5D%20extends%20distrib_mul_action%20R%20M%20%3A%3D%0A(add_smul%20%3A%20%E2%88%80(r%20s%20%3A%20R)%20(x%20%3A%20M)%2C%20(r%20%2B%20s)%20%E2%80%A2%20x%20%3D%20r%20%E2%80%A2%20x%20%2B%20s%20%E2%80%A2%20x)%0A(zero_smul%20%3A%20%E2%88%80x%20%3A%20M%2C%20(0%20%3A%20R)%20%E2%80%A2%20x%20%3D%200)%0A-%2F%0A%0A%2F-%0A--%20and%20here's%20its%20constructor%0A%23check%20%40module.mk%0Amodule.mk%20%3A%0A%20%20%CE%A0%20%7BR%20%3A%20Type%20u_1%7D%0A%20%20%20%20%7BM%20%3A%20Type%20u_2%7D%0A%20%20%20%20%5B_inst_1%20%3A%20semiring%20R%5D%0A%20%20%20%20%5B_inst_2%20%3A%20add_comm_monoid%20M%5D%0A%20%20%20%20%5B_to_distrib_mul_action%20%3A%20distrib_mul_action%20R%20M%5D%2C%0A%20%20%20%20(%E2%88%80%20(r%20s%20%3A%20R)%20(x%20%3A%20M)%2C%20(r%20%2B%20s)%20%E2%80%A2%20x%20%3D%20r%20%E2%80%A2%20x%20%2B%20s%20%E2%80%A2%20x)%20%E2%86%92%0A%20%20%20%20(%E2%88%80%20(x%20%3A%20M)%2C%200%20%E2%80%A2%20x%20%3D%200)%20%E2%86%92%0A%20%20%20%20module%20R%20M%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_105.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">-- here&#39;s the module typeclass</span>
<span class="cm">class module (R : Type u) (M : Type v) [semiring R]</span>
<span class="cm">  [add_comm_monoid M] extends distrib_mul_action R M :=</span>
<span class="cm">(add_smul : &#8704;(r s : R) (x : M), (r + s) &#8226; x = r &#8226; x + s &#8226; x)</span>
<span class="cm">(zero_smul : &#8704;x : M, (0 : R) &#8226; x = 0)</span>
<span class="cm">-/</span>

<span class="c">/-</span>
<span class="cm">-- and here&#39;s its constructor</span>
<span class="cm">#check @module.mk</span>
<span class="cm">module.mk :</span>
<span class="cm">  &#928; {R : Type u_1}</span>
<span class="cm">    {M : Type u_2}</span>
<span class="cm">    [_inst_1 : semiring R]</span>
<span class="cm">    [_inst_2 : add_comm_monoid M]</span>
<span class="cm">    [_to_distrib_mul_action : distrib_mul_action R M],</span>
<span class="cm">    (&#8704; (r s : R) (x : M), (r + s) &#8226; x = r &#8226; x + s &#8226; x) &#8594;</span>
<span class="cm">    (&#8704; (x : M), 0 &#8226; x = 0) &#8594;</span>
<span class="cm">    module R M</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>Our aim is to define an instance, [module &#8484; rot]. R = &#8484; is the scalar type,
and it must have the structure of a semi-ring. Interestingly, M = rot need
not be a full group, just a monoid, but its addition must be commutative.
Think about vector addition in linear algebra: it&#8217;s commutative. That&#8217;s how
we want elements of a module, or eventually a vector space, to behave.</p>
<p>Why not does the Lean module typeclass require a semi-ring structure on R,
and not a ring structure? The long and short of it is that it&#8217;s it&#8217;s a mathlib
design detail and all going to add up to the same stuff at the end, anyway, so
just go with it for now.</p>
<p>Next, to instantiate (module &#8484; rot) we&#8217;ll need a (distrib_mul_action &#8484; rot)
instance. It will provide definitions of the scalar multiplication operation
and proofs of certain required properties.</p>
<p>Finally, we&#8217;ll need to provide two new proofs, certifying that our definitions
satisfy the additional module axioms. The first requires scalar addition on the
left to distribute over scalar multiplication in the usual way. The second then
requires that multiplying any rotation, x, by <em>scalar</em> 0 (r0 in our case) yields
the zero <em>rotation</em>. The zero scalar zeros out any &#8220;vector.&#8221;</p>
<ul class="simple">
<li><p>add_smul: &#8704; (r s : &#8484;) (x : rot), (r + s) &#8226; x = r &#8226; x + s &#8226; x</p></li>
<li><p>zero_smul: &#8704; (x : rot), (0 : R) &#8226; x = 0</p></li>
</ul>
<p>Now we can make sense of the module typeclass instance <em>constructor</em>.
You can see where each value below slots into the structure. The &#8484; and
rot type arguments will be implicit, along with the required typeclass
instances We will then give the two new proof values explicitly.</p>
<p>We&#8217;ll now address each required building block in turn:</p>
<ul class="simple">
<li><p>[semiring &#8484;]</p></li>
<li><p>[add_comm_monoid rot]</p></li>
<li><p>distrib_mul_action &#8484; rot</p></li>
<li><p>add_smul</p></li>
<li><p>zero_smul</p></li>
</ul>
</section>
<section id="semiring">
<h4><span class="section-number">6.5.3.2. </span>semiring &#8484;<a class="headerlink" href="#semiring" title="Permalink to this heading">&#61633;</a></h4>
<p>Quoting essentially verbatim from the mathlib documentation, a semiring is
a type with the following structures:</p>
<ul class="simple">
<li><p>additive commutative monoid (<cite>add_comm_monoid</cite>)</p></li>
<li><p>multiplicative monoid (<cite>monoid</cite>)</p></li>
<li><p>distributive laws (<cite>distrib</cite>)</p></li>
<li><p>multiplication by zero law (<cite>mul_zero_class</cite>)</p></li>
</ul>
<p>The actual definition extends <cite>monoid_with_zero`instead of `monoid</cite> and
<cite>mul_zero_class</cite>.</p>
<p>The semiring typeclass definition is quoted next. It&#8217;s a bit arcane (again
largely for mathlib design purposes).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0A--%20Here's%20the%20actual%20semiring%20typeclass%20definition%20and%20constructor.%0A%40%5Bprotect_proj%2C%20ancestor%20non_unital_semiring%20non_assoc_semiring%20monoid_with_zero%5D%0Aclass%20semiring%20(%CE%B1%20%3A%20Type%20u)%20extends%20non_unital_semiring%20%CE%B1%2C%20non_assoc_semiring%20%CE%B1%2C%20monoid_with_zero%20%CE%B1%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_183.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">-- Here&#39;s the actual semiring typeclass definition and constructor.</span>
<span class="cm">@[protect_proj, ancestor non_unital_semiring non_assoc_semiring monoid_with_zero]</span>
<span class="cm">class semiring (&#945; : Type u) extends non_unital_semiring &#945;, non_assoc_semiring &#945;, monoid_with_zero &#945;</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>Fortunately, Lean already has a semiring typeclass for &#8484;, so we won&#8217;t need to
worry about instantiating that. Good news! We can skip the details of semiring
construction.</p>
</section>
<section id="add-comm-monoid-rot">
<h4><span class="section-number">6.5.3.3. </span>add_comm_monoid &#8484; rot<a class="headerlink" href="#add-comm-monoid-rot" title="Permalink to this heading">&#61633;</a></h4>
<p>To see how to instantiate (add_comm_monoid rot) one can inspect the
typeclass definition and its constructor, mk. Rather than delving into
the &#8220;super-classes&#8221;, we&#8217;ll just see what&#8217;s needed to use the constructor
and not worry about which super-classes provided which fields for now.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0AHere's%20the%20additive%20commutative%20monoid%20typeclass.%20It%20defines%20an%20additive%20monoid%0Awith%20*commutative*%20%60(%2B)%60.%0A%40%5Bprotect_proj%2C%20ancestor%20add_monoid%20add_comm_semigroup%5D%0Aclass%20add_comm_monoid%20(M%20%3A%20Type%20u)%20extends%20add_monoid%20M%2C%20add_comm_semigroup%20M%0A%0AHere's%20the%20constructor.%20We%20actually%20already%20have%20every%20field%0Avalue%20from%20our%20prior%20work%20except%20for%20the%20proof%20of%20commutativity%0Aof%20(rot)%20addition%20required%20for%20the%20last%20field%20of%20this%20typeclass.%0A%0Aadd_comm_monoid.mk%20%3A%0A%20%20%CE%A0%20%7BM%20%3A%20Type%20u%7D%0A%20%20%20%20(add%20%3A%20M%20%E2%86%92%20M%20%E2%86%92%20M)%0A%20%20%20%20(add_assoc%20%3A%20%E2%88%80%20(a%20b%20c%20%3A%20M)%2C%20a%20%2B%20b%20%2B%20c%20%3D%20a%20%2B%20(b%20%2B%20c))%0A%20%20%20%20(zero%20%3A%20M)%0A%20%20%20%20(zero_add%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%200%20%2B%20a%20%3D%20a)%0A%20%20%20%20(add_zero%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%20a%20%2B%200%20%3D%20a)%0A%20%20%20%20(nsmul%20%3A%20%E2%84%95%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20%20%20auto_param%20(%E2%88%80%20(x%20%3A%20M)%2C%20nsmul%200%20x%20%3D%200)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20M)%2C%20nsmul%20n.succ%20x%20%3D%20x%20%2B%20nsmul%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20(%E2%88%80%20(a%20b%20%3A%20M)%2C%20a%20%2B%20b%20%3D%20b%20%2B%20a)%20%E2%86%92%0A%20%20add_comm_monoid%20M%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_203.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">Here&#39;s the additive commutative monoid typeclass. It defines an additive monoid</span>
<span class="cm">with *commutative* `(+)`.</span>
<span class="cm">@[protect_proj, ancestor add_monoid add_comm_semigroup]</span>
<span class="cm">class add_comm_monoid (M : Type u) extends add_monoid M, add_comm_semigroup M</span>

<span class="cm">Here&#39;s the constructor. We actually already have every field</span>
<span class="cm">value from our prior work except for the proof of commutativity</span>
<span class="cm">of (rot) addition required for the last field of this typeclass.</span>

<span class="cm">add_comm_monoid.mk :</span>
<span class="cm">  &#928; {M : Type u}</span>
<span class="cm">    (add : M &#8594; M &#8594; M)</span>
<span class="cm">    (add_assoc : &#8704; (a b c : M), a + b + c = a + (b + c))</span>
<span class="cm">    (zero : M)</span>
<span class="cm">    (zero_add : &#8704; (a : M), 0 + a = a)</span>
<span class="cm">    (add_zero : &#8704; (a : M), a + 0 = a)</span>
<span class="cm">    (nsmul : &#8469; &#8594; M &#8594; M),</span>
<span class="cm">    auto_param (&#8704; (x : M), nsmul 0 x = 0) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (x : M), nsmul n.succ x = x + nsmul n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">    (&#8704; (a b : M), a + b = b + a) &#8594;</span>
<span class="cm">  add_comm_monoid M</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
<section id="distrib-mul-action-rot">
<h4><span class="section-number">6.5.3.4. </span>distrib_mul_action &#8484; rot<a class="headerlink" href="#distrib-mul-action-rot" title="Permalink to this heading">&#61633;</a></h4>
<p>The (distrib_mul_action M A) typeclass extends mul_action M A typeclass
brings together a set of scalars, M, and a set of objects, A, on which
they act. We will have M = &#8484; and A = rot, enabling scalar multiplication.
We&#8217;ll dig down (up) to the mul_action superclass. We&#8217;ll then have all
the information needed to instantiate (distrib_mul_action &#8484; rot), giving
us well defined meanings for expressions such as (3:Z) &#8226; (r240 + r120).
Think of that as being like a scalar multiplication of a sum of vectors.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40distrib_mul_action%0A%2F-%0A%40%5Bext%5D%20class%20distrib_mul_action%20(M%20A%20%3A%20Type*)%20%5Bmonoid%20M%5D%20%5Badd_monoid%20A%5D%0A%20%20extends%20mul_action%20M%20A%20%3A%3D%0A(smul_zero%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%20a%20%E2%80%A2%20(0%20%3A%20A)%20%3D%200)%0A(smul_add%20%3A%20%E2%88%80%20(a%20%3A%20M)%20(x%20y%20%3A%20A)%2C%20a%20%E2%80%A2%20(x%20%2B%20y)%20%3D%20a%20%E2%80%A2%20x%20%2B%20a%20%E2%80%A2%20y)%0A-%2F%0A%0A%23check%20%40mul_action%0A%2F-%0Aclass%20mul_action%20(%CE%B1%20%3A%20Type*)%20(%CE%B2%20%3A%20Type*)%20%5Bmonoid%20%CE%B1%5D%20extends%20has_smul%20%CE%B1%20%CE%B2%20%3A%3D%0A(one_smul%20%3A%20%E2%88%80%20b%20%3A%20%CE%B2%2C%20(1%20%3A%20%CE%B1)%20%E2%80%A2%20b%20%3D%20b)%0A(mul_smul%20%3A%20%E2%88%80%20(x%20y%20%3A%20%CE%B1)%20(b%20%3A%20%CE%B2)%2C%20(x%20*%20y)%20%E2%80%A2%20b%20%3D%20x%20%E2%80%A2%20y%20%E2%80%A2%20b)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_241.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">distrib_mul_action</span>
<span class="c">/-</span>
<span class="cm">@[ext] class distrib_mul_action (M A : Type*) [monoid M] [add_monoid A]</span>
<span class="cm">  extends mul_action M A :=</span>
<span class="cm">(smul_zero : &#8704; (a : M), a &#8226; (0 : A) = 0)</span>
<span class="cm">(smul_add : &#8704; (a : M) (x y : A), a &#8226; (x + y) = a &#8226; x + a &#8226; y)</span>
<span class="cm">-/</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">mul_action</span>
<span class="c">/-</span>
<span class="cm">class mul_action (&#945; : Type*) (&#946; : Type*) [monoid &#945;] extends has_smul &#945; &#946; :=</span>
<span class="cm">(one_smul : &#8704; b : &#946;, (1 : &#945;) &#8226; b = b)</span>
<span class="cm">(mul_smul : &#8704; (x y : &#945;) (b : &#946;), (x * y) &#8226; b = x &#8226; y &#8226; b)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
</section>
<section id="typeclass-instances">
<h3><span class="section-number">6.5.4. </span>Typeclass instances<a class="headerlink" href="#typeclass-instances" title="Permalink to this heading">&#61633;</a></h3>
<p>Now we develop each missing operation and proof and
instantiate each missing &#8484;-rot specific typeclass
instance so as to be able ultimately to construct
a (module &#8484; rot) instance.</p>
<section id="id11">
<h4><span class="section-number">6.5.4.1. </span>add_comm_monoid rot<a class="headerlink" href="#id11" title="Permalink to this heading">&#61633;</a></h4>
<p>We don&#8217;t need to worry about typeclasses for &#8484; as
the ones we need are already provided by mathlib.
So we&#8217;ll turn to the next item on the list: to show
rotations form an additive <em>commutative</em> monoid. For
that we are lacking only a proof of commutativity of
rotation addition.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20rot_add_comm%20%3A%20%E2%88%80%20(a%20b%20%3A%20rot)%2C%20a%20%2B%20b%20%3D%20b%20%2B%20a%20%3A%3D%0Abegin%0A%20%20ring%2C%20--%20%3F%0A%20%20%2F-%0A%20%20assume%20a%20b%2C%0A%20%20%20%20cases%20a%2C%0A%20%20%20%20repeat%20%7B%0A%20%20%20%20%20%20cases%20b%2C%0A%20%20%20%20%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20%20%20%7D%2C%0A%20%20-%2F%0Aend%0A%0A--%20now%20we%20can%20have%20our%20typeclass%20instance%20for%20rot%0Ainstance%20%3A%20add_comm_monoid%20rot%20%3A%3D%0A%E2%9F%A8%0A%20%20--%20stuff%20we%20already%20have%0A%20%20rot_add%2C%0A%20%20rot_add_assoc%2C%0A%20%20r0%2C%0A%20%20rot_left_ident%2C%0A%20%20rot_right_ident%2C%0A%20%20rot_npow%2C%20%20%20%20%20%20%20%20%20--%20fix%20multiplicative-sounding%20name%0A%20%20rot_npow_zero%2C%0A%20%20rot_npow_succ%2C%0A%20%20rot_add_comm%2C%20%20%20%20%20--%20the%20new%20proof%20here%0A%E2%9F%A9" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_277.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">rot_add_comm</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">ring</span><span class="o">,</span> <span class="c1">-- ?</span>
  <span class="c">/-</span>
<span class="cm">  assume a b,</span>
<span class="cm">    cases a,</span>
<span class="cm">    repeat {</span>
<span class="cm">      cases b,</span>
<span class="cm">      repeat {exact rfl},</span>
<span class="cm">    },</span>
<span class="cm">  -/</span>
<span class="kd">end</span>

<span class="c1">-- now we can have our typeclass instance for rot</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">add_comm_monoid</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="c1">-- stuff we already have</span>
  <span class="n">rot_add</span><span class="o">,</span>
  <span class="n">rot_add_assoc</span><span class="o">,</span>
  <span class="n">r0</span><span class="o">,</span>
  <span class="n">rot_left_ident</span><span class="o">,</span>
  <span class="n">rot_right_ident</span><span class="o">,</span>
  <span class="n">rot_npow</span><span class="o">,</span>         <span class="c1">-- fix multiplicative-sounding name</span>
  <span class="n">rot_npow_zero</span><span class="o">,</span>
  <span class="n">rot_npow_succ</span><span class="o">,</span>
  <span class="n">rot_add_comm</span><span class="o">,</span>     <span class="c1">-- the new proof here</span>
<span class="o">&#10217;</span>
</pre></div>
</div>
</div></section>
<section id="id12">
<h4><span class="section-number">6.5.4.2. </span>distrib_mul_action &#8484; rot<a class="headerlink" href="#id12" title="Permalink to this heading">&#61633;</a></h4>
<p>First we&#8217;ll define s &#8226; m to mean rot_zpow s m.
In other workds, we&#8217;ll define scalar multiplication
integer s by rotation r to be: (1) for a non-negative
s, the rotation <em>added</em> to itself that many times
(already implemented by rot_zpow), and for a negative
s by the additive inverse (negation) of that sum.
The  we&#8217;ll need to prove that scaling a rotation b
by scalar (x * y) is the same as scalaing b first
by y then by x. With that we can define an instance,
(mul_action &#8484; rot).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=instance%20%3A%20has_smul%20%E2%84%A4%20rot%20%3A%3D%20%E2%9F%A8%20rot_zpow%20%E2%9F%A9%0A%0Alemma%20rot_mul_smul%20%3A%0A%20%20%E2%88%80%20(x%20y%20%3A%20%E2%84%A4)%20(b%20%3A%20rot)%2C%20(x%20*%20y)%20%E2%80%A2%20b%20%3D%20x%20%E2%80%A2%20y%20%E2%80%A2%20b%20%3A%3D%0Abegin%0Asorry%2C%0Aend%0A%0Ainstance%20%3A%20mul_action%20%E2%84%A4%20rot%20%3A%3D%0A%E2%9F%A8%0A%20%20--%20one_smul%0A%20%20begin%0A%20%20assume%20b%2C%0A%20%20cases%20b%2C%0A%20%20repeat%20%7Bexact%20rfl%7D%2C%0A%20%20end%2C%0A%0A%20%20--%20mul_smul%0A%20%20begin%0A%20%20assume%20x%20y%20b%2C%0A%20%20apply%20rot_mul_smul%2C%20%20%20%20%20%20%20--%20sorried%0A%20%20end%2C%0A%E2%9F%A9" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_323.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">instance</span> <span class="o">:</span> <span class="n">has_smul</span> <span class="n">&#8484;</span> <span class="n">rot</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">rot_zpow</span> <span class="o">&#10217;</span>

<span class="kd">lemma</span> <span class="n">rot_mul_smul</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">&#8226;</span> <span class="n">y</span> <span class="bp">&#8226;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="gr">sorry</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_action</span> <span class="n">&#8484;</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="c1">-- one_smul</span>
  <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
  <span class="kd">end</span><span class="o">,</span>

  <span class="c1">-- mul_smul</span>
  <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">x</span> <span class="n">y</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">rot_mul_smul</span><span class="o">,</span>       <span class="c1">-- sorried</span>
  <span class="kd">end</span><span class="o">,</span>
<span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>With our (mul_action &#8484; rot) defined we now put together
the final peices needed for (distrib_mul_action &#8484; rot).
With this instance in hand, in the next subsection we
instantiate (module &#8484; rot), which was our aim: to have
not just a group, but a <em>module</em>, of rotation actions:
actions that we can add, subtract, and <em>scale</em> by values
from a <em>ring</em>. So let&#8217;s get (distrib_mul_action &#8484; rot)
constructed.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20scaling%20the%200%20rotation%20by%20any%20int%20leaves%20it%20as%200.%0Alemma%20rot_smul_zero%20%3A%20%E2%88%80%20(a%20%3A%20%E2%84%A4)%2C%20a%20%E2%80%A2%20(0%20%3A%20rot)%20%3D%200%20%3A%3D%0A%20%20begin%0A%20%20simp%20%5Brot_zpow%5D%2C%0A%20%20end%0A%0A--%20scalaing%20a%20sum%20of%20rotations%20is%20the%20sum%20of%20the%20scalaed%20rotations%0Alemma%20rot_smul_add%20%3A%20%E2%88%80%20(a%20%3A%20%E2%84%A4)%20(x%20y%20%3A%20rot)%2C%20a%20%E2%80%A2%20(x%20%2B%20y)%20%3D%20a%20%E2%80%A2%20x%20%2B%20a%20%E2%80%A2%20y%20%3A%3D%0A%20%20begin%0A%20%20assume%20z%20x%20y%2C%0A%20%20--%20annoying%3A%20notation%20is%20blocking%20progress%2C%20use%20show%20to%20change%20notation%0A%20%20have%20fix%20%3A%20r0%20%3D%20(0%3Arot)%20%3A%3D%20begin%20exact%20rfl%2C%20end%2C%0A%20%20--%20by%20case%20analysis%20on%20x%2C%20y%0A%20%20cases%20x%2C%0A%20%20repeat%20%7B%0A%20%20%20%20cases%20y%2C%0A%20%20%20%20repeat%20%7B%0A%20%20%20%20%20%20rw%20fix%2C%0A%20%20%20%20%20%20simp%20%5Brot_add%5D%2C%0A%20%20%20%20%7D%2C%0A%20%20%7D%2C%0A%20%20--%20induction%20on%20z%0A%20%20repeat%20%7B%0A%20%20induction%20z%20with%20n%20negn%2C%0A%20%20simp%20%5Brot_npow%5D%2C%0A%20%20simp%20%5Brot_zpow%5D%2C%0A%20%20%7D%2C%0A%20%20--%20by%20commutativity%20of%20rot%20%2B%0A%20%20apply%20rot_add_comm%2C%0A%20%20apply%20rot_add_comm%2C%0Aend%0A%0A--%20That's%20all%20we%20need%20for%20(distrib_mul_action%20%E2%84%A4%20rot)%0Ainstance%20%3A%20distrib_mul_action%20%E2%84%A4%20rot%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_smul_zero%2C%0A%20%20rot_smul_add%2C%0A%E2%9F%A9" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_359.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- scaling the 0 rotation by any int leaves it as 0.</span>
<span class="kd">lemma</span> <span class="n">rot_smul_zero</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&#8226;</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">rot</span><span class="o">)</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
  <span class="kd">begin</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">rot_zpow</span><span class="o">],</span>
  <span class="kd">end</span>

<span class="c1">-- scalaing a sum of rotations is the sum of the scalaed rotations</span>
<span class="kd">lemma</span> <span class="n">rot_smul_add</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="n">a</span> <span class="bp">&#8226;</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">&#8226;</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">a</span> <span class="bp">&#8226;</span> <span class="n">y</span> <span class="o">:=</span>
  <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">z</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span>
  <span class="c1">-- annoying: notation is blocking progress, use show to change notation</span>
  <span class="k">have</span> <span class="n">fix</span> <span class="o">:</span> <span class="n">r0</span> <span class="bp">=</span> <span class="o">(</span><span class="mi">0</span><span class="o">:</span><span class="n">rot</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">begin</span> <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span> <span class="kd">end</span><span class="o">,</span>
  <span class="c1">-- by case analysis on x, y</span>
  <span class="n">cases</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">y</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span>
      <span class="n">rw</span> <span class="n">fix</span><span class="o">,</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">rot_add</span><span class="o">],</span>
    <span class="o">},</span>
  <span class="o">},</span>
  <span class="c1">-- induction on z</span>
  <span class="n">repeat</span> <span class="o">{</span>
  <span class="n">induction</span> <span class="n">z</span> <span class="k">with</span> <span class="n">n</span> <span class="n">negn</span><span class="o">,</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">rot_npow</span><span class="o">],</span>
  <span class="n">simp</span> <span class="o">[</span><span class="n">rot_zpow</span><span class="o">],</span>
  <span class="o">},</span>
  <span class="c1">-- by commutativity of rot +</span>
  <span class="n">apply</span> <span class="n">rot_add_comm</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">rot_add_comm</span><span class="o">,</span>
<span class="kd">end</span>

<span class="c1">-- That&#39;s all we need for (distrib_mul_action &#8484; rot)</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">distrib_mul_action</span> <span class="n">&#8484;</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_smul_zero</span><span class="o">,</span>
  <span class="n">rot_smul_add</span><span class="o">,</span>
<span class="o">&#10217;</span>
</pre></div>
</div>
</div></section>
<section id="id13">
<h4><span class="section-number">6.5.4.3. </span>semiring &#8484;<a class="headerlink" href="#id13" title="Permalink to this heading">&#61633;</a></h4>
<p>As noted above we can rely on Lean to provide a
semi-ring structure for the integers. So we don&#8217;t
have to do any more work on this issue. Here&#8217;s a
quick demo showing that Lean finds an instance on
its own.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20z_ring%20(r1%20r2%20%3A%20%E2%84%A4)%20%5Bring%20%E2%84%A4%5D%20%3A%3D%20r1%20*%20r2%0A%23reduce%20z_ring%203%204%20%20--%20no%20error%20finding%20instance" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_410.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">z_ring</span> <span class="o">(</span><span class="n">r1</span> <span class="n">r2</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">[</span><span class="n">ring</span> <span class="n">&#8484;</span><span class="o">]</span> <span class="o">:=</span> <span class="n">r1</span> <span class="bp">*</span> <span class="n">r2</span>
<span class="k">#reduce</span> <span class="n">z_ring</span> <span class="mi">3</span> <span class="mi">4</span>  <span class="c1">-- no error finding instance</span>
</pre></div>
</div>
</div></section>
<section id="module-rot">
<h4><span class="section-number">6.5.4.4. </span>module &#8484; rot<a class="headerlink" href="#module-rot" title="Permalink to this heading">&#61633;</a></h4>
<p>And with that, we have everything we need to have the
structure of a &#8484;-module of rotations (akin to a vector
space but much more general, as you can now see). It
makes sense to have integers as scalars for an additive
group of rotations, because it just amounts to iterated
addition, under which the group is closed.</p>
<p>Note that using real numbers, &#8477;, as scalars would break
our whole design. We have no way to represent half of a
symmetry rotation, for example: it wouldn&#8217;t be one, as
it&#8217;d leave a triangle rotated only halfway to the point
where it&#8217;d lay down perfectly on top of its original
form.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20Here%20it%20is.%20But%20we've%20left%20out%20a%20proof!%20TBD.%20Big%20TODO!%0Ainstance%20%3A%20module%20%E2%84%A4%20rot%20%3A%3D%0A%E2%9F%A8%20show%20%E2%88%80%20(r%20s%20%3A%20%E2%84%A4)%20(x%20%3A%20rot)%2C%20(r%20%2B%20s)%20%E2%80%A2%20x%20%3D%20r%20%E2%80%A2%20x%20%2B%20s%20%E2%80%A2%20x%2C%0A%20%20begin%0A%20%20assume%20r%20s%20m%2C%0A%20%20sorry%2C%20%20%20%20%20%20%20%20%20%20--%20oops%0A%20%20end%2C%0A%20%20begin%0A%20%20assume%20x%2C%0A%20%20exact%20rfl%2C%0A%20%20end%0A%E2%9F%A9" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_433.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Here it is. But we&#39;ve left out a proof! TBD. Big TODO!</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">module</span> <span class="n">&#8484;</span> <span class="n">rot</span> <span class="o">:=</span>
<span class="o">&#10216;</span> <span class="k">show</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="o">:</span> <span class="n">&#8484;</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">rot</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span> <span class="bp">+</span> <span class="n">s</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">r</span> <span class="bp">&#8226;</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">s</span> <span class="bp">&#8226;</span> <span class="n">x</span><span class="o">,</span>
  <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">r</span> <span class="n">s</span> <span class="n">m</span><span class="o">,</span>
  <span class="gr">sorry</span><span class="o">,</span>          <span class="c1">-- oops</span>
  <span class="kd">end</span><span class="o">,</span>
  <span class="kd">begin</span>
  <span class="k">assume</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
  <span class="kd">end</span>
<span class="o">&#10217;</span>
</pre></div>
</div>
</div></section>
</section>
<section id="foolproof-abstract-mathematics">
<h3><span class="section-number">6.5.5. </span>Foolproof abstract mathematics<a class="headerlink" href="#foolproof-abstract-mathematics" title="Permalink to this heading">&#61633;</a></h3>
<p>Now we can write foolproof abstract mathematics
involving a torsor of symmetric triangles and a
<em>module</em> of rotation actions, where rotations can
be added, subtracted, scaled, and act on triangles,
and where triangles can be subtracted yielding
rotations.</p>
<p>Also recall that we&#8217;ve already defined the torsor
of triangles over the rotation group. We really don&#8217;t
need to do anything more. The key addition was point
point subtraction (specifically tri tri subtraction,
yielding rotation). We already have an operation of
point (tri) differences, denoted -&#7525;.</p>
<p>That becomes part of our what emerges as an overall
language of <em>geometry</em> in the limited world of our
triangles and their symmetry-preserving rotations.
Here are a few examples. Notable is that we can now
compute with both points and vectors (tri and rot in
our example).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20tri%0A--%20scalar%20mult%20of%20action%20and%20its%20application%0A%23reduce%20((3%3A%E2%84%A4)%20%E2%80%A2%20r120)%20%E2%80%A2%20t120%0A%0A--%20negative%20scalar%20multiplication%20and%20application%0A%23reduce%20((-2%3A%E2%84%A4)%20%E2%80%A2%20r120)%20%E2%80%A2%20t120%0A%0A--%20scalar%20difference%20(a%20scalar)%20multiplied%20by%20rotation%20then%20acting%20on%20triangle%0A%23reduce%20(((3%3A%E2%84%A4)%20-%20(2%3A%E2%84%A4))%20%E2%80%A2%20r120)%20%E2%80%A2%20t120%0A%0A--%20addition%20of%20scaled%20and%20unscaled%20vector%2C%20acting%20on%20a%20triange%0A%23reduce%20(((3%3A%E2%84%A4)%20%E2%80%A2%20r120)%20%2B%E1%B5%A5%20r240)%20%E2%80%A2%20t120%0A%0A--%20important%3A%20function%20subtracting%20points%20yielding%20a%20rot%20then%20acting%20on%20a%20triangle%0A%23reduce%20(t0%20-%E1%B5%A5%20t120)%20%E2%80%A2%20t240" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_472.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">tri</span>
<span class="c1">-- scalar mult of action and its application</span>
<span class="k">#reduce</span> <span class="o">((</span><span class="mi">3</span><span class="o">:</span><span class="n">&#8484;</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">r120</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">t120</span>

<span class="c1">-- negative scalar multiplication and application</span>
<span class="k">#reduce</span> <span class="o">((</span><span class="bp">-</span><span class="mi">2</span><span class="o">:</span><span class="n">&#8484;</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">r120</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">t120</span>

<span class="c1">-- scalar difference (a scalar) multiplied by rotation then acting on triangle</span>
<span class="k">#reduce</span> <span class="o">(((</span><span class="mi">3</span><span class="o">:</span><span class="n">&#8484;</span><span class="o">)</span> <span class="bp">-</span> <span class="o">(</span><span class="mi">2</span><span class="o">:</span><span class="n">&#8484;</span><span class="o">))</span> <span class="bp">&#8226;</span> <span class="n">r120</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">t120</span>

<span class="c1">-- addition of scaled and unscaled vector, acting on a triange</span>
<span class="k">#reduce</span> <span class="o">(((</span><span class="mi">3</span><span class="o">:</span><span class="n">&#8484;</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">r120</span><span class="o">)</span> <span class="bp">+&#7525;</span> <span class="n">r240</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">t120</span>

<span class="c1">-- important: function subtracting points yielding a rot then acting on a triangle</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="n">t0</span> <span class="bp">-&#7525;</span> <span class="n">t120</span><span class="o">)</span> <span class="bp">&#8226;</span> <span class="n">t240</span>
</pre></div>
</div>
</div></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="A_04_Typeclasses.html" class="btn btn-neutral float-left" title="5. Typeclasses" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="genindex.html" class="btn btn-neutral float-right" title="Index" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kevin Sullivan.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>