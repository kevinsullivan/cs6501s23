<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6. Algebraic Structures &mdash; CS6501 Spring 2023 1.2.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Index" href="genindex.html" />
    <link rel="prev" title="5. Typeclasses" href="A_04_Typeclasses.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CS6501 Spring 2023
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="A_00_Introduction.html">1. CS6501 Spring 2023</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_01_Propositional_Logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_02_Constructive_Logic.html">3. Constructive Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_03_Recursive_Types.html">4. Recursive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="A_04_Typeclasses.html">5. Typeclasses</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. Algebraic Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#monoids">6.1. Monoids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extended-example">6.1.1. Extended Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#elements-operation-proofs">6.1.2. Elements, Operation, Proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monoid-typeclass">6.1.3. Monoid typeclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semigroup">6.1.4. Semigroup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#has-mul">6.1.5. has_mul</a></li>
<li class="toctree-l3"><a class="reference internal" href="#has-mul-instance">6.1.6. has_mul instance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semigroup-instance">6.1.7. semigroup instance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mul-one-class-instance">6.1.8. mul_one_class instance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-we-get">6.1.9. What we get</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#groups">6.2. Groups</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples">6.2.1. Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rotation-groups">6.2.1.1. Rotation groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#translation-groups">6.2.1.2. Translation groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chapter-plan">6.2.1.3. Chapter plan</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#typeclasses">6.2.2. Typeclasses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#group">6.2.2.1. group</a></li>
<li class="toctree-l4"><a class="reference internal" href="#monoid">6.2.2.2. monoid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#div-inv-monoid">6.2.2.3. div_inv_monoid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">6.2.2.4. div_inv_monoid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#has-inv">6.2.2.5. has_inv</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#instances">6.2.3. Instances</a></li>
<li class="toctree-l3"><a class="reference internal" href="#has-inv-rot-syms">6.2.4. has_inv rot_syms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#has-div">6.2.4.1. has_div</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aside-int">6.2.4.2. aside: &#8484; (int)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">6.2.4.3. group</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CS6501 Spring 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">6. </span>Algebraic Structures</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/A_05_Algebraic_Structures.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="algebraic-structures">
<span id="introduction"></span><h1><span class="section-number">6. </span>Algebraic Structures<a class="headerlink" href="#algebraic-structures" title="Permalink to this heading">&#61633;</a></h1>
<section id="monoids">
<h2><span class="section-number">6.1. </span>Monoids<a class="headerlink" href="#monoids" title="Permalink to this heading">&#61633;</a></h2>
<p>In this section, we&#8217;ll analyze and use the definition of monoids provided
by Lean&#8217;s <em>mathlib</em>.</p>
<section id="extended-example">
<h3><span class="section-number">6.1.1. </span>Extended Example<a class="headerlink" href="#extended-example" title="Permalink to this heading">&#61633;</a></h3>
<p>As an exceptionally simple example, we&#8217;ll define an instance of this
concept where the elements of a multiplicative monoid are <em>rotations</em>
of an equilateral triangle that leave its vertices pointing in the
same direction as the original. We call such rotations <em>symmetries</em>
of an equilateral triange.</p>
<p>Think of such a triangle with a black dot marking the top vertex when
the triangle is in an un-rotated state. The symetries are rotations
that leave the rotated triangle sitting right on top of where it was
in its unrotated state. These are rotations by 0 degrees, which
leaves the dot where it is; by 120 degrees, which rotates the dot by one
vertex counterclockwise; and by 240 degrees, which rotates the dot two
vertices counterclockwise. Rotating by 360 degrees leaves the dot exactly
where it started, and so is equal to the zero rotation.</p>
<p>These are all of the <em>rotational symmetries</em> of an equilateral triangle.
We&#8217;ll call them <em>r0</em>, <em>r120</em>, and <em>r240</em>. Again these are the <em>elements</em>
of our monoid, well call it <em>rot_syms</em>, short for the <em>rotational
symmetries of an equilateral triangle</em>.</p>
<p>To be a monoid we also need an associative operator that takes any two
monoid elements and returns another monoid element. Our operator will
work by <em>composing</em> translations, and we&#8217;ll use multiplicative notation
for this operation. As an example, if we compose r120 with r120 we get
a rotation by 240 degrees, which is r240; composing r240 and r120 is
rotates by 360 degrees giving back the original triangle, and so is
equal to r0. It&#8217;s a simple exercise to write out the <em>multiplication
table</em> for this operator.</p>
<p>Finally we need our set of elements to includes an identity element,
e, that when composed with any element, r, just yields r. Clearly
r0 serves this purpose.</p>
</section>
<section id="elements-operation-proofs">
<h3><span class="section-number">6.1.2. </span>Elements, Operation, Proofs<a class="headerlink" href="#elements-operation-proofs" title="Permalink to this heading">&#61633;</a></h3>
<p>To formally specify our monoid of rotational symmetries of a regular
triangle as a monoid, we&#8217;ll need to represent the set of rotations
and the composition operation, and we&#8217;ll need to prove that these
components satisfy the monoid laws.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20We%20represent%20the%20set%20of%20monoid%20elements%20(rotations)%20as%20a%20type%0Ainductive%20rot_syms%0A%7C%20r0%0A%7C%20r120%0A%7C%20r240%0A%0Aopen%20rot_syms%0A%0A--%20We%20represent%20the%20operation%20as%20a%20binary%20operation%20on%20this%0Adef%20rot_mul%20%3A%20rot_syms%20%E2%86%92%20rot_syms%20%E2%86%92%20rot_syms%0A%7C%20r0%20r0%20%3A%3D%20r0%0A%7C%20r0%20r120%20%3A%3D%20r120%0A%7C%20r0%20r240%20%3A%3D%20r240%0A%7C%20r120%20r0%20%3A%3D%20r120%0A%7C%20r120%20r120%20%3A%3D%20r240%0A%7C%20r120%20r240%20%3A%3D%20r0%0A%7C%20r240%20r0%20%3A%3D%20r240%0A%7C%20r240%20r120%20%3A%3D%20r0%0A%7C%20r240%20r240%20%3A%3D%20r120%0A%0A--%20We%20need%20a%20proof%20that%20r0%20is%20an%20identity%20for%20this%20operation%0A%0Atheorem%20rot_left_ident%20%3A%20%E2%88%80%20(r%20%3A%20rot_syms)%2C%20rot_mul%20r0%20r%20%3D%20r%20%20%3A%3D%0Abegin%0Aassume%20r%2C%0Acases%20r%2C%0Arepeat%20%7Bexact%20rfl%2C%7D%0Aend%0A%0Atheorem%20rot_right_ident%20%3A%20%E2%88%80%20(r%20%3A%20rot_syms)%2C%20rot_mul%20r%20%20r0%20%3D%20r%20%3A%3D%0Abegin%0Aassume%20r%2C%0Acases%20r%2C%0Arepeat%20%7Bapply%20rfl%7D%2C%0Aend%0A%0A--%20And%20we%20need%20a%20proof%20that%20the%20operation%20is%20associative%0A%0Atheorem%20rot_mul_assoc%20%3A%0A%20%20%E2%88%80%20(e1%20e2%20e3%20%3A%20rot_syms)%2C%0A%20%20%20%20rot_mul%20(rot_mul%20e1%20e2)%20e3%20%3D%20rot_mul%20e1%20(rot_mul%20e2%20e3)%20%3A%3D%0Abegin%0Aassume%20e1%20e2%20e3%2C%0A%0Acases%20e1%2C%0Arepeat%20%7B%0A%20%20cases%20e2%2C%0A%20%20repeat%20%7B%0A%20%20%20%20cases%20e3%2C%0A%20%20%20%20repeat%20%7Bexact%20rfl%7D%7D%2C%0A%20%20%7D%2C%0Aend" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_52.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- We represent the set of monoid elements (rotations) as a type</span>
<span class="kd">inductive</span> <span class="n">rot_syms</span>
<span class="bp">|</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">r240</span>

<span class="kn">open</span> <span class="n">rot_syms</span>

<span class="c1">-- We represent the operation as a binary operation on this</span>
<span class="kd">def</span> <span class="n">rot_mul</span> <span class="o">:</span> <span class="n">rot_syms</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="n">r120</span> <span class="o">:=</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="n">r240</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">r120</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">r120</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="n">r240</span> <span class="o">:=</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">r120</span> <span class="o">:=</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="n">r240</span> <span class="o">:=</span> <span class="n">r120</span>

<span class="c1">-- We need a proof that r0 is an identity for this operation</span>

<span class="kd">theorem</span> <span class="n">rot_left_ident</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="n">rot_mul</span> <span class="n">r0</span> <span class="n">r</span> <span class="bp">=</span> <span class="n">r</span>  <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">r</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">r</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">,}</span>
<span class="kd">end</span>

<span class="kd">theorem</span> <span class="n">rot_right_ident</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="n">rot_mul</span> <span class="n">r</span>  <span class="n">r0</span> <span class="bp">=</span> <span class="n">r</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">r</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">r</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">apply</span> <span class="n">rfl</span><span class="o">},</span>
<span class="kd">end</span>

<span class="c1">-- And we need a proof that the operation is associative</span>

<span class="kd">theorem</span> <span class="n">rot_mul_assoc</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span>
    <span class="n">rot_mul</span> <span class="o">(</span><span class="n">rot_mul</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="n">e3</span> <span class="bp">=</span> <span class="n">rot_mul</span> <span class="n">e1</span> <span class="o">(</span><span class="n">rot_mul</span> <span class="n">e2</span> <span class="n">e3</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e3</span><span class="o">,</span>

<span class="n">cases</span> <span class="n">e1</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span>
  <span class="n">cases</span> <span class="n">e2</span><span class="o">,</span>
  <span class="n">repeat</span> <span class="o">{</span>
    <span class="n">cases</span> <span class="n">e3</span><span class="o">,</span>
    <span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">}},</span>
  <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></section>
<section id="monoid-typeclass">
<h3><span class="section-number">6.1.3. </span>Monoid typeclass<a class="headerlink" href="#monoid-typeclass" title="Permalink to this heading">&#61633;</a></h3>
<p>That&#8217;s all we need to have a monoid. Next we assemble these
elements into an instance of Lean&#8217;s monoid typeclass. Once we
do that, we&#8217;ll benefit from all of the machinery (including
notations and other operations) that come Lean&#8217;s monoid and
its underlying typeclass definitions. So let&#8217;s look to see
exactly what&#8217;s needed to create our own monoid instance.
Here&#8217;s Lean&#8217;s definition of monoid.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40monoid%0A%2F-%0Aclass%20monoid%20(M%20%3A%20Type%20u)%20extends%20semigroup%20M%2C%20mul_one_class%20M%20%3A%3D%0A(npow%20%3A%20%E2%84%95%20%E2%86%92%20M%20%E2%86%92%20M%20%3A%3D%20npow_rec)%0A(npow_zero'%20%3A%20%E2%88%80%20x%2C%20npow%200%20x%20%3D%201%20.%20try_refl_tac)%0A(npow_succ'%20%3A%20%E2%88%80%20(n%20%3A%20%E2%84%95)%20x%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x%20.%20try_refl_tac)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_119.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">monoid</span>
<span class="c">/-</span>
<span class="cm">class monoid (M : Type u) extends semigroup M, mul_one_class M :=</span>
<span class="cm">(npow : &#8469; &#8594; M &#8594; M := npow_rec)</span>
<span class="cm">(npow_zero&#39; : &#8704; x, npow 0 x = 1 . try_refl_tac)</span>
<span class="cm">(npow_succ&#39; : &#8704; (n : &#8469;) x, npow n.succ x = x * npow n x . try_refl_tac)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>We see that a monoid on a carrier set, <em>M</em> (here of rotations), will
extend semi-group and mul_one_class typeclasses, so we&#8217;ll need to go
look at those. The typeclass itself requires an operation n_pow, which
will be defined recursively as applying a given operation <em>n</em> times.
The proofs require base and recursive step cases, which will be given
by the base and inductive rules of the given function. Let&#8217;s ignore the
details of notation for now. What&#8217;s important to know is that these
proofs are given values here that will be computed automatically
when a definition of npow is actually given.</p>
<p>The <em>major</em> insight to gain from this definition is that, to define
a monoid typeclass instance, we need to already have instances of
Lean&#8217;s semigroup and mul_one_class typeclasses. So Let&#8217;s see what
we need for those, digging down until we reach simplest typeclasses.
We&#8217;ll then build our monoid typeclass instances in a bottom-up
fashion.</p>
</section>
<section id="semigroup">
<h3><span class="section-number">6.1.4. </span>Semigroup<a class="headerlink" href="#semigroup" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40semigroup%0A%2F-%0Aclass%20semigroup%20(G%20%3A%20Type%20u)%20extends%20has_mul%20G%20%3A%3D%0A(mul_assoc%20%3A%20%E2%88%80%20a%20b%20c%20%3A%20G%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_149.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">semigroup</span>
<span class="c">/-</span>
<span class="cm">class semigroup (G : Type u) extends has_mul G :=</span>
<span class="cm">(mul_assoc : &#8704; a b c : G, a * b * c = a * (b * c))</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>We see that to define a semigroup instance we&#8217;ll need an instance
of has_mul, so let&#8217;s look at that.
TEXT.</p>
</section>
<section id="has-mul">
<h3><span class="section-number">6.1.5. </span>has_mul<a class="headerlink" href="#has-mul" title="Permalink to this heading">&#61633;</a></h3>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40has_mul%0A%2F-%0Aclass%20has_mul%20%20%20%20%20%20(%CE%B1%20%3A%20Type%20u)%20%3A%3D%20(mul%20%3A%20%CE%B1%20%E2%86%92%20%CE%B1%20%E2%86%92%20%CE%B1)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_165.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">has_mul</span>
<span class="c">/-</span>
<span class="cm">class has_mul      (&#945; : Type u) := (mul : &#945; &#8594; &#945; &#8594; &#945;)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
<section id="has-mul-instance">
<h3><span class="section-number">6.1.6. </span>has_mul instance<a class="headerlink" href="#has-mul-instance" title="Permalink to this heading">&#61633;</a></h3>
<p>Hooray, we have everything we need to define an instance of this
typeclass, namely just a multiplication operator (mul) for objects
in our monoid. That operator is rot_mul. (Note that you can define
typeclass instances without giving them names, which is typical.)</p>
<p>You see here the use of angle-brackets to specify the field
values of a given structure. It&#8217;s easier to use than has_mul.mk.</p>
</section>
<section id="semigroup-instance">
<h3><span class="section-number">6.1.7. </span>semigroup instance<a class="headerlink" href="#semigroup-instance" title="Permalink to this heading">&#61633;</a></h3>
<p>Now we&#8217;ve got what we need to specify a semigroup typeclass
instance, which simply adds the constraint (in the form of a
proof) that the operator be associative.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20check%20the%20constructor%20to%20see%20the%20required%20field%20values%0A%23check%20%40semigroup.mk%0A%2F-%0A%CE%A0%20%7BG%20%3A%20Type%20u%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20carrier%20set%20implicit%0A%20%20(mul%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20operator%0A%20%20(%E2%88%80%20(a%20b%20c%20%3A%20G)%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%20%E2%86%92%20%20--%20proof%20of%20associativity%0Asemigroup%20G%0A-%2F%0A%0Ainstance%20%3A%20semigroup%20rot_syms%20%3A%3D%20%E2%9F%A8%20rot_mul%2C%20rot_mul_assoc%20%E2%9F%A9%0A%23check%20%40mul_one_class" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_191.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- check the constructor to see the required field values</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">semigroup.mk</span>
<span class="c">/-</span>
<span class="cm">&#928; {G : Type u}                                -- carrier set implicit</span>
<span class="cm">  (mul : G &#8594; G &#8594; G),                          -- operator</span>
<span class="cm">  (&#8704; (a b c : G), a * b * c = a * (b * c)) &#8594;  -- proof of associativity</span>
<span class="cm">semigroup G</span>
<span class="cm">-/</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">semigroup</span> <span class="n">rot_syms</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">rot_mul</span><span class="o">,</span> <span class="n">rot_mul_assoc</span> <span class="o">&#10217;</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">mul_one_class</span>
</pre></div>
</div>
</div></section>
<section id="mul-one-class-instance">
<h3><span class="section-number">6.1.8. </span>mul_one_class instance<a class="headerlink" href="#mul-one-class-instance" title="Permalink to this heading">&#61633;</a></h3>
<p>To complete a typeclass instance for monoid, we also need an instance
for mul_one_class, and as we&#8217;ll now see, that in turn requires
instances of has_one and has_mul. We aready have an instance of has_mul,
so all we need to define now is has_one, which identities the identity
element in the monoid, which will then be denoted by <em>1</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40mul_one_class%0A%23check%20%40has_one%0A%23check%20%40has_mul%0A%0A%2F-%0Aclass%20mul_one_class%20(M%20%3A%20Type%20u)%20extends%20has_one%20M%2C%20has_mul%20M%20%3A%3D%0A(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%201%20*%20a%20%3D%20a)%0A(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%20a%20*%201%20%3D%20a)%0A%0Aclass%20has_one%20%20%20%20%20%20(%CE%B1%20%3A%20Type%20u)%20%3A%3D%20(one%20%3A%20%CE%B1)%0A-%2F%0Ainstance%20%3A%20has_one%20rot_syms%20%3A%3D%20%E2%9F%A8%20r0%20%E2%9F%A9%0A%0A%23check%20%40mul_one_class.mk%0A%2F-%0A%20%CE%A0%20%7BM%20%3A%20Type%20u%7D%0A%20%20%20(one%20%3A%20M)%0A%20%20%20(mul%20%3A%20M%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20%20(%E2%88%80%20(a%20%3A%20M)%2C%201%20*%20a%20%3D%20a)%20%E2%86%92%0A%20%20%20(%E2%88%80%20(a%20%3A%20M)%2C%20a%20*%201%20%3D%20a)%20%E2%86%92%0A%20%20mul_one_class%20M%0A-%2F%0Ainstance%20%3A%20mul_one_class%20rot_syms%20%3A%3D%0A%E2%9F%A8%20r0%2C%20rot_mul%2C%20rot_left_ident%2C%20rot_right_ident%20%E2%9F%A9%0A%0A--%20Finally%20we'll%20need%20a%20definition%20of%20npow%0Adef%20rot_npow%20%3A%20%E2%84%95%20%E2%86%92%20rot_syms%20%E2%86%92%20rot_syms%0A%7C%200%20x%20%3A%3D%201%0A%7C%20(nat.succ%20n')%20x%20%3A%3D%20rot_mul%20x%20(rot_npow%20n'%20x)" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_215.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">mul_one_class</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">has_one</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">has_mul</span>

<span class="c">/-</span>
<span class="cm">class mul_one_class (M : Type u) extends has_one M, has_mul M :=</span>
<span class="cm">(one_mul : &#8704; (a : M), 1 * a = a)</span>
<span class="cm">(mul_one : &#8704; (a : M), a * 1 = a)</span>

<span class="cm">class has_one      (&#945; : Type u) := (one : &#945;)</span>
<span class="cm">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">rot_syms</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">r0</span> <span class="o">&#10217;</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">mul_one_class.mk</span>
<span class="c">/-</span>
<span class="cm"> &#928; {M : Type u}</span>
<span class="cm">   (one : M)</span>
<span class="cm">   (mul : M &#8594; M &#8594; M),</span>
<span class="cm">   (&#8704; (a : M), 1 * a = a) &#8594;</span>
<span class="cm">   (&#8704; (a : M), a * 1 = a) &#8594;</span>
<span class="cm">  mul_one_class M</span>
<span class="cm">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">mul_one_class</span> <span class="n">rot_syms</span> <span class="o">:=</span>
<span class="o">&#10216;</span> <span class="n">r0</span><span class="o">,</span> <span class="n">rot_mul</span><span class="o">,</span> <span class="n">rot_left_ident</span><span class="o">,</span> <span class="n">rot_right_ident</span> <span class="o">&#10217;</span>

<span class="c1">-- Finally we&#39;ll need a definition of npow</span>
<span class="kd">def</span> <span class="n">rot_npow</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">nat.succ</span> <span class="n">n&#39;</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rot_mul</span> <span class="n">x</span> <span class="o">(</span><span class="n">rot_npow</span> <span class="n">n&#39;</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Yay. We can now assemble our monoid instance.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40monoid.mk%0A%2F-%0A%CE%A0%20%7BM%20%3A%20Type%20u_1%7D%0A%20%20(mul%20%3A%20M%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20(%E2%88%80%20(a%20b%20c%20%3A%20M)%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%20%E2%86%92%0A%20%20%CE%A0%20(one%20%3A%20M)%0A%20%20%20%20(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%201%20*%20a%20%3D%20a)%0A%20%20%20%20(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20M)%2C%20a%20*%201%20%3D%20a)%0A%20%20%20%20(npow%20%3A%20%E2%84%95%20%E2%86%92%20M%20%E2%86%92%20M)%2C%0A%20%20%20%20--%20synthesized%20parameters%0A%20%20%20%20auto_param%20(%E2%88%80%20(x%20%3A%20M)%2C%20npow%200%20x%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20M)%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20monoid%0A-%2F%0Ainstance%20%3A%20monoid%20rot_syms%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_mul%2C%0A%20%20rot_mul_assoc%2C%0A%20%201%2C%0A%20%20rot_left_ident%2C%0A%20%20rot_right_ident%2C%0A%20%20rot_npow%2C%0A%E2%9F%A9%0A%0A--%20Synthesized%20fields%0A%23check%20monoid.npow_zero'%0A%23reduce%20monoid.npow_succ'" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_249.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">monoid.mk</span>
<span class="c">/-</span>
<span class="cm">&#928; {M : Type u_1}</span>
<span class="cm">  (mul : M &#8594; M &#8594; M),</span>
<span class="cm">  (&#8704; (a b c : M), a * b * c = a * (b * c)) &#8594;</span>
<span class="cm">  &#928; (one : M)</span>
<span class="cm">    (one_mul : &#8704; (a : M), 1 * a = a)</span>
<span class="cm">    (mul_one : &#8704; (a : M), a * 1 = a)</span>
<span class="cm">    (npow : &#8469; &#8594; M &#8594; M),</span>
<span class="cm">    -- synthesized parameters</span>
<span class="cm">    auto_param (&#8704; (x : M), npow 0 x = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (x : M), npow n.succ x = x * npow n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">  monoid</span>
<span class="cm">-/</span>
<span class="kd">instance</span> <span class="o">:</span> <span class="n">monoid</span> <span class="n">rot_syms</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_mul</span><span class="o">,</span>
  <span class="n">rot_mul_assoc</span><span class="o">,</span>
  <span class="mi">1</span><span class="o">,</span>
  <span class="n">rot_left_ident</span><span class="o">,</span>
  <span class="n">rot_right_ident</span><span class="o">,</span>
  <span class="n">rot_npow</span><span class="o">,</span>
<span class="o">&#10217;</span>

<span class="c1">-- Synthesized fields</span>
<span class="k">#check</span> <span class="n">monoid.npow_zero&#39;</span>
<span class="k">#reduce</span> <span class="n">monoid.npow_succ&#39;</span>
</pre></div>
</div>
</div></section>
<section id="what-we-get">
<h3><span class="section-number">6.1.9. </span>What we get<a class="headerlink" href="#what-we-get" title="Permalink to this heading">&#61633;</a></h3>
<p>Having defined the monoid of rotational symmetries of a
regular triangle, we can now use the notations (namely 1
and <a href="#id1"><span class="problematic" id="id2">*</span></a>) associated with the monoid identity and operator.
Second, we can now define another version of foldr that
takes a Lean monoid as an argument and extends its binary
operator to n-ary, taking an arbitrary number of arguments
in a list.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20Notations!%0A%23reduce%20(1%20%3A%20rot_syms)%0A%23reduce%20(r120%20*%201)%0A%23reduce%20(r120%20*%20r120)%0A%0A--%20foldr%20using%20monoid%20notation%0Adef%20mul_foldr%20%7B%CE%B1%20%3A%20Type%7D%20%5Bmonoid%20%CE%B1%5D%20%3A%20list%20%CE%B1%20%E2%86%92%20%CE%B1%0A%7C%20%20list.nil%20%3A%3D%201%0A%7C%20(h%3A%3At)%20%3A%3D%20h%20*%20mul_foldr%20t%0A%0A%23reduce%20mul_foldr%20%5B%5D%0A%23reduce%20mul_foldr%20%5Br120%2Cr120%5D%0A%23reduce%20mul_foldr%20%5Br120%2Cr120%2Cr120%5D%0A%0A--%20we%20could%20also%20do%20this%2C%20as%20in%20the%20previous%20chapter%0Adef%20rot_comp_n%20%3A%3D%20%40mul_foldr%20rot_syms%0A%23reduce%20rot_comp_n%20%5B%5D%0A%23reduce%20rot_comp_n%20%5Br120%2Cr120%5D%0A%23reduce%20rot_comp_n%20%5Br120%2Cr120%2Cr120%5D" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_290.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Notations!</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="mi">1</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">)</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="n">r120</span> <span class="bp">*</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">#reduce</span> <span class="o">(</span><span class="n">r120</span> <span class="bp">*</span> <span class="n">r120</span><span class="o">)</span>

<span class="c1">-- foldr using monoid notation</span>
<span class="kd">def</span> <span class="n">mul_foldr</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">[</span><span class="n">monoid</span> <span class="n">&#945;</span><span class="o">]</span> <span class="o">:</span> <span class="n">list</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span>
<span class="bp">|</span>  <span class="n">list.nil</span> <span class="o">:=</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="o">:=</span> <span class="n">h</span> <span class="bp">*</span> <span class="n">mul_foldr</span> <span class="n">t</span>

<span class="k">#reduce</span> <span class="n">mul_foldr</span> <span class="o">[]</span>
<span class="k">#reduce</span> <span class="n">mul_foldr</span> <span class="o">[</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">]</span>
<span class="k">#reduce</span> <span class="n">mul_foldr</span> <span class="o">[</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">]</span>

<span class="c1">-- we could also do this, as in the previous chapter</span>
<span class="kd">def</span> <span class="n">rot_comp_n</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">mul_foldr</span> <span class="n">rot_syms</span>
<span class="k">#reduce</span> <span class="n">rot_comp_n</span> <span class="o">[]</span>
<span class="k">#reduce</span> <span class="n">rot_comp_n</span> <span class="o">[</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">]</span>
<span class="k">#reduce</span> <span class="n">rot_comp_n</span> <span class="o">[</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">,</span><span class="n">r120</span><span class="o">]</span>
</pre></div>
</div>
</div><p>In conclusion, by define a Lean monoid typeclass instance
for our set of rotation-representing objects, rot_syms, we
have obtained:</p>
<ul class="simple">
<li><p>a proven-consistent representation of this particular monoid</p></li>
<li><p>the ability to extend the monoid operator to an n-ary version</p></li>
<li><p>to do that using a &#8220;safe&#8221; (new) version of the foldr function</p></li>
<li><p>a complete, precise, abstract, computable definition of monoid</p></li>
</ul>
</section>
</section>
<section id="groups">
<h2><span class="section-number">6.2. </span>Groups<a class="headerlink" href="#groups" title="Permalink to this heading">&#61633;</a></h2>
<p>In this chapter, we&#8217;ll turn to a first study of groups.
Simply put, a group is an algebraic structure that includes
all of the structure of a monoid with the addition of an
inverse operator. This operator then makes it possible to
define the related notion of division in a group, defining
<em>div a b,</em> usually denoted (a / b), as <em>(mul a (inv b))</em>.
We&#8217;ll be particularly interested in viewing group elements,
of some type, &#945;, as specifying <em>actions</em> or <em>transformations</em>
of objects of some other (often the same) type, &#946;.</p>
<section id="examples">
<h3><span class="section-number">6.2.1. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this heading">&#61633;</a></h3>
<p>As concrete examples let&#8217;s consider two groups, one whose
elements represent rotation actions that can be applied to
objects in some 3-D space, and one whose elements represent
translations (straight-line movements) of objects. We&#8217;ll
look at the concept of a rotation group first.</p>
<section id="rotation-groups">
<h4><span class="section-number">6.2.1.1. </span>Rotation groups<a class="headerlink" href="#rotation-groups" title="Permalink to this heading">&#61633;</a></h4>
<p>In this view, the multiplication operation of the group is
understood as <em>composing</em> actions. If <em>a1</em> and <em>a2</em> are two
rotations, for example, then <em>(a2 * a1)</em> is the overall
rotation that results when rotation <em>a1</em> is followed by
rotation <em>a2</em>. That every group also has the structure of
a monoid let&#8217;s us fold any arbitrary sequence of actions
to obtain a single resultant action, also in the group.</p>
<p>The inverse operation of the group is then understood as a
<em>undo</em> action, one for each and every action in the group.
If <em>a</em> is 90 degree counter-clockwise rotation in the 2-D
plane, for example, then <em>a&#8315;&#185;</em> is would be the 90 degree
<em>clockwise</em> rotation that undoes the effect of <em>a</em>. The
overall action, <em>a&#8315;&#185; * a,</em> is thus <em>e</em>, the action that
performs no rotation at all.</p>
</section>
<section id="translation-groups">
<h4><span class="section-number">6.2.1.2. </span>Translation groups<a class="headerlink" href="#translation-groups" title="Permalink to this heading">&#61633;</a></h4>
<p>As another example of a group, consider a vector space,
familiar from basic linear algebra. It is a group. The
elements are vectors. A vector, v, acts on an object, p,
by <em>translating</em> it through a straight-line motion by a
distance, and in the direction, of v. Vector addition is
the (additive) group operator, so <em>v2 + v1</em> is the action
that has the effect of translating an object by v1 then
by v2. The zero vector is the group identity that leaves
objects unchanged. Finally, the (additive) inverse, -v,
of a vector, v, undoes the action of v so that the effect
of v + (-v), usually written v - v, does no translation
at all. It&#8217;s the zero vector.</p>
</section>
<section id="chapter-plan">
<h4><span class="section-number">6.2.1.3. </span>Chapter plan<a class="headerlink" href="#chapter-plan" title="Permalink to this heading">&#61633;</a></h4>
<p>In the rest of this chapter, we&#8217;ll work out an extended
example of a formal specification of, and of computation
involving, a small, discrete, finite group, namely the
group of <em>rotational symmetries</em> of an equilateral triangle,
In the first section, we&#8217;ll formalize the rotation group
itself. In the second section, we&#8217;ll formalize the group
action, of rotations on (representations of) equilateral
triangles.</p>
<p>A rotation of this kind rotates an equilateral triangle by
an amount that makes the resulting triang sit right on top
of the original equilateral triangle. These are rotations
by 0, 120, and 240 degrees. There are no other rotational
symmetries of such a triangle.</p>
<p>A group structure on a collection of objects of a given
type, &#945;, is (typically) specified in Lean by instantiating
the <em>group</em> typeclass for &#945;. The group typeclass extends
from several parent typclasses, including monoid, which
reflects the fact that every group with its operator and
identity also satisfies the monoid axioms.</p>
<p>We&#8217;ll use the same method as in the last section to analyze
and then provide the values needed to instantiate the group
typeclass for a new type, with three values, representing the
set of symmetry rotations. We&#8217;ll start top-down, with Lean&#8217;s
group typeclass, see what typeclasses it extends, and then
construct the elements needed to instantiate all of these
typeclasses, finally assembing all of these pieces into a
group typeclass instance for our set of rotation-representing
group elements.</p>
</section>
</section>
<section id="typeclasses">
<h3><span class="section-number">6.2.2. </span>Typeclasses<a class="headerlink" href="#typeclasses" title="Permalink to this heading">&#61633;</a></h3>
<p>In this section we&#8217;ll go over the numerous typeclasses that
have to be instantiated before the group class can be.</p>
<section id="group">
<h4><span class="section-number">6.2.2.1. </span>group<a class="headerlink" href="#group" title="Permalink to this heading">&#61633;</a></h4>
<p>Here&#8217;s the definition of the group typeclass in Lean.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40group%0A%2F-%0Aclass%20group%20(G%20%3A%20Type%20u)%20extends%20div_inv_monoid%20G%20%3A%3D%0A(mul_left_inv%20%3A%20%E2%88%80%20a%20%3A%20G%2C%20a%E2%81%BB%C2%B9%20*%20a%20%3D%201)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_114.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">group</span>
<span class="c">/-</span>
<span class="cm">class group (G : Type u) extends div_inv_monoid G :=</span>
<span class="cm">(mul_left_inv : &#8704; a : G, a&#8315;&#185; * a = 1)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>Every group is a monoid but with some additional structure,
namely inverses for every element. Inverses in turn enable
the definition division (multiplication by inverse) and the
definition of exponentiation of an element to integer powers,
including negatives.</p>
<p>[KS: Bothered by mismatch between hierarchy as taught in
school and the weirdly refactored abstractions we&#8217;re seeing
here.]</p>
</section>
<section id="monoid">
<h4><span class="section-number">6.2.2.2. </span>monoid<a class="headerlink" href="#monoid" title="Permalink to this heading">&#61633;</a></h4>
<p>In Lean, the statement that every group is automatically
a monoid means a few things. First, the group typeclass
builds on (<em>extends</em>) monoid. Second, given  group typeclass
instance it will always be possible to extract from it a
monoid instance.</p>
<p>As something of a detailed design detail, In Lean, the
group class doesn&#8217;t extend from monoid directly. Rather
it extends a typeclass call div_inv_monoid, representing
a monoid enriched with an inverse operation that behaves
like one, and a division operation defined simply as
(monoid) multiplication/composition by the inverse of
the second argument.</p>
</section>
<section id="div-inv-monoid">
<h4><span class="section-number">6.2.2.3. </span>div_inv_monoid<a class="headerlink" href="#div-inv-monoid" title="Permalink to this heading">&#61633;</a></h4>
<p>An instance of <em>div_inv_monoid &#945;</em> provides</p>
<ul class="simple">
<li><p>inv: binary operation, a&#8315;&#185;, from has_inv</p></li>
<li><p>div: definition of a / b to be a * b&#8315;&#185;</p></li>
<li><p>div_eq_mul_inv: proof of &#8704; a b : G, a / b = a * b&#8315;&#185;</p></li>
<li><p>left inverse: multiplying by inverse on left yields 1 <em>(&#8704; a, a&#8315;&#185; * a = 1)</em></p></li>
</ul>
<p>, implements a&#8315;&#185; inverse operation</p>
<p>We will now drill down on the div_inv_monoid typeclass.</p>
<p>As a reminder, here it is again. We&#8217;ll first look at the
classes it inherits, and then the field it adds to those
from its parent classes.</p>
</section>
<section id="id3">
<h4><span class="section-number">6.2.2.4. </span>div_inv_monoid<a class="headerlink" href="#id3" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%2F-%0Aclass%20div_inv_monoid%20(G%20%3A%20Type%20u)%20extends%20monoid%20G%2C%20has_inv%20G%2C%20has_div%20G%20%3A%3D%0A(div%20%3A%3D%20%CE%BB%20a%20b%2C%20a%20*%20b%E2%81%BB%C2%B9)%0A(div_eq_mul_inv%20%3A%20%E2%88%80%20a%20b%20%3A%20G%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9%20.%20try_refl_tac)%0A(zpow%20%3A%20%E2%84%A4%20%E2%86%92%20G%20%E2%86%92%20G%20%3A%3D%20zpow_rec)%0A(zpow_zero'%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%20zpow%200%20a%20%3D%201%20.%20try_refl_tac)%0A(zpow_succ'%20%3A%0A%20%20%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20zpow%20(int.of_nat%20n)%20a%20.%20try_refl_tac)%0A(zpow_neg'%20%3A%0A%20%20%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(-%5B1%20%2B%20n%5D)%20a%20%3D%20(zpow%20n.succ%20a)%E2%81%BB%C2%B9%20.%20try_refl_tac)%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_170.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c">/-</span>
<span class="cm">class div_inv_monoid (G : Type u) extends monoid G, has_inv G, has_div G :=</span>
<span class="cm">(div := &#955; a b, a * b&#8315;&#185;)</span>
<span class="cm">(div_eq_mul_inv : &#8704; a b : G, a / b = a * b&#8315;&#185; . try_refl_tac)</span>
<span class="cm">(zpow : &#8484; &#8594; G &#8594; G := zpow_rec)</span>
<span class="cm">(zpow_zero&#39; : &#8704; (a : G), zpow 0 a = 1 . try_refl_tac)</span>
<span class="cm">(zpow_succ&#39; :</span>
<span class="cm">  &#8704; (n : &#8469;) (a : G), zpow (int.of_nat n.succ) a = a * zpow (int.of_nat n) a . try_refl_tac)</span>
<span class="cm">(zpow_neg&#39; :</span>
<span class="cm">  &#8704; (n : &#8469;) (a : G), zpow (-[1 + n]) a = (zpow n.succ a)&#8315;&#185; . try_refl_tac)</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>This typeclass extends from the monoid, has_inv, and has_div classes
and then adds several additional fields. Let&#8217;s first see what fields
div_inv_monoid inherits from its parent classes.</p>
<p>From <em>monoid</em>, div_inv_monoid inherits the following:</p>
<ul class="simple">
<li><p>mul, an associative binary operator, with notation (a * b)</p></li>
<li><p>e, an identity element for mul, with notation 1</p></li>
<li><p>npow, for computing a&#8319; by multiplication of a by itself n times</p></li>
<li><p>npow_zero&#8217;, a proof that a&#8304; = 1</p></li>
<li><p>npow_succ&#8217;, a proof that npow n a is multiplication iterated n times (&#8704; (n : &#8469;) x, npow n.succ x = x * npow n x . try_refl_tac))</p></li>
</ul>
<p>From <em>has_inv</em>, div_inv_monoid inherits a single unary operator,
inv (for inverse), for monoid elements, wotj the notation, a&#8315;&#185;.
From the has_div class, div_inv_monoid obtains a single binary
operation, div, with notation (a / b) for (div a b).  So far, then,
a div_inv_monoid instance will provide operators and notations for
multiplication, exponentiation by a natural number, inverse, and
division for monoid elements.</p>
<p>The div_inv_monoid class then adds multiple fields values to
extend and constrain this inherited structure. Let&#8217;s look at each
of these fields in turn.</p>
<ul class="simple">
<li><p>div, defining (a / b) as a * b&#8315;&#185;</p></li>
<li><p>div_eq_mul_inv, requiring that division be multiplication by inverse</p></li>
<li><p>zpow, which generalizes exponentiation to include negative exponents</p></li>
<li><p>a proof of (&#8704; (x : rot_syms), rot_npow 0 x = 1)</p></li>
<li><p>a proof of (&#8704; (n : &#8469;) (x : rot_syms), rot_npow n.succ x = x * rot_npow n x)</p></li>
<li><p>a proof of (&#8704; (a b : rot_syms), a / b = a * b&#8315;&#185;)</p></li>
<li><p>a proof of (&#8704; (n : &#8469;) (a : rot_syms), rot_zpow (int.of_nat n.succ) a = a * rot_zpow (int.of_nat n) a) :=</p></li>
<li><p>a proof of (&#8704; (n : &#8469;) (a : rot_syms), rot_zpow -[1+ n] a = (rot_zpow &#8593;(n.succ) a)&#8315;&#185;)</p></li>
</ul>
<p>Finally, to all of this structure the <em>group</em> typeclass adds one
additional constraint, (mul_left_inv : &#8704; a : G, a&#8315;&#185; * a = 1), which
requires that inv and mul work together correctly, in the sense that
for any monoid element, a, that mul (inv a) a = 1. We can say that
it requires a&#8315;&#185; to always act as a <em>left inverse</em> for any <em>a</em>.</p>
<p>To create a group typeclass instance, we need to instantiate the
parent typeclasses and then apply the group typeclass constructor
to the right arguments. We will now construct a group typeclass
instance for rot_syms in a bottom-up manner, first constructing
instances for the parent typeclasses and finally instantiating
the group typeclass.</p>
<p>To see what values have to be given to a typeclass constructor,
you can #check the constructor type. So let&#8217;s now do this for
the parent typeclasses, starting with has_inv and has_div, then
for div_inv_monoid, and finally for group.</p>
<p>We&#8217;ll tackle has_inv first. We check the constructor type to
see what arguments it needs. Then we construct the right
argument values: in this case an implementation of inverse
(inv) for rot_syms in particular. And finally we instantiate
the typeclass.</p>
</section>
<section id="has-inv">
<h4><span class="section-number">6.2.2.5. </span>has_inv<a class="headerlink" href="#has-inv" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40has_inv.mk%0A%2F-%0A%CE%A0%20%7B%CE%B1%20%3A%20Type%20u%7D%2C%20(%CE%B1%20%E2%86%92%20%CE%B1)%20%E2%86%92%20has_inv%20%CE%B1%0A%0AThe%20has_inv%20typeclass%20requires%20an%20implementation%0Aof%20a%20unary%20operation%2C%20inv%2C%20on%20%CE%B1%2C%20and%20provides%20a%E2%81%BB%C2%B9%0Aas%20a%20standard%20mathematical%20notation.%20It%20does%20not%0Aconstrain%20the%20behavior%20of%20inv%20in%20any%20way%2C%20leaving%0Athat%20task%20to%20downstream%20typeclasses%20that%20inherit%0Afrom%20this%20one.%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_245.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">has_inv.mk</span>
<span class="c">/-</span>
<span class="cm">&#928; {&#945; : Type u}, (&#945; &#8594; &#945;) &#8594; has_inv &#945;</span>

<span class="cm">The has_inv typeclass requires an implementation</span>
<span class="cm">of a unary operation, inv, on &#945;, and provides a&#8315;&#185;</span>
<span class="cm">as a standard mathematical notation. It does not</span>
<span class="cm">constrain the behavior of inv in any way, leaving</span>
<span class="cm">that task to downstream typeclasses that inherit</span>
<span class="cm">from this one.</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div></section>
</section>
<section id="instances">
<h3><span class="section-number">6.2.3. </span>Instances<a class="headerlink" href="#instances" title="Permalink to this heading">&#61633;</a></h3>
<p>We&#8217;ll build the required instances to enable construction
of a group typeclass instance for elements of type rot_syms.</p>
</section>
<section id="has-inv-rot-syms">
<h3><span class="section-number">6.2.4. </span>has_inv rot_syms<a class="headerlink" href="#has-inv-rot-syms" title="Permalink to this heading">&#61633;</a></h3>
<p>To instantiate has_inv, we have to provide an implementation
of this operation for arguments of type rot_syms. Once we have
that, the rest is straightforward. We&#8217;ll call our overloaded
implementation function, rot_inv. We define the function by
case analysis on the rot_syms argument, returning in each case
the rot_syms value that when multiplied by the argument returns
1.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20rot_syms%0Adef%20rot_inv%20%3A%20rot_syms%20%E2%86%92%20rot_syms%20%20%20%20%20%20%20%20%20%20%20--%20HOMEWORK%0A%7C%20r0%20%3A%3D%20r0%0A%7C%20r120%20%3A%3D%20r240%0A%7C%20r240%20%3A%3D%20r120%0A%0Ainstance%20%3A%20has_inv%20rot_syms%20%3A%3D%20%E2%9F%A8%20rot_inv%20%E2%9F%A9%20%20--%20%E2%9F%A8%20%E2%9F%A9%20applies%20mk" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_277.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">rot_syms</span>
<span class="kd">def</span> <span class="n">rot_inv</span> <span class="o">:</span> <span class="n">rot_syms</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span>           <span class="c1">-- HOMEWORK</span>
<span class="bp">|</span> <span class="n">r0</span> <span class="o">:=</span> <span class="n">r0</span>
<span class="bp">|</span> <span class="n">r120</span> <span class="o">:=</span> <span class="n">r240</span>
<span class="bp">|</span> <span class="n">r240</span> <span class="o">:=</span> <span class="n">r120</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_inv</span> <span class="n">rot_syms</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">rot_inv</span> <span class="o">&#10217;</span>  <span class="c1">-- &#10216; &#10217; applies mk</span>
</pre></div>
</div>
</div><p>Instantiating has_inv gives us the &#8315;&#185; notation,
which we can use to assert that multiplying on
the left by the inverse always yields the identity.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20%3A%20%E2%88%80%20(r%20%3A%20rot_syms)%2C%20(r%E2%81%BB%C2%B9%20*%20r%20%3D%201)%20%3A%3D%0Abegin%0Aassume%20r%2C%0Acases%20r%2C%0Arepeat%20%7Bexact%20rfl%2C%20%7D%2C%0Aend" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_291.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">r</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="o">(</span><span class="n">r</span><span class="bp">&#8315;&#185;</span> <span class="bp">*</span> <span class="n">r</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">r</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">r</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span> <span class="o">},</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Next we do the same thing for has_div: (1) define a binary
operation, rot_div, to use in overloading the generic div
function for values of type rot_syms; then (2) instantiate
the div typeclass using this value, which, among other things,
will provides (a / b) as a standard notation for a * b&#8315;&#185;
(which in turn of course desugars to mul a (inv b)).</p>
<section id="has-div">
<h4><span class="section-number">6.2.4.1. </span>has_div<a class="headerlink" href="#has-div" title="Permalink to this heading">&#61633;</a></h4>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=def%20rot_div%20%3A%20rot_syms%20%E2%86%92%20rot_syms%20%E2%86%92%20rot_syms%20%3A%3D%20%CE%BB%20a%20b%2C%20a%20*%20b%E2%81%BB%C2%B9%0A%0Ainstance%20%3A%20has_div%20rot_syms%20%3A%3D%20%E2%9F%A8%20rot_div%20%E2%9F%A9%0A%0Aexample%20%3A%20r240%20%2F%20r240%20%3D%201%20%3A%3D%20rfl" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_310.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">rot_div</span> <span class="o">:</span> <span class="n">rot_syms</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">&#8315;&#185;</span>

<span class="kd">instance</span> <span class="o">:</span> <span class="n">has_div</span> <span class="n">rot_syms</span> <span class="o">:=</span> <span class="o">&#10216;</span> <span class="n">rot_div</span> <span class="o">&#10217;</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">r240</span> <span class="bp">/</span> <span class="n">r240</span> <span class="bp">=</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20%40div_inv_monoid.mk%0A%2F-%0Adiv_inv_monoid.mk%20%3A%0A%20%20%CE%A0%20--%20arguments%0A%20%20%20%20%7BG%20%3A%20Type%20u_1%7D%0A%20%20%20%20(mul%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20%20%20(mul_assoc%20%3A%20%E2%88%80%20(a%20b%20c%20%3A%20G)%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%0A%20%20%20%20(one%20%3A%20G)%0A%20%20%20%20(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%201%20*%20a%20%3D%20a)%0A%20%20%20%20(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%20a%20*%201%20%3D%20a)%0A%20%20%20%20(npow%20%3A%20%E2%84%95%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20%20%20(npow_zero'%20%3A%20auto_param%20(%E2%88%80%20(x%20%3A%20G)%2C%20npow%200%20x%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(npow_succ'%20%3A%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20G)%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(inv%20%3A%20G%20%E2%86%92%20G)%0A%20%20%20%20(div%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%2C%20%20--%20comma%0A%20%20%20%20auto_param%20(%E2%88%80%20(a%20b%20%3A%20G)%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%CE%A0%20(zpow%20%3A%20%E2%84%A4%20%E2%86%92%20G%20%E2%86%92%20G)%2C%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(a%20%3A%20G)%2C%20zpow%200%20a%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20zpow%20(int.of_nat%20n)%20a)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20-%5B1%2B%20n%5D%20a%20%3D%20(zpow%20%E2%86%91(n.succ)%20a)%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20div_inv_monoid%20G%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_320.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">div_inv_monoid.mk</span>
<span class="c">/-</span>
<span class="cm">div_inv_monoid.mk :</span>
<span class="cm">  &#928; -- arguments</span>
<span class="cm">    {G : Type u_1}</span>
<span class="cm">    (mul : G &#8594; G &#8594; G)</span>
<span class="cm">    (mul_assoc : &#8704; (a b c : G), a * b * c = a * (b * c))</span>
<span class="cm">    (one : G)</span>
<span class="cm">    (one_mul : &#8704; (a : G), 1 * a = a)</span>
<span class="cm">    (mul_one : &#8704; (a : G), a * 1 = a)</span>
<span class="cm">    (npow : &#8469; &#8594; G &#8594; G)</span>
<span class="cm">    (npow_zero&#39; : auto_param (&#8704; (x : G), npow 0 x = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (npow_succ&#39; : auto_param (&#8704; (n : &#8469;) (x : G), npow n.succ x = x * npow n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (inv : G &#8594; G)</span>
<span class="cm">    (div : G &#8594; G &#8594; G),  -- comma</span>
<span class="cm">    auto_param (&#8704; (a b : G), a / b = a * b&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">    &#928; (zpow : &#8484; &#8594; G &#8594; G),</span>
<span class="cm">      auto_param (&#8704; (a : G), zpow 0 a = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : G), zpow (int.of_nat n.succ) a = a * zpow (int.of_nat n) a) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : G), zpow -[1+ n] a = (zpow &#8593;(n.succ) a)&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">  div_inv_monoid G</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>From the constructor type we can see that we&#8217;ll need to provide
explicit argument values for mul, mul_assoc, one, one_mul, mul_one,
npow, npow_zero&#8217;, and npow_succ&#8217;, all which we already have from
our instantiation of the monoid typeclass. We&#8217;ll also need functions
for inv and div on rot_syms elements, which we just produced. Finally
we&#8217;ll need an implementation of zpow along proofs that it&#8217;s behavior
satisfies certain axiom.</p>
<p>Let&#8217;s talk about zpow first. As you will recall, the npow function
computes a&#8319; (a multiplied by itself n times), where a is any monoid
element and n is any <em>natural number</em>, i.e., non-negative exponent
value. The zpow function, by contrast, computes a&#7611;, where z is any
integer value. If m is non-negative, then a&#7504; is just (npow m a) but
returning an integer. If m is negative, we define a&#7504; = 1 / a&#8315;&#7504;, as
in ordinary arithmetic. The division here is of course the monoid
div function.</p>
<p>We haven&#8217;t previously defined a function with integer inputs, nor
have we seen how the int type is defined in Lean. We will define
zpow by case analysis on its int argument, where the two cases
correspond to non-negative and negative values, respectively. To
prepare to define zpow, we need to understand the int type in more
details, so let&#8217;s do that next, ending with a definition of zpow.</p>
</section>
<section id="aside-int">
<h4><span class="section-number">6.2.4.2. </span>aside: &#8484; (int)<a class="headerlink" href="#aside-int" title="Permalink to this heading">&#61633;</a></h4>
<p>The integer type has two constructors. The first takes a natural
number, n, and returns it packaged up as an integer, int.of_nat n.
The second takes a natural number, n, and returns a term, namely
(int.neg_succ_of_nat n), representing -(n+1).</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20int%0A%2F-%0Ainductive%20int%20%3A%20Type%0A%7C%20of_nat%20%3A%20nat%20%E2%86%92%20int%0A%7C%20neg_succ_of_nat%20%3A%20nat%20%E2%86%92%20int%0A-%2F" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_377.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">int</span>
<span class="c">/-</span>
<span class="cm">inductive int : Type</span>
<span class="cm">| of_nat : nat &#8594; int</span>
<span class="cm">| neg_succ_of_nat : nat &#8594; int</span>
<span class="cm">-/</span>
</pre></div>
</div>
</div><p>Example will help. First, (int.of_nat 3) represents the <em>integer,</em>
not the natural number, 3. Second, the term, (int.neg_succ_of_nat n),
represents the integer, -(n+1), so (int.neg_succ_of_nat 0) represents
-1, while (int.neg_succ_of_nat 4) represents the integer value, -5.
Admittedly the constructors seem strange at first, but they do provide
one term for each and every integer. The +1 in the second assures that
we don&#8217;t end up with two distinct representations of 0.</p>
<p>In any case, we can now define zpow for rot_syms by case analysis on
the <em>int</em> argument. The only remaining question is what to do in each
case.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20hint%3A%20think%20about%20rot_npow%20from%20monoid%0Adef%20rot_zpow%20%3A%20%E2%84%A4%20%E2%86%92%20rot_syms%20%E2%86%92%20rot_syms%0A%7C%20(int.of_nat%20n)%20r%20%3A%3D%20rot_npow%20n%20r%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20HOMEWORK%0A%7C%20(int.neg_succ_of_nat%20n)%20r%20%3A%3D%20(rot_npow%20(n%2B1)%20r)%E2%81%BB%C2%B9%20%20%20--%20HOMEWORK" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_398.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- hint: think about rot_npow from monoid</span>
<span class="kd">def</span> <span class="n">rot_zpow</span> <span class="o">:</span> <span class="n">&#8484;</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span> <span class="bp">&#8594;</span> <span class="n">rot_syms</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int.of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">rot_npow</span> <span class="n">n</span> <span class="n">r</span>                    <span class="c1">-- HOMEWORK</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">int.neg_succ_of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="n">r</span> <span class="o">:=</span> <span class="o">(</span><span class="n">rot_npow</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">r</span><span class="o">)</span><span class="bp">&#8315;&#185;</span>   <span class="c1">-- HOMEWORK</span>
</pre></div>
</div>
</div><p>We now have all the building blocks needed to assemble
an instance of div_inv_monoid for objects of type rot_syms.
Here&#8217;s the constructor type, again. Lean will infer values
of each field marked as auto_param, so when applying the
constructor, just use _ for each of these field values.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=--%20just%20to%20be%20explicit%2C%20we%20already%20have%20the%20following%20two%20proofs%0Alemma%20rot_npow_zero%20%3A%20(%E2%88%80%20(x%20%3A%20rot_syms)%2C%20rot_npow%200%20x%20%3D%201)%20%3A%3D%0A%20%20%20monoid.npow_zero'%0A%0Alemma%20rot_npow_succ%20%3A%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20rot_syms)%2C%20rot_npow%20n.succ%20x%20%3D%20x%20*%20rot_npow%20n%20x)%20%3A%3D%0A%20%20monoid.npow_succ'%0A%0A--%20We%20need%20related%20proofs%20linking%20div%20and%20inv%20and%20proofs%20of%20axioms%20for%20zpow%0Alemma%20rot_div_inv%20%3A%20(%E2%88%80%20(a%20b%20%3A%20rot_syms)%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9)%20%3A%3D%0Abegin%0Aassume%20a%20b%2C%0Aexact%20rfl%2C%0Aend%0A%0Alemma%20rot_zpow_non_neg%20%3A%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20rot_syms)%2C%20rot_zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20rot_zpow%20(int.of_nat%20n)%20a)%20%3A%3D%0Abegin%0Aassume%20n%20a%2C%0Aexact%20rfl%2C%0Aend%0A%0Adef%20rot_zpow_neg%20%3A%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20rot_syms)%2C%20rot_zpow%20-%5B1%2B%20n%5D%20a%20%3D%20(rot_zpow%20%E2%86%91(n.succ)%20a)%E2%81%BB%C2%B9)%20%3A%3D%0Abegin%0Aassume%20n%20a%2C%0Aexact%20rfl%2C%0Aend%0A%0A%23check%20%40div_inv_monoid.mk%0A%2F-%0Adiv_inv_monoid.mk%20%3A%0A%20%20%CE%A0%20--%20arguments%0A%20%20%20%20%7BG%20%3A%20Type%20u_1%7D%0A%20%20%20%20(mul%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20%20%20(mul_assoc%20%3A%20%E2%88%80%20(a%20b%20c%20%3A%20G)%2C%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%0A%20%20%20%20(one%20%3A%20G)%0A%20%20%20%20(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%201%20*%20a%20%3D%20a)%0A%20%20%20%20(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%20a%20*%201%20%3D%20a)%0A%20%20%20%20(npow%20%3A%20%E2%84%95%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20%20%20(npow_zero'%20%3A%20auto_param%20(%E2%88%80%20(x%20%3A%20G)%2C%20npow%200%20x%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(npow_succ'%20%3A%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20G)%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20%20%20(inv%20%3A%20G%20%E2%86%92%20G)%0A%20%20%20%20(div%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%2C%20%20--%20comma%0A%20%20%20%20auto_param%20(%E2%88%80%20(a%20b%20%3A%20G)%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%CE%A0%20(zpow%20%3A%20%E2%84%A4%20%E2%86%92%20G%20%E2%86%92%20G)%2C%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(a%20%3A%20G)%2C%20zpow%200%20a%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20zpow%20(int.of_nat%20n)%20a)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20-%5B1%2B%20n%5D%20a%20%3D%20(zpow%20%E2%86%91(n.succ)%20a)%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous)%20%E2%86%92%0A%20%20div_inv_monoid%20G%0A-%2F%0A%0A%23check%20rot_npow%0A%0Ainstance%20div_inv_monoid_rot_syms%20%3A%20div_inv_monoid%20rot_syms%20%3A%3D%0A%E2%9F%A8%0A%20%20rot_mul%2C%0A%20%20rot_mul_assoc%2C%0A%20%201%2C%0A%20%20rot_left_ident%2C%0A%20%20rot_right_ident%2C%0A%20%20rot_npow%2C%0A%20%20rot_npow_zero%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20autoparam%0A%20%20rot_npow_succ%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20autoparam%0A%20%20rot_inv%2C%0A%20%20rot_div%2C%0A%20%20rot_div_inv%2C%0A%20%20rot_zpow%2C%0A%20%20rot_npow_zero%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20same%20proof%20again%0A%20%20rot_zpow_non_neg%2C%20%20%20%20%20%20%20%20%20%20%20%20%20--%20explicit%20typing%20needed%0A%20%20rot_zpow_neg%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20same%0A%E2%9F%A9%0A%0A%2F-%0ANow%20we%20can%20see%20the%20structure%20we've%20built!%0AThe%20proofs%20are%20erased%20in%20this%20presentation%0Aand%20only%20the%20computational%20data%20are%20named.%0A-%2F%0A%23reduce%20%40div_inv_monoid_rot_syms" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_411.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- just to be explicit, we already have the following two proofs</span>
<span class="kd">lemma</span> <span class="n">rot_npow_zero</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="n">rot_npow</span> <span class="mi">0</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
   <span class="n">monoid.npow_zero&#39;</span>

<span class="kd">lemma</span> <span class="n">rot_npow_succ</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="n">rot_npow</span> <span class="n">n.succ</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">rot_npow</span> <span class="n">n</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
  <span class="n">monoid.npow_succ&#39;</span>

<span class="c1">-- We need related proofs linking div and inv and proofs of axioms for zpow</span>
<span class="kd">lemma</span> <span class="n">rot_div_inv</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="n">a</span> <span class="bp">/</span> <span class="n">b</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="bp">&#8315;&#185;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">lemma</span> <span class="n">rot_zpow_non_neg</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="n">rot_zpow</span> <span class="o">(</span><span class="n">int.of_nat</span> <span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">rot_zpow</span> <span class="o">(</span><span class="n">int.of_nat</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">def</span> <span class="n">rot_zpow_neg</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="n">rot_zpow</span> <span class="bp">-</span><span class="o">[</span><span class="mi">1</span><span class="bp">+</span> <span class="n">n</span><span class="o">]</span> <span class="n">a</span> <span class="bp">=</span> <span class="o">(</span><span class="n">rot_zpow</span> <span class="bp">&#8593;</span><span class="o">(</span><span class="n">n.succ</span><span class="o">)</span> <span class="n">a</span><span class="o">)</span><span class="bp">&#8315;&#185;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">n</span> <span class="n">a</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">rfl</span><span class="o">,</span>
<span class="kd">end</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">div_inv_monoid.mk</span>
<span class="c">/-</span>
<span class="cm">div_inv_monoid.mk :</span>
<span class="cm">  &#928; -- arguments</span>
<span class="cm">    {G : Type u_1}</span>
<span class="cm">    (mul : G &#8594; G &#8594; G)</span>
<span class="cm">    (mul_assoc : &#8704; (a b c : G), a * b * c = a * (b * c))</span>
<span class="cm">    (one : G)</span>
<span class="cm">    (one_mul : &#8704; (a : G), 1 * a = a)</span>
<span class="cm">    (mul_one : &#8704; (a : G), a * 1 = a)</span>
<span class="cm">    (npow : &#8469; &#8594; G &#8594; G)</span>
<span class="cm">    (npow_zero&#39; : auto_param (&#8704; (x : G), npow 0 x = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (npow_succ&#39; : auto_param (&#8704; (n : &#8469;) (x : G), npow n.succ x = x * npow n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">    (inv : G &#8594; G)</span>
<span class="cm">    (div : G &#8594; G &#8594; G),  -- comma</span>
<span class="cm">    auto_param (&#8704; (a b : G), a / b = a * b&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">    &#928; (zpow : &#8484; &#8594; G &#8594; G),</span>
<span class="cm">      auto_param (&#8704; (a : G), zpow 0 a = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : G), zpow (int.of_nat n.succ) a = a * zpow (int.of_nat n) a) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">      auto_param (&#8704; (n : &#8469;) (a : G), zpow -[1+ n] a = (zpow &#8593;(n.succ) a)&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous) &#8594;</span>
<span class="cm">  div_inv_monoid G</span>
<span class="cm">-/</span>

<span class="k">#check</span> <span class="n">rot_npow</span>

<span class="kd">instance</span> <span class="n">div_inv_monoid_rot_syms</span> <span class="o">:</span> <span class="n">div_inv_monoid</span> <span class="n">rot_syms</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
  <span class="n">rot_mul</span><span class="o">,</span>
  <span class="n">rot_mul_assoc</span><span class="o">,</span>
  <span class="mi">1</span><span class="o">,</span>
  <span class="n">rot_left_ident</span><span class="o">,</span>
  <span class="n">rot_right_ident</span><span class="o">,</span>
  <span class="n">rot_npow</span><span class="o">,</span>
  <span class="n">rot_npow_zero</span><span class="o">,</span>                <span class="c1">-- autoparam</span>
  <span class="n">rot_npow_succ</span><span class="o">,</span>                <span class="c1">-- autoparam</span>
  <span class="n">rot_inv</span><span class="o">,</span>
  <span class="n">rot_div</span><span class="o">,</span>
  <span class="n">rot_div_inv</span><span class="o">,</span>
  <span class="n">rot_zpow</span><span class="o">,</span>
  <span class="n">rot_npow_zero</span><span class="o">,</span>                <span class="c1">-- same proof again</span>
  <span class="n">rot_zpow_non_neg</span><span class="o">,</span>             <span class="c1">-- explicit typing needed</span>
  <span class="n">rot_zpow_neg</span><span class="o">,</span>                 <span class="c1">-- same</span>
<span class="o">&#10217;</span>

<span class="c">/-</span>
<span class="cm">Now we can see the structure we&#39;ve built!</span>
<span class="cm">The proofs are erased in this presentation</span>
<span class="cm">and only the computational data are named.</span>
<span class="cm">-/</span>
<span class="k">#reduce</span> <span class="bp">@</span><span class="n">div_inv_monoid_rot_syms</span>
</pre></div>
</div>
</div></section>
<section id="id4">
<h4><span class="section-number">6.2.4.3. </span>group<a class="headerlink" href="#id4" title="Permalink to this heading">&#61633;</a></h4>
<p>And now, finally, we can instantiate the group class
for rot_syms elements.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23check%20group%0A%2F-%0Aclass%20group%20(G%20%3A%20Type%20u)%20extends%20div_inv_monoid%20G%20%3A%3D%0A(mul_left_inv%20%3A%20%E2%88%80%20a%20%3A%20G%2C%20a%E2%81%BB%C2%B9%20*%20a%20%3D%201)%0A-%2F%0A%23check%20%40group.mk%0A%2F-%0A%CE%A0%20%7BG%20%3A%20Type%20u_1%7D%0A%20%20(mul%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20(mul_assoc%20%3A%20%E2%88%80%20(a%20b%20c%20%3A%20G)%2C%0A%20%20a%20*%20b%20*%20c%20%3D%20a%20*%20(b%20*%20c))%0A%20%20(one%20%3A%20G)%0A%20%20(one_mul%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%201%20*%20a%20%3D%20a)%0A%20%20(mul_one%20%3A%20%E2%88%80%20(a%20%3A%20G)%2C%20a%20*%201%20%3D%20a)%0A%20%20(npow%20%3A%20%E2%84%95%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20(npow_zero'%20%3A%20auto_param%20(%E2%88%80%20(x%20%3A%20G)%2C%20npow%200%20x%20%3D%201)%0A%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(npow_succ'%20%3A%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(x%20%3A%20G)%2C%20npow%20n.succ%20x%20%3D%20x%20*%20npow%20n%20x)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(inv%20%3A%20G%20%E2%86%92%20G)%20(div%20%3A%20G%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20(div_eq_mul_inv%20%3A%20auto_param%20(%E2%88%80%20(a%20b%20%3A%20G)%2C%20a%20%2F%20b%20%3D%20a%20*%20b%E2%81%BB%C2%B9)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(zpow%20%3A%20%E2%84%A4%20%E2%86%92%20G%20%E2%86%92%20G)%0A%20%20(zpow_zero'%20%3A%20auto_param%20(%E2%88%80%20(a%20%3A%20G)%2C%20zpow%200%20a%20%3D%201)%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(zpow_succ'%20%3A%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20(int.of_nat%20n.succ)%20a%20%3D%20a%20*%20zpow%20(int.of_nat%20n)%20a)%0A%20%20%20%20%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%0A%20%20(zpow_neg'%20%3A%0A%20%20%20%20auto_param%20(%E2%88%80%20(n%20%3A%20%E2%84%95)%20(a%20%3A%20G)%2C%20zpow%20-%5B1%2B%20n%5D%20a%20%3D%20(zpow%20%E2%86%91(n.succ)%20a)%E2%81%BB%C2%B9)%0A%20%20%20%20%20%20(name.mk_string%20%22try_refl_tac%22%20name.anonymous))%2C%20(%E2%88%80%20(a%20%3A%20G)%2C%20a%E2%81%BB%C2%B9%20*%20a%20%3D%201)%20%E2%86%92%0A%20%20group%20G%0A-%2F%0A%0Alemma%20rot_left_inv%3A%20%20(%E2%88%80%20(a%20%3A%20rot_syms)%2C%20a%E2%81%BB%C2%B9%20*%20a%20%3D%201)%20%3A%3D%0Abegin%0Aassume%20a%2C%0Acases%20a%2C%0Arepeat%20%7Bexact%20rfl%7D%2C%0Aend%0A%0A%0Ainstance%20%3A%20group%20rot_syms%20%3A%3D%0A%E2%9F%A8%0A%20%20%20%20rot_mul%2C%0A%20%20rot_mul_assoc%2C%0A%20%201%2C%0A%20%20rot_left_ident%2C%0A%20%20rot_right_ident%2C%0A%20%20rot_npow%2C%0A%20%20rot_npow_zero%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20autoparam%0A%20%20rot_npow_succ%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20autoparam%0A%20%20rot_inv%2C%0A%20%20rot_div%2C%0A%20%20rot_div_inv%2C%0A%20%20rot_zpow%2C%0A%20%20rot_npow_zero%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20same%20proof%20again%0A%20%20rot_zpow_non_neg%2C%20%20%20%20%20%20%20%20%20%20%20%20%20--%20explicit%20typing%20needed%0A%20%20rot_zpow_neg%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20same%0A%20%20rot_left_inv%0A%E2%9F%A9" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_498.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">group</span>
<span class="c">/-</span>
<span class="cm">class group (G : Type u) extends div_inv_monoid G :=</span>
<span class="cm">(mul_left_inv : &#8704; a : G, a&#8315;&#185; * a = 1)</span>
<span class="cm">-/</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">group.mk</span>
<span class="c">/-</span>
<span class="cm">&#928; {G : Type u_1}</span>
<span class="cm">  (mul : G &#8594; G &#8594; G)</span>
<span class="cm">  (mul_assoc : &#8704; (a b c : G),</span>
<span class="cm">  a * b * c = a * (b * c))</span>
<span class="cm">  (one : G)</span>
<span class="cm">  (one_mul : &#8704; (a : G), 1 * a = a)</span>
<span class="cm">  (mul_one : &#8704; (a : G), a * 1 = a)</span>
<span class="cm">  (npow : &#8469; &#8594; G &#8594; G)</span>
<span class="cm">  (npow_zero&#39; : auto_param (&#8704; (x : G), npow 0 x = 1)</span>
<span class="cm">  (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (npow_succ&#39; :</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (x : G), npow n.succ x = x * npow n x) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (inv : G &#8594; G) (div : G &#8594; G &#8594; G)</span>
<span class="cm">  (div_eq_mul_inv : auto_param (&#8704; (a b : G), a / b = a * b&#8315;&#185;) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (zpow : &#8484; &#8594; G &#8594; G)</span>
<span class="cm">  (zpow_zero&#39; : auto_param (&#8704; (a : G), zpow 0 a = 1) (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (zpow_succ&#39; :</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (a : G), zpow (int.of_nat n.succ) a = a * zpow (int.of_nat n) a)</span>
<span class="cm">      (name.mk_string &quot;try_refl_tac&quot; name.anonymous))</span>
<span class="cm">  (zpow_neg&#39; :</span>
<span class="cm">    auto_param (&#8704; (n : &#8469;) (a : G), zpow -[1+ n] a = (zpow &#8593;(n.succ) a)&#8315;&#185;)</span>
<span class="cm">      (name.mk_string &quot;try_refl_tac&quot; name.anonymous)), (&#8704; (a : G), a&#8315;&#185; * a = 1) &#8594;</span>
<span class="cm">  group G</span>
<span class="cm">-/</span>

<span class="kd">lemma</span> <span class="n">rot_left_inv</span><span class="o">:</span>  <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">rot_syms</span><span class="o">),</span> <span class="n">a</span><span class="bp">&#8315;&#185;</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">a</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">a</span><span class="o">,</span>
<span class="n">repeat</span> <span class="o">{</span><span class="n">exact</span> <span class="n">rfl</span><span class="o">},</span>
<span class="kd">end</span>


<span class="kd">instance</span> <span class="o">:</span> <span class="n">group</span> <span class="n">rot_syms</span> <span class="o">:=</span>
<span class="o">&#10216;</span>
    <span class="n">rot_mul</span><span class="o">,</span>
  <span class="n">rot_mul_assoc</span><span class="o">,</span>
  <span class="mi">1</span><span class="o">,</span>
  <span class="n">rot_left_ident</span><span class="o">,</span>
  <span class="n">rot_right_ident</span><span class="o">,</span>
  <span class="n">rot_npow</span><span class="o">,</span>
  <span class="n">rot_npow_zero</span><span class="o">,</span>                <span class="c1">-- autoparam</span>
  <span class="n">rot_npow_succ</span><span class="o">,</span>                <span class="c1">-- autoparam</span>
  <span class="n">rot_inv</span><span class="o">,</span>
  <span class="n">rot_div</span><span class="o">,</span>
  <span class="n">rot_div_inv</span><span class="o">,</span>
  <span class="n">rot_zpow</span><span class="o">,</span>
  <span class="n">rot_npow_zero</span><span class="o">,</span>                <span class="c1">-- same proof again</span>
  <span class="n">rot_zpow_non_neg</span><span class="o">,</span>             <span class="c1">-- explicit typing needed</span>
  <span class="n">rot_zpow_neg</span><span class="o">,</span>                 <span class="c1">-- same</span>
  <span class="n">rot_left_inv</span>
<span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>What we&#8217;ve finally done is to show that we can impose a
group structure on elements of type rot_syms, given our
definitions of mul, inv, div, npow, and zpow.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=%23reduce%20r120%20*%20r120%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20multiplication%0A%23reduce%20r120%E2%81%BB%C2%B9%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20inverses%0A%23reduce%20r120%20%2F%20r240%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20division%0A%23reduce%20r120%5E4%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20exponentiation%20by%20nat%0A%23reduce%20r120%5E(4%3Aint)%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20exponentiation%20by%20non-negative%20int%0A%23reduce%20r120%5E(-4%3Aint)%20%20%20%20%20%20%20%20%20%20%20%20%20--%20exponentiation%20by%20negative%20int" target="_blank" tryitfile="../examples/A_05_Algebraic_Structures/unnamed_565.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#reduce</span> <span class="n">r120</span> <span class="bp">*</span> <span class="n">r120</span>               <span class="c1">-- multiplication</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">&#8315;&#185;</span>                    <span class="c1">-- inverses</span>
<span class="k">#reduce</span> <span class="n">r120</span> <span class="bp">/</span> <span class="n">r240</span>               <span class="c1">-- division</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">^</span><span class="mi">4</span>                    <span class="c1">-- exponentiation by nat</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">^</span><span class="o">(</span><span class="mi">4</span><span class="o">:</span><span class="n">int</span><span class="o">)</span>              <span class="c1">-- exponentiation by non-negative int</span>
<span class="k">#reduce</span> <span class="n">r120</span><span class="bp">^</span><span class="o">(</span><span class="bp">-</span><span class="mi">4</span><span class="o">:</span><span class="n">int</span><span class="o">)</span>             <span class="c1">-- exponentiation by negative int</span>
</pre></div>
</div>
</div></section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="A_04_Typeclasses.html" class="btn btn-neutral float-left" title="5. Typeclasses" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="genindex.html" class="btn btn-neutral float-right" title="Index" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kevin Sullivan.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>